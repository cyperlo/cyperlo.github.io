<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Opengauss 数据库连接池问题</title>
    <link href="/2025/12/29/Openguass%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <url>/2025/12/29/Openguass%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Opengauss-数据库连接池问题"><a href="#Opengauss-数据库连接池问题" class="headerlink" title="Opengauss 数据库连接池问题"></a>Opengauss 数据库连接池问题</h1><p>公司生产环境数据库采用<code>Opengauss</code>数据库，最近出现了服务器内存暴涨，并且一直降不下去，基于此现状进行分析</p><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>服务器是arm架构的麒麟系统，数据库每个节点4C8G，主从三节点，然后使用 druid 做数据库连接池，druid配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">validation-query:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span><br><span class="hljs-attr">test-while-idle:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">min-evictable-idle-time-millis:</span> <span class="hljs-number">300000</span> <span class="hljs-comment"># 参考值</span><br></code></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>当应用启动时，<code>druid</code>会初始化5个连接，并且最小存活5个连接，后端服务有70个pod，导致全部运行时会直接初始化210个连接，最大连接数可以达1400个。当使用连接的时候，连接会记录执行计划，会导致内存一直上涨（有上限的， 在SQL执行时，会将SQL进行预编译成PreparedStatement，比如 <code>SELECT * FROM TABLE WHERE id = ?</code>这种，不同传参其实执行计划是一个，所以是有上限）</p><p>这种问题点就是因为每个pod还有定时任务，就会导致初始化的连接会一直释放不掉，然后pod数量也多</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>临时解决<br>按理来说，像这种情况，pod如此多的情况还使用一个数据库是一个不正常的现象，如果条件允许可以多申请点资源，因为连接不释放才是正常的</p></blockquote><p>为了解决连接一直占用的问题，我这边新增了几个<code>druid</code>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">max-evictable-idle-time-millis:</span> <span class="hljs-number">1800000</span> <span class="hljs-comment"># 参考值</span><br><span class="hljs-attr">keepAlive:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>设置了<code>druid</code>中连接最大的空闲时间，当最大空闲时间达到就可以回收这个连接，使用<code>keepAlive</code>，可以保证连接存活，因为设置了<code>minIdle</code>，当回收了连接，<code>druid</code>会新建被回收连接的数量</p><blockquote><p>当连接使用了，最大空闲时间会被重置，直到重新达到最大空闲时间才会被回收</p></blockquote><h2 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h2><ol><li>新建中</li><li>Idle: 空闲可用</li><li>Active</li><li>回收中 </li><li>已关闭</li></ol><h2 id="查询当前有多少链接"><a href="#查询当前有多少链接" class="headerlink" title="查询当前有多少链接"></a>查询当前有多少链接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> pg_stat_activity;<br></code></pre></td></tr></table></figure><p>关键字段：</p><ol><li>backend_start: 建立连接的时间</li><li>usename: 连接使用人</li></ol><h2 id="JDBC-推荐配置"><a href="#JDBC-推荐配置" class="headerlink" title="JDBC 推荐配置"></a>JDBC 推荐配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:opengauss//host1:port1,host2:port2,host3:port3/db?currentSchema=public&amp;autoReconnect=true&amp;targetServerType=master&amp;forceTargetServerSlave=true</span><br></code></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>我们数据库会有一层F5，原则上直接连接F5的ip其实也可以实现建立连接</p><table><thead><tr><th>连接信息</th><th>状态</th></tr></thead><tbody><tr><td>使用F5连接</td><td>连接会自动与主库发生连接，当主从发生切换，等几分钟后会识别到，然后重新与主库建立连接</td></tr><tr><td>指定多个连接信息</td><td>同F5</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于<code>Druid</code>其实能实现很多功能，包含初始化连接，通过<code>PreparedStatement</code>可以减少服务器内存</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>连接池</tag>
      
      <tag>Opengauss</tag>
      
      <tag>postgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录认证</title>
    <link href="/2025/11/19/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
    <url>/2025/11/19/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>Cookie</strong> 是一种在 Web 浏览器中存储数据的小文件，主要用于在用户与网站之间传递状态信息。它们使得 Web 服务器可以记住用户的状态或信息，并在后续请求中恢复这些状态。Cookies 被广泛用于各种目的，包括用户认证、会话管理、个性化设置以及跟踪用户行为等。</p><p><strong>Cookie</strong> 是由 <strong>Web</strong> 服务器通过 <strong>HTTP</strong> 响应头发送到用户浏览器的一个小的文本数据块。浏览器会将其存储在本地，当用户访问相同网站时，浏览器会将这些 <strong>Cookie</strong> 附带在请求中<code>发送回服务器</code>。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p><strong>名称（Name）</strong>: Cookie 的标识符。</p></li><li><p><strong>值（Value）</strong>: 与名称相关联的数据。</p></li><li><p><strong>过期时间（Expires）</strong>: Cookie 的有效期，浏览器在此时间之前会保持 Cookie 的存在。如果没有设置过期时间，Cookie 是会话 Cookie，会在浏览器关闭时删除。</p></li><li><p><strong>路径（Path）</strong>: 指定 Cookie 适用的 URL 路径。</p></li><li><p><strong>域（Domain）</strong>: 指定 Cookie 可用的域名。</p></li><li><p><strong>安全标志（Secure）</strong>: 指示 Cookie 只能通过 HTTPS 协议传输。</p><ul><li><strong>HttpOnly 标志</strong>: 防止 JavaScript 访问 Cookie，以增加安全性。</li></ul></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><ul><li><strong>用户登录</strong>: 记录用户的登录状态，避免每次访问都要求重新登录。</li><li><strong>购物车</strong>: 在电商网站上存储购物车的内容。</li></ul><h4 id="用户个性化"><a href="#用户个性化" class="headerlink" title="用户个性化"></a>用户个性化</h4><ul><li><strong>用户设置</strong>: 记录用户的语言偏好、主题设置等个性化信息。</li><li><strong>推荐系统</strong>: 根据用户的行为历史提供个性化推荐。</li></ul><h4 id="跟踪与分析"><a href="#跟踪与分析" class="headerlink" title="跟踪与分析"></a>跟踪与分析</h4><ul><li><strong>用户行为分析</strong>: 跟踪用户在网站上的活动，以分析用户行为和网站性能。</li><li><strong>广告定向</strong>: 跟踪用户的兴趣，以展示相关的广告。</li></ul><h3 id="如何使用-Cookie"><a href="#如何使用-Cookie" class="headerlink" title="如何使用 Cookie"></a>如何使用 Cookie</h3><p>在 Go 的 <code>net/http</code> 包中，你可以通过 HTTP 请求和响应操作 Cookies。以下是一些基本操作的示例：</p><h4 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:     <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:    <span class="hljs-string">&quot;john_doe&quot;</span>,<br>        Path:     <span class="hljs-string">&quot;/&quot;</span>,<br>        MaxAge:   <span class="hljs-number">3600</span>, <span class="hljs-comment">// 1 hour</span><br>        HttpOnly: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 不能被 JavaScript 访问</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been set!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/set-cookie&quot;</span>, setCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 读取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Cookie not found&quot;</span>, http.StatusNotFound)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            http.Error(w, <span class="hljs-string">&quot;Error retrieving cookie&quot;</span>, http.StatusInternalServerError)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 的值</span><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie value: &quot;</span> + cookie.Value))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/read-cookie&quot;</span>, readCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteCookieHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个新的 Cookie，并设置过期时间</span><br>    cookie := &amp;http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;username&quot;</span>,<br>        Value:   <span class="hljs-string">&quot;&quot;</span>,<br>        Path:    <span class="hljs-string">&quot;/&quot;</span>,<br>        Expires: time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">// 设置为过去的时间</span><br>    &#125;<br><br>    <span class="hljs-comment">// 删除 Cookie</span><br>    http.SetCookie(w, cookie)<br><br>    w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Cookie has been deleted!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/delete-cookie&quot;</span>, deleteCookieHandler)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>Session（会话）</strong> 是一种在用户与 Web 应用程序之间保持状态的机制，通常用于存储和管理用户的状态信息。与 Cookie 不同，Session 数据通常存储在服务器端，而非客户端。Session 通常用来跟踪用户的会话状态、存储用户数据、处理认证和授权等</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Session 是一段时间内用户与服务器之间的交互。在用户首次访问网站时，服务器创建一个 Session，并为其分配一个唯一的标识符（通常是一个随机生成的字符串，称为 Session ID）。这个 Session ID 通常会被存储在用户的 Cookie 中，随着每次请求被发送到服务器。服务器使用这个 Session ID 来查找并检索对应的会话数据。</p><p>组成:</p><ul><li><strong>Session ID</strong>: 唯一标识用户会话的标识符。</li><li><strong>Session 数据</strong>: 与用户相关的信息，比如用户身份、偏好设置、购物车内容等。</li><li><strong>Session 存储</strong>: Session 数据的存储方式，通常可以是内存、数据库、文件系统等。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>创建 Session</strong>: 用户首次访问应用时，服务器生成一个新的 Session ID，并创建一个新的会话存储区域。</p></li><li><p><strong>存储 Session 数据</strong>: 服务器将与用户相关的数据存储在会话中。</p></li><li><p><strong>传递 Session ID</strong>: 服务器将 Session ID 发送给客户端，通常通过 Cookie。</p></li><li><p><strong>识别 Session</strong>: 客户端在后续请求中将 Session ID 发送回服务器，服务器根据 Session ID 查找相应的会话数据。</p></li><li><p><strong>更新 Session 数据</strong>: 服务器可以更新会话数据，用户的每个请求都可以修改这些数据。</p></li><li><p><strong>销毁 Session</strong>: 会话可以在用户登出、会话超时或者服务器主动清除时被销毁。</p></li></ol><h3 id="Session-的用途"><a href="#Session-的用途" class="headerlink" title="Session 的用途"></a>Session 的用途</h3><h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4><ul><li><strong>登录状态管理</strong>: 记录用户的登录状态，使得用户在浏览不同页面时不需要重新登录。</li></ul><h4 id="会话数据存储"><a href="#会话数据存储" class="headerlink" title="会话数据存储"></a>会话数据存储</h4><ul><li><strong>用户设置</strong>: 存储用户的个性化设置和偏好。</li><li><strong>购物车</strong>: 在电子商务网站上存储用户的购物车内容。</li></ul><h4 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h4><ul><li><strong>表单数据</strong>: 在多步表单过程中保持用户填写的数据。</li></ul><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h2><p>Cookie 和 Session 的关系 </p><p><strong>服务器创建和管理 Session</strong>: 服务器创建 Session，并为每个会话分配唯一的 Session ID。</p><p><strong>浏览器存储和发送 Cookie</strong>: 服务器通过 Cookie 将 Session ID 发送到浏览器，浏览器将 Cookie 随后每次请求自动发送回服务器。</p><p><strong>服务器使用 Session ID 访问 Session 数据</strong>: 服务器通过 Cookie 中的 Session ID 查找和操作对应的 Session 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟的 session 存储 (在真实应用中，通常会使用数据库或内存缓存)</span><br><span class="hljs-keyword">var</span> sessionStore = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/welcome&quot;</span>, welcomeHandler)<br><br>    fmt.Println(<span class="hljs-string">&quot;Server started at :8080&quot;</span>)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// 登录处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 模拟用户登录并生成 Session ID</span><br>    sessionID := <span class="hljs-string">&quot;123456&quot;</span> <span class="hljs-comment">// 在真实场景下，这应该是一个随机生成的唯一 ID</span><br>    userID := <span class="hljs-string">&quot;user42&quot;</span>    <span class="hljs-comment">// 假设这是从数据库中查到的用户ID</span><br><br>    <span class="hljs-comment">// 将 Session ID 和 用户ID 存储到 sessionStore 中</span><br>    sessionStore[sessionID] = userID<br><br>    <span class="hljs-comment">// 将 Session ID 写入 Cookie</span><br>    cookie := http.Cookie&#123;<br>        Name:    <span class="hljs-string">&quot;session_id&quot;</span>,<br>        Value:   sessionID,<br>        Expires: time.Now().Add(<span class="hljs-number">24</span> * time.Hour), <span class="hljs-comment">// 设置 Cookie 有效期为24小时</span><br>    &#125;<br>    http.SetCookie(w, &amp;cookie)<br><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;User logged in. Session ID set: %s\n&quot;</span>, sessionID)<br>&#125;<br><br><span class="hljs-comment">// 欢迎页面处理程序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">welcomeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// 从请求中获取 Cookie</span><br>    cookie, err := r.Cookie(<span class="hljs-string">&quot;session_id&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> err == http.ErrNoCookie &#123;<br>            <span class="hljs-comment">// 如果没有找到 session_id Cookie</span><br>            http.Error(w, <span class="hljs-string">&quot;Session not found&quot;</span>, http.StatusUnauthorized)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        http.Error(w, <span class="hljs-string">&quot;Internal Server Error&quot;</span>, http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用 Cookie 中的 Session ID 查找对应的用户</span><br>    sessionID := cookie.Value<br>    userID, exists := sessionStore[sessionID]<br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        http.Error(w, <span class="hljs-string">&quot;Invalid Session ID&quot;</span>, http.StatusUnauthorized)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果 Session ID 有效，显示欢迎信息</span><br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome back, User ID: %s\n&quot;</span>, userID)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h1><blockquote><p>单点登录有多种方式，常见的形式有</p><ol><li>基于 Cookie</li><li>基于 Token</li><li>基于重定向</li><li>基于Session</li><li>LDAP</li></ol></blockquote><h2 id="基于-Cookie"><a href="#基于-Cookie" class="headerlink" title="基于 Cookie"></a>基于 Cookie</h2><p><strong>原理</strong>：同一域下的子系统<code>共享 Cookie</code>。用户在一个子系统登录后，生成的 Cookie 可以被其他子系统读取，从而实现单点登录。</p><p><strong>特点</strong>：</p><ul><li>适用于同域名的多个子域系统（如 <code>a.example.com</code> 和 <code>b.example.com</code>）。</li><li>配置简单，但无法跨域。</li></ul><p><strong>限制</strong>：Cookie 受浏览器和域限制，无法在跨域环境下直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 用户访问系统<br>condA=&gt;condition: 是否已登录？<br>condB=&gt;condition: 是否共享 Cookie 可用？<br>login=&gt;operation: 重定向到 SSO 登录<br>generate=&gt;operation: 生成共享 Cookie<br>redirectA=&gt;operation: 重定向回系统 A<br>accessA=&gt;operation: 系统 A 允许访问<br>accessB=&gt;operation: 系统 B 允许访问<br><br>st-&gt;condA<br>condA(no)-&gt;login<br>login-&gt;generate<br>generate-&gt;redirectA<br>redirectA-&gt;accessA<br>condA(yes)-&gt;condB<br>condB(yes)-&gt;accessB<br>condB(no)-&gt;login<br><br><br><br></code></pre></td></tr></table></figure><h3 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h3><ol><li>SSO 服务器<ul><li>负责用户认证</li><li>登录成功后生成一个共享的 Cookie（如 <code>sso_token</code>），该 Cookie 设置为 <code>Domain=.example.com</code>，以便子系统共享。</li></ul></li><li>子系统 A 和 B<ul><li>用户访问时，检查共享 Cookie 是否存在并有效</li><li>若无效，重定向用户到 SSO 服务器登录</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><blockquote><p>用 Golang 实现</p><p>​可以增加 target_url 当 SSO 服务认证完成之后跳转到原页面</p></blockquote><ol><li><p>SSO 服务端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 模拟用户登录逻辑</span><br>username := r.FormValue(<span class="hljs-string">&quot;username&quot;</span>)<br>password := r.FormValue(<span class="hljs-string">&quot;password&quot;</span>)<br><br><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; password == <span class="hljs-string">&quot;pass&quot;</span> &#123;<br><span class="hljs-comment">// 登录成功，设置 Cookie，Domain 为 .example.com</span><br>http.SetCookie(w, &amp;http.Cookie&#123;<br>Name:     <span class="hljs-string">&quot;sso_token&quot;</span>,<br>Value:    <span class="hljs-string">&quot;random-generated-token&quot;</span>,<br>Domain:   <span class="hljs-string">&quot;.example.com&quot;</span>, <span class="hljs-comment">// 共享 Cookie 的关键</span><br>Path:     <span class="hljs-string">&quot;/&quot;</span>,<br>Expires:  time.Now().Add(<span class="hljs-number">24</span> * time.Hour),<br>HttpOnly: <span class="hljs-literal">true</span>,<br>&#125;)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Login successful!&quot;</span>))<br><span class="hljs-keyword">return</span><br>&#125;<br>http.Error(w, <span class="hljs-string">&quot;Invalid credentials&quot;</span>, http.StatusUnauthorized)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子系统 A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 检查共享 Cookie</span><br>cookie, err := r.Cookie(<span class="hljs-string">&quot;sso_token&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 未登录，重定向到 SSO 服务器</span><br>http.Redirect(w, r, <span class="hljs-string">&quot;http://sso.example.com:8080/login&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 验证 token 是否有效（此处简化，假设有效）</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome to System A! Your token: %s&quot;</span>, cookie.Value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>子系统 B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 检查共享 Cookie</span><br>cookie, err := r.Cookie(<span class="hljs-string">&quot;sso_token&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 未登录，重定向到 SSO 服务器</span><br>http.Redirect(w, r, <span class="hljs-string">&quot;http://sso.example.com:8080/login&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 验证 token 是否有效（此处简化，假设有效）</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome to System B! Your token: %s&quot;</span>, cookie.Value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8082&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li><p>启动 SSO 服务（端口 8080）、子系统 A（8081）和子系统 B（8082）。</p></li><li><p>在浏览器访问 <code>http://system-a.example.com:8081/</code>：</p><ul><li>第一次访问会跳转到 <code>http://sso.example.com:8080/login</code> 登录。</li></ul></li><li><p>登录后，带有 <code>sso_token</code> 的共享 Cookie 被写入。</p></li><li><p>再访问 <code>http://system-b.example.com:8082/</code> 时，无需登录即可访问。</p></li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ol><li><strong>共享 Cookie 的域配置</strong>：<ul><li><code>Domain=.example.com</code>，确保所有子域都能访问同一 Cookie。</li></ul></li><li><strong>安全考虑</strong>：<ul><li>使用 <code>HttpOnly</code> 和 <code>Secure</code> 标志。</li><li>实际系统中应对 <code>sso_token</code> 进行加密签名，并在服务端验证。</li></ul></li><li><strong>缺陷</strong>：<ul><li>只能用于同一顶级域名及其子域，无法支持跨域。</li></ul></li></ol><h2 id="基于-Token"><a href="#基于-Token" class="headerlink" title="基于 Token"></a>基于 Token</h2><p><strong>原理</strong>：用户登录后获取一个令牌（如 JWT），此令牌在后续请求中被带上，验证用户身份。</p><p><strong>特点</strong>：</p><ul><li>无需依赖 Cookie，可通过 HTTP Header 携带 Token。</li><li>适合分布式架构，尤其是前后端分离系统。</li></ul><p><strong>典型协议</strong>：OAuth 2.0 和 OpenID Connect（OIDC）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 用户访问系统<br>checkToken=&gt;condition: 是否有 Token？<br>redirectToSSO=&gt;operation: 重定向到 SSO 登录<br>login=&gt;operation: 用户登录<br>generateToken=&gt;operation: SSO 生成 Token<br>returnToken=&gt;operation: 返回 Token 并重定向回系统<br>validateToken=&gt;operation: 系统验证 Token<br>accessGranted=&gt;operation: 允许访问<br>accessDenied=&gt;operation: 拒绝访问<br><br>st-&gt;checkToken<br>checkToken(no)-&gt;redirectToSSO<br>redirectToSSO-&gt;login<br>login-&gt;generateToken<br>generateToken-&gt;returnToken<br>returnToken-&gt;validateToken<br>checkToken(yes)-&gt;validateToken<br>validateToken(yes)-&gt;accessGranted<br>validateToken(no)-&gt;accessDenied<br><br></code></pre></td></tr></table></figure><h3 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h3><ol><li><strong>认证服务器</strong>：<ul><li>用户登录后生成一个 Token（如 JWT）。</li><li>返回 Token 给客户端。</li></ul></li><li><strong>子系统</strong>：<ul><li>客户端请求子系统时，将 Token 放在请求头中（如 <code>Authorization: Bearer &lt;token&gt;</code>）。</li><li>子系统通过解析或验证 Token 判断用户身份。</li></ul></li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><ol><li><p>认证服务器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/golang-jwt/jwt/v5&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> jwtKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;your-secret-key&quot;</span>)<br><br><span class="hljs-comment">// 用户登录信息结构</span><br><span class="hljs-keyword">type</span> Credentials <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// JWT Claims</span><br><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot;`</span><br>jwt.RegisteredClaims<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">var</span> creds Credentials<br>err := json.NewDecoder(r.Body).Decode(&amp;creds)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || creds.Username == <span class="hljs-string">&quot;&quot;</span> || creds.Password == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Invalid request&quot;</span>, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 模拟用户验证</span><br><span class="hljs-keyword">if</span> creds.Username != <span class="hljs-string">&quot;user&quot;</span> || creds.Password != <span class="hljs-string">&quot;pass&quot;</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 创建 Token</span><br>expirationTime := time.Now().Add(<span class="hljs-number">1</span> * time.Hour)<br>claims := &amp;Claims&#123;<br>Username: creds.Username,<br>RegisteredClaims: jwt.RegisteredClaims&#123;<br>ExpiresAt: jwt.NewNumericDate(expirationTime),<br>&#125;,<br>&#125;<br>token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)<br>tokenString, err := token.SignedString(jwtKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Could not create token&quot;</span>, http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回 Token</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;token&quot;:&quot;`</span> + tokenString + <span class="hljs-string">`&quot;&#125;`</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>子系统 A 和 B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><br><span class="hljs-string">&quot;github.com/golang-jwt/jwt/v5&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> jwtKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;your-secret-key&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*Claims, <span class="hljs-type">error</span>) &#123;<br>claims := &amp;Claims&#123;&#125;<br>token, err := jwt.ParseWithClaims(tokenString, claims, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || !token.Valid &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>authHeader := r.Header.Get(<span class="hljs-string">&quot;Authorization&quot;</span>)<br><span class="hljs-keyword">if</span> !strings.HasPrefix(authHeader, <span class="hljs-string">&quot;Bearer &quot;</span>) &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 提取 Token</span><br>tokenString := strings.TrimPrefix(authHeader, <span class="hljs-string">&quot;Bearer &quot;</span>)<br>claims, err := validateToken(tokenString)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 返回资源</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome %s! You have accessed the resource.&quot;</span>, claims.Username)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/resource&quot;</span>, resourceHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤-1"><a href="#测试步骤-1" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li><p>启动认证服务器（端口 8080）和子系统 A（端口 8081）。</p></li><li><p>使用工具（如 <code>curl</code> 或 Postman）发送登录请求：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scilab">bash<br><br><br>复制代码<br>curl -X POST http:<span class="hljs-comment">//localhost:8080/login \</span><br>-H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>-d <span class="hljs-string">&#x27;&#123;&quot;</span>username<span class="hljs-string">&quot;:&quot;</span>user<span class="hljs-string">&quot;, &quot;</span>password<span class="hljs-string">&quot;:&quot;</span>pass<span class="hljs-string">&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>返回结果（示例）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span><br><br>复制代码<br>&#123;<span class="hljs-string">&quot;token&quot;</span>:<span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用返回的 Token 访问子系统 A 的资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash<br><br><br>复制代码<br>curl http://localhost:8081/resource \<br>-H <span class="hljs-string">&quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;</span><br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">plaintext<br><br><br>复制代码<br>Welcome <span class="hljs-keyword">user</span>! You have accessed the resource.<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ol><li><strong>Token 携带方式</strong>：<ul><li>通常通过 HTTP Header（<code>Authorization: Bearer &lt;token&gt;</code>）。</li><li>也可以通过 URL 参数（不推荐）或 Cookie。</li></ul></li><li><strong>Token 有效性</strong>：<ul><li>使用 JWT 的 <code>exp</code> 字段设置过期时间。</li><li>子系统应验证 Token 是否过期或是否伪造。</li></ul></li><li><strong>安全性</strong>：<ul><li>使用 HTTPS 确保 Token 传输安全。</li><li>Token 中不要存储敏感信息。</li></ul></li><li><strong>扩展性</strong>：<ul><li>子系统也可以向认证服务器验证 Token 是否已失效（可选），子系统校验的话必须采用对称加密算法。</li><li>可为 Token 添加角色权限字段以支持更细粒度的访问控制。</li></ul></li></ol><hr><p>这种基于 Token 的 SSO 机制非常适合前后端分离或分布式系统，支持跨域，也易于扩展为微服务架构的一部分。</p><h2 id="基于-Token-2"><a href="#基于-Token-2" class="headerlink" title="基于 Token 2"></a>基于 Token 2</h2><blockquote><p>上述 基于 Token 还有一种变种 由客户端（子系统）产生 Token， 然后其他系统拿token去提供token的子系统验证。</p></blockquote><p><img src="https://i.imgur.com/72FJyDK.png" alt="image-20241128133349175"></p><p>例子(以群杰系统为例)：A 系统想要访问 B系统的接口或则页面</p><ol><li>A 产生一个 token</li><li>A 请求 B 系统的认证接口<ol><li>请求参数带上 A 系统产生的token 和 需要跳转的url(target_url：b系统的接口或则页面)</li></ol></li><li>A 基于 token 提供一个能解析 token 的请求。然后能返回用户信息</li><li>B 在 上面第二步 A 请求 B 的接口的时候，调用 A 提供的解析 token 的请求，获取到用户信息</li><li>然后 B 在经历自己的业务后，重定向到 target_url（b系统的页面）</li></ol><h2 id="基于重定向"><a href="#基于重定向" class="headerlink" title="基于重定向"></a>基于重定向</h2><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><ol><li><strong>用户未登录时</strong>：<ul><li>用户访问 <code>System A</code> 或 <code>System B</code>。</li><li>检测无有效登录状态，重定向到认证服务器登录页面。</li></ul></li><li><strong>登录成功后</strong>：<ul><li>认证服务器生成一个登录票据（如 <code>ticket</code> 或 <code>JWT</code>）。</li><li>将用户重定向回原子系统，同时附加 <code>ticket</code>。</li></ul></li><li><strong>子系统校验票据</strong>：<ul><li>子系统将 <code>ticket</code> 发送给认证服务器验证。</li><li>验证通过后为用户创建会话并允许访问资源。</li></ul></li></ol><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><ol><li><p>SSO 服务器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> tokenStore = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 假设的令牌存储</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loginHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> r.Method == http.MethodPost &#123;<br>username := r.FormValue(<span class="hljs-string">&quot;username&quot;</span>)<br>password := r.FormValue(<span class="hljs-string">&quot;password&quot;</span>)<br><br><span class="hljs-comment">// 简单的身份验证示例</span><br><span class="hljs-keyword">if</span> username == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; password == <span class="hljs-string">&quot;pass&quot;</span> &#123;<br>token := fmt.Sprintf(<span class="hljs-string">&quot;token-%d&quot;</span>, time.Now().Unix())<br>tokenStore[username] = token<br>http.Redirect(w, r, r.FormValue(<span class="hljs-string">&quot;redirect_uri&quot;</span>)+<span class="hljs-string">&quot;?token=&quot;</span>+token, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.Error(w, <span class="hljs-string">&quot;Invalid credentials&quot;</span>, http.StatusUnauthorized)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.ServeFile(w, r, <span class="hljs-string">&quot;login.html&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, loginHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>子系统</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">homeHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>token := r.URL.Query().Get(<span class="hljs-string">&quot;token&quot;</span>)<br><span class="hljs-keyword">if</span> token == <span class="hljs-string">&quot;&quot;</span> &#123;<br>http.Redirect(w, r, <span class="hljs-string">&quot;http://localhost:8080/login?redirect_uri=http://localhost:8081/home&quot;</span>, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 验证令牌</span><br><span class="hljs-comment">// 可以拿 Token 去 SSO 服务器验证</span><br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/home&quot;</span>, homeHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8081&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="测试步骤-2"><a href="#测试步骤-2" class="headerlink" title="测试步骤"></a>测试步骤</h3><h2 id="基于-Session"><a href="#基于-Session" class="headerlink" title="基于 Session"></a>基于 Session</h2><p>常见的分布式 session 即可</p><p>一般是集群使用</p><h2 id="LDAP-认证"><a href="#LDAP-认证" class="headerlink" title="LDAP 认证"></a>LDAP 认证</h2><h1 id="Oauth-2-0"><a href="#Oauth-2-0" class="headerlink" title="Oauth 2.0"></a>Oauth 2.0</h1><blockquote><p>着重介绍如何接入， 及授权的过程</p><p>不详细介绍安全部分</p></blockquote><h2 id="背景及使用场景"><a href="#背景及使用场景" class="headerlink" title="背景及使用场景"></a>背景及使用场景</h2><ul><li>关于授权的开放网络标准，目前的版本是2.0版</li><li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></li><li>Oauth2.0 主要用于授权</li><li>核心就是向第三方颁发令牌，用于访问资源</li></ul><h2 id="四种获取授权码的方式"><a href="#四种获取授权码的方式" class="headerlink" title="四种获取授权码的方式"></a>四种获取授权码的方式</h2><ul><li>授权码（authorization code）</li><li>隐藏式（implicit）</li><li>密码式（resource owner password credentials）</li><li>凭证式（client credentials）</li></ul><table><thead><tr><th>方式</th><th>适用范围</th><th>特点</th></tr></thead><tbody><tr><td>授权码</td><td>有后端的 Web 应用</td><td>最常用最安全</td></tr><tr><td>隐藏式</td><td>纯前端 Web 应用</td><td>所有步骤在浏览器完成</td></tr><tr><td>密码式</td><td>高度信任应用</td><td>直接获取到用户名和密码</td></tr><tr><td>凭证式</td><td>命令行应用</td><td></td></tr></tbody></table><h3 id="授权码-（authorization-code）"><a href="#授权码-（authorization-code）" class="headerlink" title="授权码 （authorization  code）"></a>授权码 （authorization  code）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>最常用</li><li>安全性最高</li><li>适用于那些有后端的 Web 应用</li></ul><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p>A网站提供一个链接，用户点击后就会跳转到 B 网站。如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/authorize?<br>  response<span class="hljs-emphasis">_type=code&amp;</span><br><span class="hljs-emphasis">  client_</span>id=CLIENT<span class="hljs-emphasis">_ID&amp;</span><br><span class="hljs-emphasis">  redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL&amp;</span><br><span class="hljs-emphasis">  scope=read</span><br></code></pre></td></tr></table></figure><ul><li><code>response_type</code>: <code>code</code> 要返回授权码</li><li><code>client_id</code>: 让 B 知道是谁在请求</li><li><code>redirect_url</code>: B 接受或者拒绝请求后的跳转网址</li><li><code>scope</code>: 表示请求的授权范围</li></ul></li><li><p>用户跳转之后， B 网站会要求用户登录，然后询问是否愿意给予 A 网站授权。用户表示同意，这时 B 网站会跳会<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">https://a.com/callback?code=AUTHORIZATION<span class="hljs-emphasis">_CODE</span><br></code></pre></td></tr></table></figure></li><li><p>A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs md">https://b.com/oauth/token?<br> client<span class="hljs-emphasis">_id=CLIENT_</span>ID&amp;<br> client<span class="hljs-emphasis">_secret=CLIENT_</span>SECRET&amp;<br> grant<span class="hljs-emphasis">_type=authorization_</span>code&amp;<br> code=AUTHORIZATION<span class="hljs-emphasis">_CODE&amp;</span><br><span class="hljs-emphasis"> redirect_</span>uri=CALLBACK<span class="hljs-emphasis">_URL</span><br></code></pre></td></tr></table></figure><ul><li><code>client_id client_secret</code>: 用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）</li><li><code>grant_type</code>: <code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码</li><li><code>code</code>: 上一步拿到的授权码</li><li><code>redirect_uri</code>: 与步骤1中的<code>redirect_uri</code>一致</li></ul></li><li><p>B 网站收到请求以后，就会颁发令牌。具体做法是发送一段 JSON 数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">100101</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>第三方登录<ul><li>以允许 github 第三方登录举例<ul><li>实际为需要授权访问用户信息</li></ul></li><li><a href="https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps">https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps</a></li><li>Github 只支持授权码方式</li></ul></li></ul><h3 id="用户使用流程"><a href="#用户使用流程" class="headerlink" title="用户使用流程"></a>用户使用流程</h3><ol><li>A 网站让用户跳转到 GitHub</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码</li><li>A 网站使用授权码，向 GitHub 请求令牌</li><li>GitHub 返回令牌</li><li>A 网站使用令牌，向 GitHub 请求用户数据</li></ol><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ol><li>应用登记<ol><li>一个应用要求 Oauth 授权，必须先到对方网站登记，让对方知道是谁在请求</li><li>提交登记之后，会返回客户端 ID 和客户端秘钥</li></ol></li><li>开发跳转部分:      </li><li>开发回调接口（上述的步骤3）<ol><li>拿着授权码访问 Github 索要 AccessToken:      </li><li>设置重定向地址，重定向至主页</li></ol></li><li>后续便可以通过 AccessToken 获取用户信息资源<ol><li>拿着 AccessToken 向 github 获取用户信息:</li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Oauth 在第三方登录例子中，仅用于获取用户信息，但不仅限于此</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   cli := httpcli.New()<br>   engine := gin.Default()<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         Code <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      req, err := request.Post(<span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_id&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;client_secret&quot;</span>, <span class="hljs-string">&quot;---&quot;</span>).<br>         AddQuery(<span class="hljs-string">&quot;code&quot;</span>, code.Code).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> AccessTokenResp <span class="hljs-keyword">struct</span> &#123;<br>         AccessToken <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;access_token&quot;`</span><br>         Scope       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;scope&quot;`</span><br>         TokenType   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;token_type&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> accessTokenResp AccessTokenResp<br>      _, err = cli.DoDecodeJSON(req, &amp;accessTokenResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = accessTokenResp.AccessToken<br><br>      req, err = request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessTokenResp.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;https://github.com/login/oauth/authorize?client_id=c263072748e5306ad088&amp;redirect_uri=http://localhost:8080/oauth/redirect\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合现有库"><a href="#结合现有库" class="headerlink" title="结合现有库"></a>结合现有库</h3><blockquote><p>可以帮你简化一部分工作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;context&quot;</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;net/http&quot;</span><br><br>   <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>   <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>   <span class="hljs-string">&quot;golang.org/x/oauth2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   oauthConfig := oauth2.Config&#123;<br>      ClientID:     <span class="hljs-string">&quot;---&quot;</span>,<br>      ClientSecret: <span class="hljs-string">&quot;---&quot;</span>,<br>      Endpoint: oauth2.Endpoint&#123;<br>         AuthURL:  <span class="hljs-string">&quot;https://github.com/login/oauth/authorize&quot;</span>,<br>         TokenURL: <span class="hljs-string">&quot;https://github.com/login/oauth/access_token&quot;</span>,<br>      &#125;,<br>      RedirectURL: <span class="hljs-string">&quot;http://localhost:8080/oauth/redirect&quot;</span>,<br>      Scopes:      <span class="hljs-literal">nil</span>,<br>   &#125;<br><br>   state := <span class="hljs-string">&quot;a-random-string&quot;</span><br><br>   cli := httpcli.New()<br>   engine := gin.Default()<br>   engine.GET(<span class="hljs-string">&quot;/github_login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      url := oauthConfig.AuthCodeURL(state)<br>      ctx.Redirect(http.StatusTemporaryRedirect, url)<br>   &#125;)<br><br>   <span class="hljs-keyword">var</span> accessToken <span class="hljs-type">string</span><br><br>   engine.GET(<span class="hljs-string">&quot;/oauth/redirect&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      <span class="hljs-keyword">type</span> CodeS <span class="hljs-keyword">struct</span> &#123;<br>         State <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;state&quot; binding:&quot;required&quot;`</span><br>         Code  <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;code&quot; binding:&quot;required&quot;`</span><br>      &#125;<br><br>      <span class="hljs-keyword">var</span> code CodeS<br>      <span class="hljs-keyword">if</span> err := ctx.ShouldBindQuery(&amp;code); err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">400</span>&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      token, err := oauthConfig.Exchange(context.Background(), code.Code)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br><br>      req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>         AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+token.AccessToken).<br>         Build()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      accessToken = token.AccessToken<br>      <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>         Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;login&quot;`</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>      _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <br>      ctx.SetCookie(<span class="hljs-string">&quot;username&quot;</span>, userInfoResp.Name, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>      ctx.Redirect(http.StatusFound, <span class="hljs-string">&quot;http://localhost:8080/homepage&quot;</span>)<br>   &#125;)<br><br>   engine.GET(<span class="hljs-string">&quot;/homepage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>      username, err := ctx.Cookie(<span class="hljs-string">&quot;username&quot;</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> errors.Is(err, http.ErrNoCookie) &#123;<br>            ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;p&gt;请先登录&lt;/p&gt;\n&lt;a href=\&quot;http://localhost:8080/github_login\&quot;&gt;github 登录&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">var</span> company <span class="hljs-type">string</span><br>      <span class="hljs-keyword">if</span> accessToken != <span class="hljs-string">&quot;&quot;</span> &#123;<br>         req, err := request.Get(<span class="hljs-string">&quot;https://api.github.com/user&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>            AddHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;token &quot;</span>+accessToken).<br>            Build()<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br><br>         <span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">interface</span>&#123;&#125;<br>         <span class="hljs-keyword">var</span> userInfoResp UserInfo<br>         _, err = cli.DoDecodeJSON(req, &amp;userInfoResp)<br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ctx.JSON(http.StatusInternalServerError, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         company = userInfoResp.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;company&quot;</span>].(<span class="hljs-type">string</span>)<br>      &#125;<br>      ctx.Data(http.StatusOK, <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>, []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\&quot;utf-8\&quot;&gt;\n&lt;title&gt;第三方登录 demo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;Hello %s!&lt;/p&gt;\n&lt;p&gt;Company: %s&lt;/p&gt;    &lt;/body&gt;\n&lt;/html&gt;&quot;</span>, username, company)))<br>   &#125;)<br><br>   engine.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Oauth2-0-和-单点登录的关系"><a href="#Oauth2-0-和-单点登录的关系" class="headerlink" title="Oauth2.0 和 单点登录的关系"></a>Oauth2.0 和 单点登录的关系</h2><ul><li>Oauth2.0 主要用于授权资源<ul><li>授权原则上不一定必须用户点击来授权</li></ul></li><li>单点登录可以利用 Oauth2.0 来实现，利用 Oauth2.0 授权用户信息资源至目标应用来实现登录，并可以获取用户信息</li><li>Oauth2.0 本身是需要用户授权，才能第三方登录（授权用户信息），但如果当前应用本身足够信任目标应用，认为在当前应用中的用户都可以直接授权用户信息到目标应用，则可以实现无缝单点登录</li></ul><h2 id="令牌和密码的区别"><a href="#令牌和密码的区别" class="headerlink" title="令牌和密码的区别"></a>令牌和密码的区别</h2><ul><li>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异<ul><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li><li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li><li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ul></li><li>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</li><li>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>登录</tag>
      
      <tag>SSO</tag>
      
      <tag>Oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rag</title>
    <link href="/2025/10/23/python/rag/"/>
    <url>/2025/10/23/python/rag/</url>
    
    <content type="html"><![CDATA[<h1 id="基于-Ollama-实现-Rag-系统"><a href="#基于-Ollama-实现-Rag-系统" class="headerlink" title="基于 Ollama 实现 Rag 系统"></a>基于 Ollama 实现 Rag 系统</h1><h2 id="安装-ollama-及相关模型"><a href="#安装-ollama-及相关模型" class="headerlink" title="安装 ollama 及相关模型"></a>安装 ollama 及相关模型</h2><p>安装部分可查询官方文档<a href="https://docs.ollama.com/">https://docs.ollama.com/</a>, ollama相当于是一个能够快速在本地部署大模型的工具</p><h3 id="下载模型："><a href="#下载模型：" class="headerlink" title="下载模型："></a>下载模型：</h3><p>在命令行执行如下两个命令来下载模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ollama pull nomic-embed-text:latest<br>ollama pull qwen:4b<br></code></pre></td></tr></table></figure><ul><li><code>nomic-embed-text:latest</code>是一个文本转向量的模型：<a href="https://link.zhihu.com/?target=https://ollama.com/library/nomic-embed-text">https://ollama.com/library/nomic-embed-text</a></li><li><code>qwen:4b</code>就是阿里开源的千问大模型：<a href="https://link.zhihu.com/?target=https://ollama.com/library/qwen">https://ollama.com/library/qwen</a></li></ul><h3 id="启动-ollama-服务"><a href="#启动-ollama-服务" class="headerlink" title="启动 ollama 服务"></a>启动 ollama 服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ollama serve<br></code></pre></td></tr></table></figure><p>执行如上命令会在本机的11434端口启动ollama的http服务：</p><p>可以直接通过http请求也就是REST API来集成ollama提供的服务: <a href="https://link.zhihu.com/?target=https://github.com/ollama/ollama/blob/main/docs/api.md">https://github.com/ollama/ollama/blob/main/docs/api.md</a></p><p>也可以通过ollama的python API来继承ollama的服务：<a href="https://link.zhihu.com/?target=https://github.com/ollama/ollama-python">https://github.com/ollama/ollama-python</a></p><p>本文的ollama-rag项目采用的是后一种方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>使用版本是 <code>Python3.8</code>，需要事先安装依赖</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">ollama<br>faiss-cpu==1.8.0<br>tqdm<br></code></pre></td></tr></table></figure><p>本文使用的测试文档为<code>预警模型.txt</code>，文档内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">复制状态异常: 严重级别为 serious，可通过 pg_state_get_stream_replications 查看实例复制状态细节 detail_information<br></code></pre></td></tr></table></figure><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> faiss<br><span class="hljs-keyword">import</span> ollama<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">return</span> ollama.embeddings(model=<span class="hljs-string">&#x27;nomic-embed-text&#x27;</span>, prompt=text)[<span class="hljs-string">&#x27;embedding&#x27;</span>]<br><br><br><span class="hljs-comment"># 读取文档并分段</span><br>chunks = []<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;告警规则.txt&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>    line = line.strip()<br>    <span class="hljs-keyword">if</span> line:<br>        chunks.append(line.strip())<br>file.close()<br><br><span class="hljs-comment"># 计算每个分段的embedding</span><br>chunk_embeddings = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(chunks)), desc=<span class="hljs-string">&#x27;计算chunks的embedding&#x27;</span>):<br>    chunk_embeddings.append(encode(chunks[i]))<br>chunk_embeddings = np.array(chunk_embeddings)<br>chunk_embeddings = chunk_embeddings.astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br><br><span class="hljs-comment"># 建立faiss索引</span><br>faiss.normalize_L2(chunk_embeddings)<br>faiss_index = faiss.index_factory(chunk_embeddings.shape[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Flat&quot;</span>, faiss.METRIC_INNER_PRODUCT)<br>faiss_index.add(chunk_embeddings)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 提示用户输入</span><br>    question = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个问题: &quot;</span>)<br>    <span class="hljs-built_in">print</span>(question)<br><br>    <span class="hljs-comment"># 将问题编码</span><br>    question_embedding = encode(question)<br><br>    <span class="hljs-comment"># 检索到最相关的top1分段</span><br>    question_embedding = np.array([question_embedding])<br>    question_embedding = question_embedding.astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    faiss.normalize_L2(question_embedding)<br>    _, index_matrix = faiss_index.search(question_embedding, k=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 构造prompt</span><br>    prompt = <span class="hljs-string">f&#x27;根据参考文档回答问题，回答尽量简洁，不超过200个字\n&#x27;</span> \<br>             <span class="hljs-string">f&#x27;问题是：&quot;<span class="hljs-subst">&#123;question&#125;</span>&quot;\n&#x27;</span> \<br>             <span class="hljs-string">f&#x27;参考文档是：&quot;<span class="hljs-subst">&#123;chunks[index_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]&#125;</span>&quot;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;prompt:\n<span class="hljs-subst">&#123;prompt&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-comment"># 获取答案</span><br>    stream = ollama.chat(model=<span class="hljs-string">&#x27;qwen:4b&#x27;</span>, messages=[&#123;<span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: prompt&#125;], stream=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;answer:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:<br>        <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>], end=<span class="hljs-string">&#x27;&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前代码暂时只实现了读取本地文件，实际开发中，会使用到向量数据库，因为此处文本数量比较小，如果文本数量比较多、比较大的化，会导致程序启动比较缓慢</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>rag</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rag</tag>
      
      <tag>ollma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2025/10/22/python/python/"/>
    <url>/2025/10/22/python/python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>此处忽略<code>Python</code>基础部分</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种高级功能，用于在不修改原有函数或类代码的情况下，动态地扩展或修改其行为。装饰器本质上是一个高阶函数，通常接受一个函数作为输入，并返回一个新的函数（或包装后的函数）。它广泛用于代码复用、日志记录、性能监控、权限验证等场景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在函数执行前做点什么&quot;</span>)<br>        func()  <span class="hljs-comment"># 调用原函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在函数执行后做点什么&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><br>say_hello()<br></code></pre></td></tr></table></figure><p>带参数的函数装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;调用函数 <span class="hljs-subst">&#123;func.__name__&#125;</span>，参数: <span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;函数执行完毕&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>在 Python 中，上下文管理器（Context Manager）是一种用于管理资源的工具，通常用于确保资源在使用后被正确清理。它通过 with 语句实现，能够简化异常处理和资源管理（如文件、网络连接、数据库等）的代码。</p><p>自定义上下文管理器：</p><ol><li><p>通过类实现</p><p>通过定义一个类并实现<code>__enter__</code> 和 <code>__exit__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContextManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入上下文&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>  <span class="hljs-comment"># 返回的对象会绑定到 as 后的变量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出上下文&quot;</span>)<br>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发生异常: <span class="hljs-subst">&#123;exc_type&#125;</span>, <span class="hljs-subst">&#123;exc_value&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 返回 True 表示抑制异常，返回 False 表示抛出异常</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">with</span> MyContextManager() <span class="hljs-keyword">as</span> cm:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在上下文内执行&quot;</span>)<br>    <span class="hljs-comment"># raise ValueError(&quot;测试异常&quot;)  # 取消注释以测试异常处理</span><br></code></pre></td></tr></table></figure></li><li><p>通过 <code>contextlib</code> 模块</p><p><code>Python</code> 的 <code>contextlib</code> 模块提供了一种更简洁的方式来创建上下文管理器，通常使用 <code>@contextmanager</code> 装饰器和生成器函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_context_manager</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入上下文&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;传递的值&quot;</span>  <span class="hljs-comment"># yield 的值会绑定到 as 后的变量</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出上下文&quot;</span>)<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">with</span> my_context_manager() <span class="hljs-keyword">as</span> value:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;在上下文内执行，接收到: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="Python-项目管理"><a href="#Python-项目管理" class="headerlink" title="Python 项目管理"></a>Python 项目管理</h2><h3 id="pipx"><a href="#pipx" class="headerlink" title="pipx"></a>pipx</h3><h3 id="poetry"><a href="#poetry" class="headerlink" title="poetry"></a>poetry</h3><h3 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h3>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/2025/09/25/%E5%89%8D%E7%AB%AF/React/React/"/>
    <url>/2025/09/25/%E5%89%8D%E7%AB%AF/React/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>一个用于构建用户界面的 JavaScript 库，是一个将数据渲染为 HTML 视图的开源 JS 库，它遵循基于组件的方法，有助于构建可重用的 UI 组件，它用于开发复杂的交互式的 web 和移动 UI</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><code>jsx</code> 是 <code>JavaScript</code> 的语法扩展，<code>Jsx</code> 使得我们可以以类似于 <code>html</code> 的形式去使用 <code>js</code>。<code>jsx</code>便是<code>React</code>中声明式编程的体现方式。声明式编程，简单理解就是以结果为导向的编程。使用<code>jsx</code>将我们所期望的网页结构编写出来，然后<code>React</code>再根据<code>jsx</code>自动生成<code>js</code>代码。所以我们所编写的<code>jsx</code>代码，最终都会转换为以调用<code>React.createElement()</code>创建元素的代码。</p><ol><li><p>定义虚拟<code>DOM</code>，<code>jsx</code>不是字符串，不要加引号</p></li><li><p>标签中混入<code>JS表达式</code>的时候使用{}</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">id = &#123;myId.<span class="hljs-title function_">toUpperCase</span>()&#125;<br></code></pre></td></tr></table></figure></li><li><p>样式的类名指定不能使用class，使用<code>className</code></p></li><li><p>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">style=&#123;&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;skyblue&#x27;</span>,<span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;24px&#x27;</span>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>不能有多个根标签，只能有一个根标签</p></li><li><p><code>jsx</code>的标签必须正确结束（自结束标签必须写&#x2F;）</p></li><li><p><code>jsx</code>中<code>html</code>标签应该小写，<code>React</code>组件应该大写开头。如果小写字母开头，就将标签转化为 <code>html</code> 同名元素，如果 <code>html</code> 中无该标签对应的元素，就报错；如果是大写字母开头，<code>React</code> 就去渲染对应的组件，如果没有就报错</p></li><li><p>如果表达式是空值、布尔值、undefined，将不会显示</p></li></ol><blockquote><p>关于JS表达式和JS语句：</p><ul><li>JS表达式：返回一个值，可以放在任何一个需要值的地方 a a+b demo(a) arr.map() function text(){}</li><li>JS语句：if(){} for(){} while(){} swith(){} 不会返回一个值</li></ul></blockquote><ol start="9"><li>注释</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 写在花括号里面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    &#123;/*注释...*/&#125;</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><ol start="10"><li><p><code>class</code>需要<code>className</code>代替</p></li><li><p><code>style</code>中必须使用对象设置<code> style=&#123;&#123;background:'red'&#125;&#125;</code></p></li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p><p>只有两种方式的组件</p><ul><li>函数组件</li><li>类式组件</li></ul><p><strong>注意</strong></p><ol><li>组件名必须是首字母大写（React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div &#x2F;&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome &#x2F;&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>）</li><li>虚拟DOM元素只能有一个根元素</li><li>虚拟DOM元素必须有结束标签 <code>&lt; /&gt;</code></li></ol><p><strong>渲染类组件标签的基本流程</strong></p><ol><li>React 内部会创建组件实例对象</li><li>调用<code>render()</code>得到虚拟 DOM ,并解析为真实 DOM</li><li>插入到指定的页面元素内部</li></ol><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>定义组件最简单的方式就是编写 <code>JavaScript</code>函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//1.创建函数式组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//此处的this是undefined，因为babel编译后开启了严格模式</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">//2.渲染组件到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>让我们来回顾一下这个例子中发生了什么：</p><ol><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ol><h4 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h4><blockquote><p><strong>将函数组件转换成 class 组件</strong></p><p>通过以下五步将 <code>Clock</code> 的函数组件转成 class 组件：</p><ol><li>创建一个同名的 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>，并且继承于 <code>React.Component</code>。</li><li>添加一个空的 <code>render()</code> 方法。</li><li>将函数体移动到 <code>render()</code> 方法之中。</li><li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li><li>删除剩余的空函数声明。</li></ol></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render中的this:&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>          <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>        &#125;<br>      &#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;MyComponent/&gt;</code> ，就仅有一个 <code>MyComponent</code> 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p><p><strong>执行过程：</strong></p><ol><li>React解析组件标签，找到相应的组件</li><li>发现组件是类定义的，随后new出来的类的实例，并通过该实例调用到原型上的render方法</li><li>将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中</li></ol><h4 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h4><p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p><p>例如，我们可以创建一个可以多次渲染 <code>Welcome</code> 组件的 <code>App</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Cahal&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。</p><h4 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h4><p>将组件拆分为更小的组件。</p><p>例如，参考如下 <code>Comment</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) &#123;<br>        <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toLocaleString</span>()<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Commment&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.author.avatarUrl&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;width:</span> &#x27;<span class="hljs-attr">200px</span>&#x27;, <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100px</span>&#x27;&#125;&#125;/&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> comment = &#123;<br>        <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;I hope you enjoy learning React!&#x27;</span>,<br>        <span class="hljs-attr">author</span>: &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hello Kitty&#x27;</span>,<br>            <span class="hljs-attr">avatarUrl</span>: <span class="hljs-string">&#x27;https://t7.baidu.com/it/u=1819248061,230866778&amp;fm=193&amp;f=GIF&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&#123;comment.date&#125;</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&#123;comment.text&#125;</span> <span class="hljs-attr">author</span>=<span class="hljs-string">&#123;comment.author&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p><p>该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。</p><p>首先，我们将提取 <code>Avatar</code> 组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span>      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span>      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span>    /&gt;</span></span>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Avatar</code> 不需知道它在 <code>Comment</code> 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：<code>user</code>，而不是 <code>author</code>。</p><p>我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p><p>我们现在针对 <code>Comment</code> 做些微小调整：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们将提取 <code>UserInfo</code> 组件，该组件在用户名旁渲染 <code>Avatar</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.user.name&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步简化 <code>Comment</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>我们都说React是一个状态机，体现是什么地方呢，就是体现在state上，通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了。state是组件的私有属性。</p><p>在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，用户的界面会随着状态的改变而改变。</p><p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p><p>简单的说就是组件的状态，也就是该组件所存储的数据</p><p>案例：</p><p>需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p><p>核心代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/react.development.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id = &quot;test&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>    class Weather extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;isHot: true&#125;<br>            this.changeWeather = this.changeWeather.bind(this)<br>        &#125;<br>        render()&#123;<br>            return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;&lt;/h1&gt;<br>        &#125;<br><br>        changeWeather()&#123;<br>            // 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined<br>            const isHot = this.state.isHot<br>            this.setState(&#123;isHot: !isHot&#125;)<br>            console.log(isHot)<br>        &#125;<br>    &#125;<br>    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在<strong>类式组件</strong>的函数中，直接修改<code>state</code>值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><blockquote><p>页面的渲染靠的是<code>render</code>函数</p></blockquote><p>这时候会发现页面内容不会改变，原因是 React 中不建议 <code>state</code>不允许直接修改，而是通过类的原型对象上的方法 <code>setState()</code></p><p><strong>注意：</strong></p><ol><li>组件的构造函数，必须要传递一个props参数</li><li>特别关注this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this就是undefined</li><li>想要改变state,需要使用setState进行修改，如果只是修改state的部分属性，则不会影响其他的属性，这个只是合并并不是覆盖。</li></ol><p><strong>在优化过程中遇到的问题</strong></p><ol><li>组件中的 render 方法中的 this 为组件实例对象</li><li>组件自定义方法中由于开启了严格模式，this 指向<code>undefined</code>如何解决<ol><li>通过 bind 改变 this 指向</li><li>推荐采用箭头函数，箭头函数的 <code>this</code> 指向</li></ol></li><li>state 数据不能直接修改或者更新</li></ol><h5 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h5><p>this.State()，该方法接收两种参数：对象或函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(partialState, [callback]);<br></code></pre></td></tr></table></figure><ul><li>partialState: 需要跟新状态的部分对象，可以是<code>function</code></li><li>callback: 更新完状态后的回调函数</li></ul><p><strong>有两种写法:</strong></p><ol><li>对象：即要修改的state</li><li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state参数</li></ol><h5 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h5><ol><li><p>state 的赋值可以不在构造函数中进行</p><p><a href="https://gitee.com/link?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields">公有类字段</a></p></li><li><p>使用了箭头函数，将 this 的指向改变</p><blockquote><p>箭头函数中的this会指向调用此箭头函数的外层</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;</span><br><span class="language-javascript">        state = &#123;<span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">super</span>(props);</span><br><span class="language-javascript">            <span class="hljs-comment">// this.changeWeather = this.changeWeather.bind(this)</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 箭头函数</span></span><br><span class="language-javascript">        changeWeather = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> isHot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isHot</span>: !isHot&#125;)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isHot)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Weather</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>​ </p><h5 id="state-的更新可能是异步的"><a href="#state-的更新可能是异步的" class="headerlink" title="state 的更新可能是异步的"></a>state 的更新可能是异步的</h5><p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout&#x2F;setInterval等</strong>。</p><blockquote><p>18版本中测试setTimeout回调函数中也是异步更新的</p></blockquote><p><strong>大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        count : <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addCount&#125;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            &#123;<br>                <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>            &#125;<br>        )<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>上面的案例中预期setState使得count变成了11，输出也应该是11。然而在控制台打印的却是10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p><p><strong>React怎么调用同步或者异步的呢？</strong></p><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p><p><strong>如果是同步更新，每一个setState对调用一个render，并且如果多次调用setState会以最后调用的为准，前面的将会作废；如果是异步更新，多个setSate会统一调用一次render</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">dem = <span class="hljs-function">() =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">444</span><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">isHot</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> + <span class="hljs-number">1</span><br><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">888</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">888</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的最后会输出：isHot是888，cont是888</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>count</code>初始值为1，当执行addCount后值变成2，也就是前面两部的setState并没有执行</p><p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用render，这样每一次更新都会 **</p><h5 id="异步更新导致的问题解决方案"><a href="#异步更新导致的问题解决方案" class="headerlink" title="异步更新导致的问题解决方案"></a>异步更新导致的问题解决方案</h5><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面使用了<a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">state, props</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h5><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><p>为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 <code>Clock</code> 的 <code>App</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>    </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Clock</code> 组件都会单独设置它自己的计时器并且更新它。</p><p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然</p><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><blockquote><p>只读</p></blockquote><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而 <code>props</code> 是外部传入的数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>      )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//传递数据</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tom&quot;</span> <span class="hljs-attr">age</span> = <span class="hljs-string">&#123;41&#125;</span> <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><p>如果传递的数据是一个对象，可以更加简便的使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...p</span>&#125;/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>… 这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr1 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>arr2 = [...arr,...arr1];  <span class="hljs-comment">//arr2 = [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><p>但是他还有其他的用法：</p><ol><li><p>复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>在复制的时候，合并其中的属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1,name : <span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-attr">hua</span>:<span class="hljs-string">&quot;ss&quot;</span>&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p><p><strong>props传递一个对象，是因为babel+react使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p><h5 id="props-限制"><a href="#props-限制" class="headerlink" title="props 限制"></a>props 限制</h5><blockquote><p>注意：</p><p>自 React v15.5 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <a href="https://gitee.com/link?target=https://www.npmjs.com/package/prop-types"><code>prop-types</code> 库</a> 代替。</p><p>我们提供了一个 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html%23migrating-from-reactproptypes">codemod 脚本</a>来做自动转换。</p></blockquote><p>随着你的应用程序不断增长，你可以通过类型检查捕获大量错误。对于某些应用程序来说，你可以使用 <a href="https://gitee.com/link?target=https://flow.org/">Flow</a> 或 <a href="https://gitee.com/link?target=https://www.typescriptlang.org/">TypeScript</a> 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 <code>propTypes</code> 属性：</p><p>react对此提供了相应的解决方法：</p><ul><li>propTypes:类型检查，还可以限制不能为空</li><li>defaultProps：默认值</li></ul><blockquote><p>从 ES2022 开始，你也可以在 React 类组件中将 <code>defaultProps</code> 声明为静态属性。欲了解更多信息，请参阅 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields%23public_static_fields">class public static fields</a>。这种现代语法需要添加额外的编译步骤才能在老版浏览器中工作。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//对标签属性进行类型、必要性的限制</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span><br>    <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span><br>    <span class="hljs-attr">speak</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<span class="hljs-comment">//限制speak为函数</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-comment">//指定默认标签属性值</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;<br>    <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p><p><code>defaultProps</code> 用于确保 <code>this.props.sex</code> 在父组件没有指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p><h6 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h6><p>以下提供了使用不同验证器的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span><br>  <span class="hljs-comment">// 这些属性都是可选的。</span><br>  <span class="hljs-attr">optionalArray</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>,<br>  <span class="hljs-attr">optionalBool</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">bool</span>,<br>  <span class="hljs-attr">optionalFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<br>  <span class="hljs-attr">optionalNumber</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>  <span class="hljs-attr">optionalObject</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">object</span>,<br>  <span class="hljs-attr">optionalString</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>  <span class="hljs-attr">optionalSymbol</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">symbol</span>,<br><br>  <span class="hljs-comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span><br>  <span class="hljs-comment">// (或 Fragment) 也包含这些类型。</span><br>  <span class="hljs-attr">optionalNode</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">node</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素。</span><br>  <span class="hljs-attr">optionalElement</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素类型（即，MyComponent）。</span><br>  <span class="hljs-attr">optionalElementType</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">elementType</span>,<br><br>  <span class="hljs-comment">// 你也可以声明 prop 为类的实例，这里使用</span><br>  <span class="hljs-comment">// JS 的 instanceof 操作符。</span><br>  <span class="hljs-attr">optionalMessage</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>),<br><br>  <span class="hljs-comment">// 你可以让你的 prop 只能是特定的值，指定它为</span><br>  <span class="hljs-comment">// 枚举类型。</span><br>  <span class="hljs-attr">optionalEnum</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOf</span>([<span class="hljs-string">&#x27;News&#x27;</span>, <span class="hljs-string">&#x27;Photos&#x27;</span>]),<br><br>  <span class="hljs-comment">// 一个对象可以是几种类型中的任意一个类型</span><br>  <span class="hljs-attr">optionalUnion</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOfType</span>([<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>)<br>  ]),<br><br>  <span class="hljs-comment">// 可以指定一个数组由某一类型的元素组成</span><br>  <span class="hljs-attr">optionalArrayOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由某一类型的值组成</span><br>  <span class="hljs-attr">optionalObjectOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">objectOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由特定的类型值组成</span><br>  <span class="hljs-attr">optionalObjectWithShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">shape</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 具有额外属性警告的对象</span><br>  <span class="hljs-attr">optionalObjectWithStrictShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">exact</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">quantity</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span><br>  <span class="hljs-comment">// 这个 prop 没有被提供时，会打印警告信息。</span><br>  <span class="hljs-attr">requiredFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 任意类型的必需数据</span><br>  <span class="hljs-attr">requiredAny</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">any</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。</span><br>  <span class="hljs-attr">customProp</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">props, propName, componentName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(props[propName])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span><br>  <span class="hljs-comment">// 它应该在验证失败时返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span><br>  <span class="hljs-comment">// 第一个是数组或对象本身</span><br>  <span class="hljs-comment">// 第二个是他们当前的键。</span><br>  <span class="hljs-attr">customArrayProp</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">propValue, key, componentName, location, propFullName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(propValue[key])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="限制单个元素"><a href="#限制单个元素" class="headerlink" title="限制单个元素"></a>限制单个元素</h6><p>你可以通过 <code>PropTypes.element</code> 来确保传递给组件的 children 中只包含一个元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 这必须只有一个元素，否则控制台会打印警告。</span><br>    <span class="hljs-keyword">const</span> children = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-attr">children</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>.<span class="hljs-property">isRequired</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!-- 准备好一个“容器” --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//创建组件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(props);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">super</span>(props)</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//对标签属性进行类型、必要性的限制</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> propTypes = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//指定默认标签属性值</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> defaultProps = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(this);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">const</span> &#123;name,age,sex&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> (</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">            )</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//渲染组件到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在使用的时候可以通过 <code>this.props</code>来获取值 类式组件的 <code>props</code>:</p><ol><li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li><li>在构造器里的<code>props</code>参数里可以获取到 <code>props</code></li><li>可以分别设置 <code>propTypes</code> 和 <code>defaultProps</code> 两个属性来分别操作 <code>props</code>的规范和默认值，两者都是直接添加在类式组件的<strong>原型对象</strong>上的（所以需要添加 <code>static</code>）</li><li>同时可以通过<code>...</code>运算符来简化</li></ol><h5 id="函数组件的使用"><a href="#函数组件的使用" class="headerlink" title="函数组件的使用"></a>函数组件的使用</h5><blockquote><p>函数在使用props的时候，是作为参数进行使用的(props)</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>对props进行限制<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//创建组件</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">props</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = props</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> (</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">sex</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>, <span class="hljs-comment">//限制sex为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>, <span class="hljs-comment">//限制age为数值</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//指定默认标签属性值</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-comment">//sex默认值为男</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">//age默认值为18</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//渲染组件到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>函数组件的 <code>props</code>定义:</p><ol><li>在组件标签中传递 <code>props</code>的值</li><li>组件函数的参数为 <code>props</code></li><li>对 <code>props</code>的限制和默认值同样设置在原型对象上</li></ol><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p><p>在典型的 React 数据流中，<a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/components-and-props.html">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p><blockquote><p>在我们正常的操作节点时，需要采用DOM API 来查找元素，但是这样违背了 React 的理念，因此有了<code>refs</code></p></blockquote><p><strong>何时使用 Refs</strong></p><p>下面是几个适合使用 refs 的情况：</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p><p><strong>有三种操作<code>refs</code>的方法，分别为：</strong></p><ul><li>字符串形式</li><li>回调形式</li><li><code>createRef</code>形式</li></ul><p><strong>勿过度使用 Refs</strong></p><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/lifting-state-up.html">状态提升</a> 以获取更多有关示例。</p><h5 id="字符串形式"><a href="#字符串形式" class="headerlink" title="字符串形式"></a>字符串形式</h5><p>在想要获取到一个DOM节点，可以直接在这个节点上添加ref属性。利用该属性进行获取该节点的值。</p><p>案例：给需要的节点添加ref属性，此时该实例对象的refs上就会有这个值。就可以利用实例对象的refs获取已经添加节点的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;失去焦点提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>不建议使用它，因为 string 类型的 refs 存在 <a href="https://gitee.com/link?target=https://github.com/facebook/react/pull/8333%23issuecomment-271648615">一些问题</a>。它已过时并可能会在未来的版本被移除。</p><p>如果你目前还在使用 <code>this.refs.textInput</code> 这种方式访问 refs ，我们建议用<a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/refs-and-the-dom.html%23callback-refs">回调函数</a>或 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/refs-and-the-dom.html%23creating-refs"><code>createRef</code> API</a> 的方式代替。</p><h5 id="回调形式"><a href="#回调形式" class="headerlink" title="回调形式"></a>回调形式</h5><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p><p>这种方式会将该DOM作为参数传递过去。</p><p>组件实例的<code>ref</code>属性传递一个回调函数<code>c =&gt; this.input1 = c </code>（箭头函数简写），这样会在实例的属性中存储对DOM节点的引用，使用时可通过<code>this.input1</code>来使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><code>current</code>会接收到当前节点作为参数，然后将当前节点赋值给<code>input1</code>实例属性上</p><p><strong>关于回调 refs 的说明</strong></p><p>如果 <code>ref</code> 回调函数是以<code>内联函数</code>的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。<strong>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的</strong>。</p><p><code>class的绑定函数</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    saveInput = <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>, c)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.saveInput&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>tips: 其实就相当于是匿名函数对于react来说，每次的函数都是不一样的，基于类绑定的方式，使用的是一个固定的实例函数，因此对于他来说没必要有清空之前绑定的这一步</p></blockquote><h5 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h5><blockquote><p>React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点 </p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    myRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.myRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>修改天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    changeWeather = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@ ref&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span>.<span class="hljs-property">current</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>逻辑：最开始创建一个实例的ref，后续通过ref关键字，react发现ref是通过<code>React.crateRef</code>创建的，然后他会把当前的节点赋值给myRef，如果有多个节点的话，他就需要创建多个ref</p></blockquote><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>Refs与函数组件</p><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyFunctionComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">textInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// This will *not* work!</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyFunctionComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.textInput&#125;</span> /&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/forwarding-refs.html"><code>forwardRef</code></a>（可与 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/hooks-reference.html%23useimperativehandle"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p><p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomTextInput</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 才可以引用它</span><br>  <span class="hljs-keyword">const</span> textInput = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    textInput.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;textInput&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Focus the text input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>React的事件是通过onXxx属性指定事件处理函数，React 使用的是自定义事件，而不是原生的 DOM 事件，React 的事件是通过事件委托方式处理的（为了更加的高效），可以通过事件的 <code>event.target</code>获取发生的 DOM 元素对象，可以尽量减少 <code>refs</code>的使用，事件中必须返回的是函数</p><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><p>例如，传统的html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;activateLasers()&quot;</span>&gt;</span><br>  Activate Lasers<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 React 中略微不同：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;activateLasers&#125;&gt;  <br>   <span class="hljs-title class_">Activate</span> <span class="hljs-title class_">Lasers</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式地使用 <code>preventDefault</code>。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;console.log(&#x27;You clicked submit.&#x27;); return false&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 React 中，可能是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You clicked submit.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://gitee.com/link?target=https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南。</p><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p><h3 id="类式组件绑定事件"><a href="#类式组件绑定事件" class="headerlink" title="类式组件绑定事件"></a>类式组件绑定事件</h3><p>当你使用 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;this.state.isToggleOn?&#x27;ON&#x27;: &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            <span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>                <span class="hljs-attr">isToggleOn</span>: !state.<span class="hljs-property">isToggleOn</span><br>            &#125;)<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br><br></code></pre></td></tr></table></figure><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">saveName = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">name</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br>savePwd = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">pwd</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">            用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveName&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">            密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.pwd&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.savePwd&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>非受控组件其实就是表单元素的值不会更新state。输入数据都是现用现取的。</p><p>如下：下面并没有使用state来控制属性，使用的是事件来控制表单的属性值。</p><blockquote><p>表单提交同样需要通过事件来处理，提交表单的事件通过form标签的onSubmit事件来绑定，处理表单的方式因情况而已，但是一定要注意，必须要取消默认行为，否则会触发表单的默认提交行为：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br><br>    login = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>        event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">//阻止表单默认事件</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pwd</span>.<span class="hljs-property">value</span>);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> (<br>                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">                用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.name =e &#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="language-xml">                密码：  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.pwd =e &#125; type = &quot;password&quot; name =&quot;password&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h3><p><strong>高级函数</strong></p><ol><li>如果函数的参数是函数</li><li>如果函数返回一个函数</li></ol><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p><p>如下，我们将上面的案例简化，创建高级函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;this.saveType(</span>&#x27;<span class="hljs-attr">name</span>&#x27;)&#125; <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><p>不使用函数柯里化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type,event</span>) =&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;event</span> =&gt;</span> this.saveType(&#x27;name&#x27;,event)&#125; type = &quot;text&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>组件从创建到死亡，会经过一些特定的阶段</p><p>React组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p><p>我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p><p>在 React 中为我们提供了一些生命周期钩子函数，让我们能在 React 执行的重要阶段，在钩子函数中做一些事情。</p><h3 id="React-生命周期（旧）"><a href="#React-生命周期（旧）" class="headerlink" title="React 生命周期（旧）"></a>React 生命周期（旧）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染<br><span class="hljs-bullet">                    1.</span>constructor()<br><span class="hljs-bullet">                    2.</span>componentWillMount()<br><span class="hljs-bullet">                    3.</span>render()<br><span class="hljs-bullet">                    4.</span>componentDidMount() =====&gt; 常用<br><span class="hljs-code">                        一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="hljs-code">2. 更新阶段: 由组件内部this.setSate()或父组件render触发</span><br><span class="hljs-code">                    1.shouldComponentUpdate()</span><br><span class="hljs-code">                    2.componentWillUpdate()</span><br><span class="hljs-code">                    3.render() =====&gt; 必须使用的一个</span><br><span class="hljs-code">                    4.componentDidUpdate()</span><br><span class="hljs-code">3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发</span><br><span class="hljs-code">                    1.componentWillUnmount()  =====&gt; 常用</span><br><span class="hljs-code">                        一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/i0lrc3J.png" alt="image-20250128150711851"></p><p>在最新的react版本中，有些生命周期钩子被抛弃了，具体函数如下：</p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul><p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）</p><p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有UNSAFE_ 前缀的三个函数，比如: UNSAFE_ componentWillMount。即便如此，其实React官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p><h3 id="React-生命周期（新）"><a href="#React-生命周期（新）" class="headerlink" title="React 生命周期（新）"></a>React 生命周期（新）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染<br><span class="hljs-bullet">                1.</span>constructor()<br><span class="hljs-bullet">                2.</span>getDerivedStateFromProps <br><span class="hljs-bullet">                3.</span>render()<br><span class="hljs-bullet">                4.</span>componentDidMount() =====&gt; 常用<br><span class="hljs-code">                一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</span><br><span class="hljs-code">2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发</span><br><span class="hljs-code">                1.getDerivedStateFromProps</span><br><span class="hljs-code">                2.shouldComponentUpdate()</span><br><span class="hljs-code">                3.render()</span><br><span class="hljs-code">                4.getSnapshotBeforeUpdate</span><br><span class="hljs-code">                5.componentDidUpdate()</span><br><span class="hljs-code">3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发</span><br><span class="hljs-code">                1.componentWillUnmount()  =====&gt; 常用</span><br><span class="hljs-code">                一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/b8vjsRu.png" alt="image-20250128151159128"></p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p><strong>在组件实例被创建并插入到dom中时，生命周期调用顺序如下</strong></p><p><strong>旧生命周期：</strong></p><ol><li>constructor（props）</li><li>componentWillMount（）————-可以用但是不建议使用</li><li>render（）</li><li>componentDidMount（）</li></ol><p><strong>新生命周期：</strong></p><ol><li>constructor（props）</li><li><code>static getDerivedStateFromProps（props，state）</code>–替代了<code>componentWillReceiveProps</code></li><li>render（）</li><li>componentDidMount（）</li></ol><h4 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1. constructor"></a>1. constructor</h4><blockquote><p>数据的初始化</p></blockquote><p>接收props和context，当想在函数内使用这两个参数需要在super传入参数，当使用constructor时必须使用super，否则可能会有this的指向问题，如果不初始化state或者不进行方法绑定，则可以不为组件实现构造函数；</p><p>避免将 props 的值复制给 state！这是一个常见的错误：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br> <span class="hljs-variable language_">super</span>(props);<br> <span class="hljs-comment">// 不要这样做</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">color</span>: props.<span class="hljs-property">color</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此做毫无必要（可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;this.state.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&#123;this.state.name&#125;/</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.fnChangeName&#125;</span>&gt;</span>修改名称<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    fnChangeName = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击成功&quot;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Change A&#x27;</span><br>        &#125;))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">name</span>: props.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>B&#x27;s name:&#123;this.state.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">A</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>现在我们通常不会使用 <code>constructor</code> 属性，而是改用类加箭头函数的方法，来替代 <code>constructor</code><br>例如，我们可以这样初始化 <code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">state = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-componentWillMount"><a href="#2-componentWillMount" class="headerlink" title="2. componentWillMount"></a><del>2. componentWillMount</del></h4><p><strong>该方法只在挂载的时候调用一次，表示组件将要被挂载，并且在 <code>render</code> 方法之前调用。</strong></p><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code></p><p>在服务端渲染唯一会调用的函数，代表已经初始化数据但是没有渲染dom，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。</p><p><strong>这个方法在 React 18版本中将要被废弃，官方解释是在 React 异步机制下，如果滥用这个钩子可能会有 Bug</strong></p><h4 id="3-static-getDerivedStateFromProps-–-新钩子"><a href="#3-static-getDerivedStateFromProps-–-新钩子" class="headerlink" title="3. static getDerivedStateFromProps – 新钩子"></a>3. static getDerivedStateFromProps – 新钩子</h4><blockquote><p><strong>从props获取state。</strong></p><p>注意：<code>state</code> 的值在任何时候都取决于传入的 <code>props</code> ，不会再改变</p></blockquote><p>替代了<code>componentWillReceiveProps，</code>此方法适用于<a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html%23when-to-use-derived-state">罕见的用例</a>，即 state 的值在任何时候都取决于 props。</p><p>这个是 React 新版本中新增的2个钩子之一，据说很少用。</p><ol><li>首先，该函数会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用；</li><li>该函数必须是静态的；</li><li>给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；</li><li>该函数也必须有返回值，返回一个Null或者state对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回state对象，就相当于将原来的state进行了覆盖，所以倒是修改状态不起作用。</li></ol><p>如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Count</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&quot;109&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.test&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>count</code> 的值不会改变，一直是 109</p><p><a href="https://gitee.com/link?target=https://www.jianshu.com/p/b331d0e4b398">React的生命周期 - 简书</a> </p><p>老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p><p>这两者最大的不同就是: 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。</p><ol><li>在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。</li><li>而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li></ol><h4 id="4-render"><a href="#4-render" class="headerlink" title="4. render"></a>4. render</h4><blockquote><p><strong>class组件中唯一必须实现的方法。</strong></p><p>避免在 <code>render</code> 中使用 <code>setState</code> ，否则会死循环</p></blockquote><p>当render被调用时，他会检查this.props.和this.state的变化并返回以下类型之一：</p><ol><li>通过jsx创建的react元素</li><li>数组或者fragments：使得render可以返回多个元素</li><li>Portals:可以渲染子节点到不同的dom树上</li><li>字符串或数值类型：他们在dom中会被渲染为文本节点</li><li>布尔类型或者null：什么都不渲染</li></ol><h4 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5. componentDidMount"></a>5. componentDidMount</h4><p><strong>在组件挂在后（插入到dom树中）后立即调用</strong></p><p><code>componentDidMount</code> 的执行意味着初始化挂载操作已经基本完成，它主要用于组件挂载完成后做某些操作</p><p>这个挂载完成指的是：组件插入 DOM tree</p><p>可以在这里调用Ajax请求，返回的数据可以通过setState使组件重新渲染，或者添加订阅，但是要在conponentWillUnmount中取消订阅</p><h4 id="6-初始化阶段总结"><a href="#6-初始化阶段总结" class="headerlink" title="6. 初始化阶段总结"></a>6. 初始化阶段总结</h4><p>执行顺序 <code>constructor</code> -&gt; <code>getDerivedStateFromProps</code> 或者 <code>componentWillMount</code> -&gt; <code>render</code> -&gt; <code>componentDidMount</code></p><p><img src="https://i.imgur.com/gwToXO4.png" alt="image-20221023223048451"></p><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p><strong>当组件的 props 或 state 发生变化时会触发更新。</strong></p><p><strong>旧生命周期</strong></p><ol><li>componentWillReceiveProps (nextProps)——————可以用但是不建议使用</li><li>shouldComponentUpdate（nextProps,nextState）</li><li>componetnWillUpdate（nextProps,nextState）—————-可以用但是不建议使用</li><li>render（）</li><li>componentDidUpdate（prevProps,precState,snapshot）</li></ol><p><strong>新生命周期</strong></p><ol><li>static getDerivedStateFromProps（nextProps, prevState）</li><li>shouldComponentUpdate（nextProps,nextState）</li><li>render（）</li><li>getSnapshotBeforeUpdate（prevProps,prevState）</li><li>componentDidUpdate（prevProps,precState,snapshot）</li></ol><h4 id="1-componentWillReceiveProps"><a href="#1-componentWillReceiveProps" class="headerlink" title="1. componentWillReceiveProps"></a><del>1. componentWillReceiveProps</del></h4><p><strong>在已挂载的组件接收新的props之前调用</strong></p><p>通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件，可以在此方法中使用this.setState改变state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">componentWillReceiveProps</span> (nextProps) &#123;<br>    nextProps.<span class="hljs-property">openNotice</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">openNotice</span>&amp;&amp;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">openNotice</span>:nextProps.<span class="hljs-property">openNotice</span><br>    &#125;，() =&gt; &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">openNotice</span>:nextProps)<br>      <span class="hljs-comment">//将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。React 不会针对初始 props 调用 UNSAFE_componentWillReceiveProps()。组件只会在组件的 props 更新时调用此方法。调用 this.setState() 通常不会触发该生命周期。</p></blockquote><h4 id="2-shouldComponentUpdate"><a href="#2-shouldComponentUpdate" class="headerlink" title="2.  shouldComponentUpdate"></a>2.  shouldComponentUpdate</h4><p>在渲染之前被调用，默认返回为true。</p><p>返回值是判断组件的输出是否受当前state或props更改的影响，默认每次state发生变化都重新渲染，首次渲染或使用forceUpdate(使用<code>this.forceUpdate()</code>)时不被调用。</p><blockquote><p>他主要用于性能优化，会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。不建议深层比较，会影响性能。如果返回false，则不会调用componentWillUpdate、render和componentDidUpdate</p></blockquote><ul><li>唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新，但是不建议，建议使用 PureComponent</li><li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li></ul><h4 id="3-componentWillUpdate"><a href="#3-componentWillUpdate" class="headerlink" title="3. componentWillUpdate"></a><del>3. componentWillUpdate</del></h4><p><strong>当组件接收到新的props和state会在渲染前调用，初始渲染不会调用该方法。</strong></p><p>shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate，不能在这使用setState，在函数返回之前不能执行任何其他更新组件的操作</p><blockquote><p>此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p></blockquote><h4 id="4-getSnapshotBeforeUpdate-–-新钩子"><a href="#4-getSnapshotBeforeUpdate-–-新钩子" class="headerlink" title="4.  getSnapshotBeforeUpdate – 新钩子"></a>4.  getSnapshotBeforeUpdate – 新钩子</h4><p><strong>在最近一次的渲染输出之前被提交之前调用，也就是即将挂载时调用，替换componetnWillUpdate。</strong></p><p>相当于淘宝购物的快照，会保留下单前的商品内容，在 React 中就相当于是 即将更新前的状态</p><p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code>。如不需要传递任何值，那么请返回 null</p><blockquote><p>和componentWillUpdate的区别</p><ul><li>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li><li>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。</li></ul></blockquote><p>使用场景</p><p>在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动</p><p><img src="https://i.imgur.com/wJF6bBq.gif" alt="BeforeGender"></p><p>上面的动图：区域内部的内容展现没有变化，但是可以看见滚动条在变化，也就是说上面依旧有内容在输出，只不过不在这个区域内部展现。</p><ol><li>接下来就是控制滚动条了</li></ol><p> 我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p><ol><li><p>首先我们先实现定时输出内容</p><p>我们可以使用state状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为state的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新state。更新渲染组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">New</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>   <br>       state = &#123;<span class="hljs-attr">num</span>:[]&#125;;<br>   <br>       <span class="hljs-comment">//在组件创建之后,开启一个定时任务</span><br>       <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>               <span class="hljs-keyword">let</span> &#123;num&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br>               <span class="hljs-keyword">const</span> news = (num.<span class="hljs-property">length</span>+<span class="hljs-number">1</span>);<br>               <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">num</span>:[news,...num]&#125;);<br>           &#125;,<span class="hljs-number">2000</span>);<br>       &#125;<br>   <br>       <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> (<br>               <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">className</span> = <span class="hljs-string">&quot;list&quot;</span>&gt;</span>&#123;</span><br><span class="language-xml">                   this.state.num.map((n,index)=&gt;&#123;</span><br><span class="language-xml">                   return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;news&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> &gt;</span>新闻&#123;n&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                   &#125;)</span><br><span class="language-xml">               &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>           )<br>       &#125;<br> &#125;<br> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">New</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>接下来就是控制滚动条了</p><p>我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span>;<br>&#125;<br><br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">preProps,preState,height</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span> += (<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollHeight</span> - height);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-componentDidUpdate"><a href="#4-componentDidUpdate" class="headerlink" title="4. componentDidUpdate"></a>4. componentDidUpdate</h4><p><strong>组件在更新完毕后会立即被调用，首次渲染不会调用</strong></p><p>可以在该方法调用setState，但是要包含在条件语句中，否则一直更新会造成死循环。</p><p>当组件更新后，可以在此处对 DOM 进行操作。如果对更新前后的props进行了比较，可以进行网络请求。（当 props 未发生变化时，则不会执行网络请求）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">componentDidUpdate(prevProps,prevState,snapshotValue) &#123;<br>  <span class="hljs-comment">// 典型用法（不要忘记比较 props）：</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.userID !== prevProps.userID) &#123;<br>    <span class="hljs-keyword">this</span>.fetchData(<span class="hljs-keyword">this</span>.props.userID);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 “snapshotValue” 参数传递。否则此参数将为 undefined。如果返回false就不会调用这个函数。</p></blockquote><p>这样就实现了这个功能。</p><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p><strong>当组件从 DOM中移除时会调用如下方法</strong></p><h4 id="1-componentWillUnmount"><a href="#1-componentWillUnmount" class="headerlink" title="1. componentWillUnmount"></a>1. componentWillUnmount</h4><p><strong>在组件卸载和销毁之前调用</strong></p><blockquote><p>使用这样的方式去卸载<code>ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))</code></p></blockquote><p>在这执行必要的清理操作，例如，清除timer（setTimeout,setInterval），取消网络请求，或者取消在componentDidMount的订阅，移除所有监听</p><p>有时候我们会碰到这个warning:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Can only update a mounted<span class="hljs-built_in"> or </span>mounting component. This usually means you called setState() on an unmounted component. This is a   no-op. Please<span class="hljs-built_in"> check </span>the code for the undefined component.<br></code></pre></td></tr></table></figure><p>原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning</p><p>解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> === <span class="hljs-literal">true</span><br>    axios.<span class="hljs-title function_">post</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;   <span class="hljs-comment">// 增加条件ismount为true时</span><br>      <span class="hljs-attr">aaa</span>:res<br>    &#125;)<br>&#125;)<br>&#125;<br><span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isMount</span> === <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http 请求中 Header 存放中文会发生的问题</title>
    <link href="/2025/09/12/%E5%B7%A5%E4%BD%9C/Http%20%E8%AF%B7%E6%B1%82%E4%B8%AD%20Header%20%E5%AD%98%E6%94%BE%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/09/12/%E5%B7%A5%E4%BD%9C/Http%20%E8%AF%B7%E6%B1%82%E4%B8%AD%20Header%20%E5%AD%98%E6%94%BE%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Http-请求中-Header-存放中文会发生的问题"><a href="#Http-请求中-Header-存放中文会发生的问题" class="headerlink" title="Http 请求中 Header 存放中文会发生的问题"></a>Http 请求中 Header 存放中文会发生的问题</h1><p>背景：遇到了一个场景，现在请求打到网关，然后网关中有一个过滤器，过滤器会向请求中的<code>header</code>存放一个类似于 <code>X-User-Data</code>字段，然后值是一个<code>json</code>字符串，然后将请求转发到另一台服务器，另一台服务器去解析这个json字符串，但此时出现了一个意外的情况，解析之后<code>json</code>字符串中的中文会变成<code>???</code>，然后排查了很多情况，因为也有序列化的定制，最后逐一排查没有问题，发现是因为 <code>header</code>中存放的问题。</p><blockquote><p>其实笔者很难理解为啥要把用户信息变成json字符串存放到header中</p></blockquote><h2 id="为什么会出现这种情况？"><a href="#为什么会出现这种情况？" class="headerlink" title="为什么会出现这种情况？"></a>为什么会出现这种情况？</h2><h3 id="1-HTTP-Header-的历史规范"><a href="#1-HTTP-Header-的历史规范" class="headerlink" title="1. HTTP Header 的历史规范"></a>1. HTTP Header 的历史规范</h3><ol><li><p>早期 HTTP&#x2F;1.1 的 RFC 2616（1999 年）要求 Header 值必须是 <strong>ISO-8859-1 (Latin-1)</strong>，即单字节字符集，只能表示西欧字符。</p></li><li><p>后来 RFC 7230（2014 年）放宽了要求，允许 Header 使用 ASCII，但仍然没有正式规定 UTF-8。</p></li><li><p>到现在的 RFC 9110（HTTP&#x2F;1.1 最新规范，2022 年）里才明确：Header 的语义值可以是 <strong>Unicode（UTF-8）</strong>，但实现上仍要考虑兼容性。</p></li></ol><h3 id="2-一些服务器仍然不支持-“UTF-8”"><a href="#2-一些服务器仍然不支持-“UTF-8”" class="headerlink" title="2. 一些服务器仍然不支持 “UTF-8”"></a>2. 一些服务器仍然不支持 “UTF-8”</h3><p><strong>老旧的 Web 服务器</strong></p><ul><li>例如某些版本的 Apache、Tomcat、IIS，仍然默认用 ISO-8859-1 解析 Header。</li><li>如果你传中文 UTF-8（多字节），它会逐字节解码 → 乱码。</li></ul><p><strong>反向代理 &#x2F; API 网关</strong></p><ul><li>比如 Nginx 默认认为 Header 是 ASCII，如果配置不对，转发时可能丢掉或截断非 ASCII。</li><li>某些企业级 API 网关（如 Zuul、Kong）也会拒绝包含非 ASCII 的 Header。</li></ul><p><strong>编程语言库</strong></p><ul><li>Go 的 <code>net/http</code> 是支持 UTF-8 Header 的（不会报错）</li><li>但 Java 的 <code>HttpURLConnection</code> 或一些老的 Servlet 容器可能会用 ISO-8859-1 处理，中文就会乱码。</li></ul><h3 id="3-兼容性问题"><a href="#3-兼容性问题" class="headerlink" title="3. 兼容性问题"></a>3. 兼容性问题</h3><p>不同的服务和中间件处理方式不一样：</p><ul><li><strong>浏览器 &#x2F; 常见 HTTP 客户端库</strong>：有些会自动尝试转义，有些会直接报错。</li><li><strong>Nginx &#x2F; Apache</strong>：可能会拒绝请求（<code>400 Bad Request</code>）或者把中文替换成 <code>?</code>。</li><li><strong>反向代理 &#x2F; 网关（如 Kong、Zuul、Envoy）</strong>：可能会直接丢掉该 header，或者导致整个请求失败。</li><li><strong>跨语言服务</strong>：比如后端是 Go，网关是 Java，某些语言解析时直接报错。</li></ul><h2 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h2><blockquote><p>因为解决问题比较简单，笔者只提供思路</p></blockquote><ol><li>在 <code>Header</code>中只存放<code>用户id</code>等关键信息，一方面是避免请求过大，导致请求性能降低，另一方面符合 <code>Http</code>规范，后续其他服务通过<code>用户id</code>等关键信息可以再次获取用户信息</li><li>如果现在架构已经设计好了，已经没有办法修改了，现在可以采用把整个带中文的<code>json字符串</code>通过<code>BSER64</code>加密之后传输，跟<code>http</code>中<code>url</code>携带中文类似</li></ol>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
      <category>工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Centos7下 Golang 环境搭建</title>
    <link href="/2025/07/14/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Centos%207%20%E4%B8%8B%20golang%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/07/14/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Centos%207%20%E4%B8%8B%20golang%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Centos7下-Golang-环境搭建"><a href="#Centos7下-Golang-环境搭建" class="headerlink" title="Centos7下 Golang 环境搭建"></a>Centos7下 Golang 环境搭建</h1><h2 id="yum-安装-【不推荐】"><a href="#yum-安装-【不推荐】" class="headerlink" title="yum 安装 【不推荐】"></a>yum 安装 【不推荐】</h2><ol><li>用yum指令安装缺点是：不是最新版</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install golang<br></code></pre></td></tr></table></figure><h2 id="使用二进制文件安装"><a href="#使用二进制文件安装" class="headerlink" title="使用二进制文件安装"></a>使用二进制文件安装</h2><p>标准官网：<a href="https://golang.org/">https://golang.org/</a> 需要墙<br>镜像官网：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a> 【国内推荐】</p><ol><li><p>下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://golang.google.cn/dl/go1.23.0.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压文件到 &#x2F;usr&#x2F;local<br>  【重要】如果之前已经安装过go的版本，先清空下go下面src，不然可能会报一些previous declaration at &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;internal&#x2F;atomic&#x2F;atomic_amd64.go:16:24的错误</p></li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /usr/local/go<br></code></pre></td></tr></table></figure><ol start="3"><li><p>解压 go 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf go1.17.linux-amd64.tar.gz -C /usr/local<br></code></pre></td></tr></table></figure></li><li><p>配置环境变量，vim 命令编辑 &#x2F;etc&#x2F;profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>在 <code>/etc/profile</code>文件末尾添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#golang config</span><br><span class="hljs-built_in">export</span> GOROOT=/usr/local/go <br><span class="hljs-built_in">export</span> GOPATH=/data/gopath<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure></li><li><p>创建 &#x2F;data&#x2F;gopath 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /data/gopath<br></code></pre></td></tr></table></figure></li><li><p><code>source /etc/profile</code></p></li><li><p>设置 <code>golang</code>代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Linux</tag>
      
      <tag>Centos 7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2025/07/07/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/vim/"/>
    <url>/2025/07/07/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>背景介绍，公司开发使用主要使用的是 Golang，很多小伙伴会使用 <code>LazyVim</code>进行开发，因此在公司我也尝试自己配置了一个出来。</p><p>下面是一些<code>debug</code>配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>  &#123; <span class="hljs-string">&quot;nvim-neotest/nvim-nio&quot;</span> &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;mfussenegger/nvim-dap&quot;</span>,<br><br>    dependencies = &#123;<br><br>      <span class="hljs-comment">-- fancy UI for the debugger</span><br>      &#123;<br>        <span class="hljs-string">&quot;rcarriga/nvim-dap-ui&quot;</span>,<br>      <span class="hljs-comment">-- stylua: ignore</span><br>      keys = &#123;<br>        &#123; <span class="hljs-string">&quot;&lt;leader&gt;du&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>).toggle(&#123; &#125;) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Dap UI&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;&lt;leader&gt;de&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>).eval() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Eval&quot;</span>, mode = &#123;<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125; &#125;,<br>      &#125;,<br>        opts = &#123;&#125;,<br>        <span class="hljs-built_in">config</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, opts)</span></span><br>          <span class="hljs-comment">-- setup dap config by VsCode launch.json file</span><br>          <span class="hljs-comment">-- require(&quot;dap.ext.vscode&quot;).load_launchjs()</span><br>          <span class="hljs-keyword">local</span> dap = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>)<br>          <span class="hljs-keyword">local</span> dapui = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>)<br>          dapui.setup(opts)<br>          dap.listeners.after.event_initialized[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">open</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>          dap.listeners.before.event_terminated[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>          dap.listeners.before.event_exited[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span>,<br>      &#125;,<br><br>      <span class="hljs-comment">-- virtual text for the debugger</span><br>      &#123;<br>        <span class="hljs-string">&quot;theHamsta/nvim-dap-virtual-text&quot;</span>,<br>        opts = &#123;&#125;,<br>      &#125;,<br><br>      <span class="hljs-comment">-- which key integration</span><br>      &#123;<br>        <span class="hljs-string">&quot;folke/which-key.nvim&quot;</span>,<br>        optional = <span class="hljs-literal">true</span>,<br>        opts = &#123;<br>          defaults = &#123;<br>            [<span class="hljs-string">&quot;&lt;leader&gt;d&quot;</span>] = &#123; name = <span class="hljs-string">&quot;+debug&quot;</span> &#125;,<br>          &#125;,<br>        &#125;,<br>      &#125;,<br><br>      <span class="hljs-comment">-- mason.nvim integration</span><br>      &#123;<br>        <span class="hljs-string">&quot;jay-babu/mason-nvim-dap.nvim&quot;</span>,<br>        dependencies = <span class="hljs-string">&quot;mason.nvim&quot;</span>,<br>        cmd = &#123; <span class="hljs-string">&quot;DapInstall&quot;</span>, <span class="hljs-string">&quot;DapUninstall&quot;</span> &#125;,<br>        opts = &#123;<br>          <span class="hljs-comment">-- Makes a best effort to setup the various debuggers with</span><br>          <span class="hljs-comment">-- reasonable debug configurations</span><br>          automatic_installation = <span class="hljs-literal">true</span>,<br><br>          <span class="hljs-comment">-- You can provide additional configuration to the handlers,</span><br>          <span class="hljs-comment">-- see mason-nvim-dap README for more information</span><br>          handlers = &#123;&#125;,<br><br>          <span class="hljs-comment">-- You&#x27;ll need to check that you have the required things installed</span><br>          <span class="hljs-comment">-- online, please don&#x27;t ask me how to install them :)</span><br>          ensure_installed = &#123;<br>            <span class="hljs-comment">-- Update this to ensure that you have the debuggers for the langs you want</span><br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br><br>  <span class="hljs-comment">-- stylua: ignore</span><br>  keys = &#123;<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dB&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).set_breakpoint(vim.fn.<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Breakpoint condition: &#x27;</span>)) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Breakpoint Condition&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;db&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).toggle_breakpoint() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Toggle Breakpoint&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).continue() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Continue&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;da&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).continue(&#123; before = get_args &#125;) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run with Args&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dC&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).run_to_cursor() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run to Cursor&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dg&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).goto_() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Go to line (no execute)&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;di&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_into() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Into&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dj&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).down() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Down&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dk&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).up() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Up&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dl&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).run_last() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run Last&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;do&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_out() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Out&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dO&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_over() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Over&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dp&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).pause() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Pause&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dr&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).repl.toggle() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Toggle REPL&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;ds&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).session() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Session&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dt&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).terminate() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Terminate&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dw&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap.ui.widgets&quot;</span>).hover() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Widgets&quot;</span> &#125;,<br>  &#125;,<br><br>    <span class="hljs-built_in">config</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>      <span class="hljs-keyword">local</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lazyvim.config&quot;</span>)<br>      vim.api.nvim_set_hl(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;DapStoppedLine&quot;</span>, &#123; default = <span class="hljs-literal">true</span>, link = <span class="hljs-string">&quot;Visual&quot;</span> &#125;)<br><br>      <span class="hljs-keyword">for</span> name, sign <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(Config.icons.dap) <span class="hljs-keyword">do</span><br>        sign = <span class="hljs-built_in">type</span>(sign) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">and</span> sign <span class="hljs-keyword">or</span> &#123; sign &#125;<br>        vim.fn.sign_define(<br>          <span class="hljs-string">&quot;Dap&quot;</span> .. name,<br>          &#123; text = sign[<span class="hljs-number">1</span>], texthl = sign[<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;DiagnosticInfo&quot;</span>, linehl = sign[<span class="hljs-number">3</span>], numhl = sign[<span class="hljs-number">3</span>] &#125;<br>        )<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">require(&quot;dap-go&quot;).setup(&#123;</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">Additional</span> <span class="hljs-string">dap</span> <span class="hljs-string">configurations</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">added.</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">dap_configurations</span> <span class="hljs-string">accepts</span> <span class="hljs-string">a</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">tables</span> <span class="hljs-string">where</span> <span class="hljs-string">each</span> <span class="hljs-string">entry</span><br>  <span class="hljs-string">dap_configurations</span> <span class="hljs-string">=</span> &#123;<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowServer&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/server/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowJob&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/job/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowGRPC&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/grpc/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowMigrate&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/migrate/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;Integhub&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/server/main.go&quot;</span>,<br>    &#125;,<br>  &#125;<span class="hljs-string">,</span> <span class="hljs-string">--</span> <span class="hljs-attr">represents a dap configuration. For more details do:</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">:help</span> <span class="hljs-string">dap-configuration</span><br><br>  <span class="hljs-string">--</span> <span class="hljs-string">delve</span> <span class="hljs-string">configurations</span><br>  <span class="hljs-string">delve</span> <span class="hljs-string">=</span> &#123;<br>    <span class="hljs-string">--</span> <span class="hljs-string">the</span> <span class="hljs-string">path</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">executable</span> <span class="hljs-string">dlv</span> <span class="hljs-string">which</span> <span class="hljs-string">will</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">for</span> <span class="hljs-string">debugging.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">by</span> <span class="hljs-string">default</span>, <span class="hljs-string">this</span> <span class="hljs-string">is</span> <span class="hljs-string">the</span> <span class="hljs-string">&quot;dlv&quot;</span> <span class="hljs-string">executable</span> <span class="hljs-string">on</span> <span class="hljs-string">your</span> <span class="hljs-string">PATH.</span><br>    <span class="hljs-string">path</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;dlv&quot;</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">time</span> <span class="hljs-string">to</span> <span class="hljs-string">wait</span> <span class="hljs-string">for</span> <span class="hljs-string">delve</span> <span class="hljs-string">to</span> <span class="hljs-string">initialize</span> <span class="hljs-string">the</span> <span class="hljs-string">debug</span> <span class="hljs-string">session.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">default</span> <span class="hljs-string">to</span> <span class="hljs-number">20</span> <span class="hljs-string">seconds</span><br>    <span class="hljs-string">initialize_timeout_sec</span> <span class="hljs-string">=</span> <span class="hljs-number">20</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">a</span> <span class="hljs-string">string</span> <span class="hljs-string">that</span> <span class="hljs-string">defines</span> <span class="hljs-string">the</span> <span class="hljs-string">port</span> <span class="hljs-string">to</span> <span class="hljs-string">start</span> <span class="hljs-string">delve</span> <span class="hljs-string">debugger.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">default</span> <span class="hljs-string">to</span> <span class="hljs-string">string</span> <span class="hljs-string">&quot;$&#123;port&#125;&quot;</span> <span class="hljs-string">which</span> <span class="hljs-string">instructs</span> <span class="hljs-string">nvim-dap</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">to</span> <span class="hljs-string">start</span> <span class="hljs-string">the</span> <span class="hljs-string">process</span> <span class="hljs-string">in</span> <span class="hljs-string">a</span> <span class="hljs-string">random</span> <span class="hljs-string">available</span> <span class="hljs-string">port</span><br>    <span class="hljs-string">port</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;$&#123;port&#125;&quot;</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">additional</span> <span class="hljs-string">args</span> <span class="hljs-string">to</span> <span class="hljs-string">pass</span> <span class="hljs-string">to</span> <span class="hljs-string">dlv</span><br>    <span class="hljs-string">args</span> <span class="hljs-string">=</span> &#123;&#125;,<br>    <span class="hljs-string">--</span> <span class="hljs-string">the</span> <span class="hljs-string">build</span> <span class="hljs-string">flags</span> <span class="hljs-string">that</span> <span class="hljs-string">are</span> <span class="hljs-string">passed</span> <span class="hljs-string">to</span> <span class="hljs-string">delve.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">defaults</span> <span class="hljs-string">to</span> <span class="hljs-string">empty</span> <span class="hljs-string">string</span>, <span class="hljs-string">but</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">to</span> <span class="hljs-string">provide</span> <span class="hljs-string">flags</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">such</span> <span class="hljs-string">as</span> <span class="hljs-string">&quot;-tags=unit&quot;</span> <span class="hljs-string">to</span> <span class="hljs-string">make</span> <span class="hljs-string">sure</span> <span class="hljs-string">the</span> <span class="hljs-string">test</span> <span class="hljs-string">suite</span> <span class="hljs-string">is</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">compiled</span> <span class="hljs-string">during</span> <span class="hljs-string">debugging</span>, <span class="hljs-string">for</span> <span class="hljs-string">example.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">passing</span> <span class="hljs-string">build</span> <span class="hljs-string">flags</span> <span class="hljs-string">using</span> <span class="hljs-string">args</span> <span class="hljs-string">is</span> <span class="hljs-string">ineffective</span>, <span class="hljs-string">as</span> <span class="hljs-string">those</span> <span class="hljs-string">are</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">ignored</span> <span class="hljs-string">by</span> <span class="hljs-string">delve</span> <span class="hljs-string">in</span> <span class="hljs-string">dap</span> <span class="hljs-string">mode.</span><br>    <span class="hljs-string">build_flags</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;<span class="hljs-string">,</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log/slog&quot;</span><br><br><span class="hljs-string">&quot;github.com/traefik/yaegi/interp&quot;</span><br><span class="hljs-string">&quot;github.com/traefik/yaegi/stdlib&quot;</span><br><br><span class="hljs-string">&quot;powerlaw.ai/ae/integhub/pkg/param&quot;</span><br><span class="hljs-string">&quot;powerlaw.ai/ae/integhub/runtime/yaegi&quot;</span>. <span class="hljs-comment">// 导入包</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">code2Runnable</span><span class="hljs-params">(code <span class="hljs-type">string</span>)</span></span> (runFunc, <span class="hljs-type">error</span>) &#123;<br>i := interp.New(interp.Options&#123;&#125;)<br><span class="hljs-keyword">if</span> err := loadLibs(i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to load libs: %w&quot;</span>, err)<br>&#125;<br><br>_, err := i.Eval(code)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to eval code: %w&quot;</span>, err)<br>&#125;<br><br>v, err := i.Eval(<span class="hljs-string">&quot;goapp.Run&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to get DemoGoApp: %w&quot;</span>, err)<br>&#125;<br>slog.Debug(<span class="hljs-string">&quot;app loaded&quot;</span>, <span class="hljs-string">&quot;app&quot;</span>, v)<br><br>rf, ok := v.Interface().(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>))<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrSignatureMismatch<br>&#125;<br><br><span class="hljs-keyword">return</span> rf, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadLibs</span><span class="hljs-params">(i *interp.Interpreter)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := i.Use(stdlib.Symbols); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to use stdlib: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := i.Use(yaegi.Symbols); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to use plibs: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2025/07/07/Docker/"/>
    <url>/2025/07/07/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li><li>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></li></ul><h2 id="1-Docker的基本概念"><a href="#1-Docker的基本概念" class="headerlink" title="1. Docker的基本概念"></a>1. Docker的基本概念</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h3 id="1-2-为什么是Docker"><a href="#1-2-为什么是Docker" class="headerlink" title="1.2 为什么是Docker"></a>1.2 为什么是Docker</h3><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p><p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势1: 一致的运行环境,更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p><p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p><p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p></li></ul><h3 id="1-3-Docker和虚拟机的区别"><a href="#1-3-Docker和虚拟机的区别" class="headerlink" title="1.3 Docker和虚拟机的区别"></a>1.3 Docker和虚拟机的区别</h3><blockquote><p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p></blockquote><p><img src="https://i.imgur.com/pwU9rfo.png" alt="img"></p><p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p><table><thead><tr><th align="left"></th><th align="left">传统虚拟机</th><th align="left">Docker容器</th></tr></thead><tbody><tr><td align="left">磁盘占用</td><td align="left">几个GB到几十个GB左右</td><td align="left">几十MB到几百MB左右</td></tr><tr><td align="left">CPU内存占用</td><td align="left">虚拟操作系统非常占用CPU和内存</td><td align="left">Docker引擎占用极低</td></tr><tr><td align="left">启动速度</td><td align="left">（从开机到运行项目）几分钟</td><td align="left">（从开启容器到运行项目）几秒</td></tr><tr><td align="left">安装管理</td><td align="left">需要专门的运维技术</td><td align="left">安装、管理方便</td></tr><tr><td align="left">应用部署</td><td align="left">每次部署都费时费力</td><td align="left">从第二次部署开始轻松简捷</td></tr><tr><td align="left">耦合性</td><td align="left">多个应用服务安装到一起，容易互相影响</td><td align="left">每个应用服务一个容器，达成隔离</td></tr><tr><td align="left">系统依赖</td><td align="left">无</td><td align="left">需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><hr><h2 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2. Docker的安装"></a>2. Docker的安装</h2><blockquote><p>以centos7为例 文档： <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p></blockquote><ul><li><p>卸载原始docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>安装docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y yum-utils<br><span class="hljs-built_in">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo <span class="hljs-comment"># 国内可能无法使用 可以使用下面的镜像源</span><br><span class="hljs-comment"># sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure></li><li><p>兼容性卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 卸载旧版本的docker</span><br>yum remove docker \<br>           docker-client \<br>           docker-client-latest \<br>           docker-common \<br>           docker-latest \<br>           docker-latest-logrotate \<br>           docker-logrotate \<br>           docker-selinux \<br>           docker-engine-selinux \<br>           docker-engine<br><span class="hljs-comment"># 卸载新版本的docker（叫docker-ce）</span><br>yum remove docker-ce \<br>           docker-ce-cli \<br>           containerd<br><br><span class="hljs-comment"># 停止删除服务</span><br>systemctl stop docker<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service.d<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service<br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><span class="hljs-built_in">rm</span> -rf /var/run/docker<br><span class="hljs-built_in">rm</span> -rf /usr/local/docker<br><span class="hljs-built_in">rm</span> -rf /etc/docker<br><span class="hljs-built_in">rm</span> -rf /usr/bin/docker* /usr/bin/containerd* /usr/bin/runc /usr/bin/ctr<br></code></pre></td></tr></table></figure><p>删除之后再进行<strong>安装</strong>可能会遇到报错</p><p><img src="https://i.imgur.com/k9kZxJn.png" alt="image-20240528220125947"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看冲突的依赖包</span><br>yum list installed | grep docker<br><span class="hljs-comment"># 删除后安装其他指定版本</span><br>rpm -e docker-client.x86_64、rpm -e docker-common.x86_64<br></code></pre></td></tr></table></figure></li></ul><p>​<img src="https://i.imgur.com/6t0ZMvR.png" alt="image-20240528220350909"></p><h2 id="3-Docker的核心架构"><a href="#3-Docker的核心架构" class="headerlink" title="3. Docker的核心架构"></a>3. Docker的核心架构</h2><p><img src="https://i.imgur.com/qULQy2h.png" alt="img"></p><ul><li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li><li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li><li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li><li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li><li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li></ul><h2 id="4-Docker配置阿里云镜像加速"><a href="#4-Docker配置阿里云镜像加速" class="headerlink" title="4. Docker配置阿里云镜像加速"></a>4. Docker配置阿里云镜像加速</h2><ul><li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><code>验证docker的镜像加速是否生效</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br>   Registry Mirrors:<br>    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;<br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><h3 id="5-1-辅助命令"><a href="#5-1-辅助命令" class="headerlink" title="5.1 辅助命令"></a>5.1 辅助命令</h3><pre><code class="hljs">docker version--------------------------查看docker的信息docker info--------------------------查看更详细的信息docker --help--------------------------帮助命令</code></pre><h3 id="5-2-Images-镜像命令"><a href="#5-2-Images-镜像命令" class="headerlink" title="5.2 Images 镜像命令"></a>5.2 Images 镜像命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看本机中所有镜像</span><br>docker images--------------------------列出本地所有镜像<br>-a列出所有镜像（包含中间映像层）<br>  -q只显示镜像<span class="hljs-built_in">id</span><br><span class="hljs-comment"># 2.搜索镜像</span><br>docker search [options] 镜像名-------------------去dockerhub上查询当前镜像<br>-s 指定值列出收藏数不少于指定值的镜像<br>  --no-trunc  显示完整的镜像信息<br><span class="hljs-comment"># 3.从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]----------------- 下载镜像<br><span class="hljs-comment"># 4.删除镜像</span><br>docker rmi 镜像名--------------------------  删除镜像<br>-f强制删除<br></code></pre></td></tr></table></figure><h3 id="5-3-Container命令"><a href="#5-3-Container命令" class="headerlink" title="5.3 Container命令"></a>5.3 Container命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.运行容器</span><br>docker run 镜像名--------------------------镜像名新建并启动容器<br>    --name 别名为容器起一个名字<br>    -d启动守护式容器（在后台启动容器）<br>    -p 映射端口号：原始端口号 指定端口号启动<br><br>例：docker run -it --name myTomcat -p 8888:8080 tomcat<br>    docker run -d --name myTomcat -P tomcat<br><br><span class="hljs-comment"># 2.查看运行的容器</span><br>docker ps--------------------------列出所有正在运行的容器<br>    -a正在运行的和历史运行过的容器<br>    -q静默模式，只显示容器编号<br><br><span class="hljs-comment"># 3.停止|关闭|重启容器</span><br>docker start   容器名字或者容器<span class="hljs-built_in">id</span>  --------------- 开启容器<br>docker restart 容器名或者容器<span class="hljs-built_in">id</span>    --------------- 重启容器<br>docker stop  容器名或者容器<span class="hljs-built_in">id</span>     ------------------ 正常停止容器运行<br>docker <span class="hljs-built_in">kill</span>  容器名或者容器<span class="hljs-built_in">id</span>      ------------------ 立即停止容器运行<br><br><span class="hljs-comment"># 4.删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f 容器<span class="hljs-built_in">id</span>和容器名     <br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)--------------------------删除所有容器<br><br><span class="hljs-comment"># 5.查看容器内进程</span><br>docker top 容器<span class="hljs-built_in">id</span>或者容器名 ------------------ 查看容器内的进程<br><br><span class="hljs-comment"># 6.查看查看容器内部细节</span><br>docker inspect 容器<span class="hljs-built_in">id</span> ------------------ 查看容器内部细节<br><br><span class="hljs-comment"># 7.查看容器的运行日志</span><br>docker logs [OPTIONS] 容器<span class="hljs-built_in">id</span>或容器名------------------ 查看容器日志<br>    -t 加入时间戳<br>    -f 跟随最新的日志打印<br>    --<span class="hljs-built_in">tail</span>  数字显示最后多少条<br><br><span class="hljs-comment"># 8.进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> [options] 容器<span class="hljs-built_in">id</span> 容器内命令 ------------------ 进入容器执行命令<br>-i以交互模式运行容器，通常与-t一起使用<br>    -t分配一个伪终端    shell窗口   bash <br><br><span class="hljs-comment"># 9.容器和宿主机之间复制文件</span><br>docker <span class="hljs-built_in">cp</span> 文件|目录 容器<span class="hljs-built_in">id</span>:容器路径           -----------------   将宿主机复制到容器内部<br>docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上<br><br><span class="hljs-comment"># 10.数据卷(volum)实现与宿主机共享目录</span><br>docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名<br>注意: <br>    1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容<br>    2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中<br><br><span class="hljs-comment"># 11.打包镜像</span><br>docker save 镜像名 -o  名称.tar<br><br><span class="hljs-comment"># 12.载入镜像</span><br>docker load -i   名称.tar<br><br><span class="hljs-comment"># 13.容器打包成新的镜像</span><br>docker commit -m <span class="hljs-string">&quot;描述信息&quot;</span> -a <span class="hljs-string">&quot;作者信息&quot;</span>   （容器<span class="hljs-built_in">id</span>或者名称）打包的镜像名称:标签<br><br><span class="hljs-comment"># 14. 容器重新命名</span><br>docker tag [镜像<span class="hljs-built_in">id</span>] [新镜像名称]:[新镜像标签]<br></code></pre></td></tr></table></figure><h2 id="6-Docker镜像的原理"><a href="#6-Docker镜像的原理" class="headerlink" title="6. Docker镜像的原理"></a>6. Docker镜像的原理</h2><h3 id="6-1-镜像是什么"><a href="#6-1-镜像是什么" class="headerlink" title="6.1 镜像是什么"></a>6.1 镜像是什么</h3><blockquote><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p></blockquote><h3 id="6-2-Docker的镜像原理"><a href="#6-2-Docker的镜像原理" class="headerlink" title="6.2 Docker的镜像原理"></a>6.2 Docker的镜像原理</h3><blockquote><p><strong>docker的镜像实际是由一层一层的文件系统组成。</strong></p></blockquote><ul><li>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</li><li>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</li><li>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</li></ul><p><img src="https://i.imgur.com/mYIKz3o.png" alt="img"></p><p><code>UnionFS</code> (联合文件系统)： Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同的目录挂载到同一个虚拟机文件系统下，Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以用来制作各种具体的应用镜像。</p><p>特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>怎么理解？当我们执行docker pull 的时候会拉取很多模块</p></blockquote><h2 id="7-Docker安装常用服务"><a href="#7-Docker安装常用服务" class="headerlink" title="7. Docker安装常用服务"></a>7. Docker安装常用服务</h2><h3 id="7-1-ETCD"><a href="#7-1-ETCD" class="headerlink" title="7.1 ETCD"></a>7.1 ETCD</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/docker/etcd/data ~/docker/etcd/conf<br><br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/data <br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/conf<br></code></pre></td></tr></table></figure></li><li><p>准备配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/docker/etcd/conf/etcd.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#成员名称</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">etcd01</span><br><span class="hljs-comment"># 数据保存路径</span><br><span class="hljs-attr">data-dir:</span> <span class="hljs-string">/data</span><br><span class="hljs-comment">#对外提供服务的地址</span><br><span class="hljs-attr">listen-client-urls:</span> <span class="hljs-string">http://0.0.0.0:2379</span><br><span class="hljs-comment">#成员之间通信地址</span><br><span class="hljs-attr">listen-peer-urls:</span> <span class="hljs-string">http://0.0.0.0:2380</span><br><span class="hljs-comment">#此成员的客户端URL列表，用于通告群集的其余部分。这些URL可以包含域名</span><br><span class="hljs-attr">advertise-client-urls:</span> <span class="hljs-string">http://etcd01:2379</span><br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name etcd -p 2379:2379 -p 2380:2380 \<br>-e ALLOW_NONE_AUTHENTICATION=<span class="hljs-built_in">yes</span> \<br>-e ETCD_CONFIG_FILE=/opt/bitnami/etcd/conf/etcd.yml \<br>-v ~/docker/etcd/data:/data \<br>-v ~/docker/etcd/conf:/opt/bitnami/etcd/conf \<br>bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>进入 ETCD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -u root -it etcd /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker update --restart=always etcd<br></code></pre></td></tr></table></figure></li><li><p>其他</p><p><a href="https://xie.infoq.cn/link?target=https://github.com/etcd-io/etcd/blob/main/etcd.conf.yml.sample">详细配置文件地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证安装</span><br>etcd --version<br></code></pre></td></tr></table></figure><ol><li><p>增加认证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下命令都需要进入 etcd 容器 shell</span><br>etcdctl user add root --interactive <span class="hljs-comment"># 增加用户 并以命令行形式设置密码</span><br>etcdctl role add root <span class="hljs-comment"># 增加root</span><br>etcdctl user grant-role root root <span class="hljs-comment"># 给 root 设置 root权限</span><br>etcdctl auth <span class="hljs-built_in">enable</span> <span class="hljs-comment"># 开启认证</span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="7-2-MySQL"><a href="#7-2-MySQL" class="headerlink" title="7.2 MySQL"></a>7.2 MySQL</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /root/docker/mysql/data /root/docker/mysql/conf.d:/etc/mysql/conf.d <br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name mysql -v /root/docker/mysql/data:/var/lib/mysql -v /root/docker/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 13306:3306 -d mysql:5.7<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-Nginx"><a href="#7-3-Nginx" class="headerlink" title="7.3 Nginx"></a>7.3 Nginx</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx:latest<br></code></pre></td></tr></table></figure></li><li><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/conf<br><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/log<br><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/html<br></code></pre></td></tr></table></figure></li><li><p>获取 nginx 文件</p><ol><li><p>临时运行一个 <code>nginx</code> 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name nginx -p 9001:80 -d nginx<br></code></pre></td></tr></table></figure></li><li><p>将容器中的文件复制出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/nginx.conf /root/deploy/docker/nginx/conf/nginx.conf<br>docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/conf.d /root/deploy/docker/nginx/conf/conf.d<br>docker <span class="hljs-built_in">cp</span> nginx:/usr/share/nginx/html /root/deploy/docker/nginx<br></code></pre></td></tr></table></figure></li></ol></li><li><p>创建 Nginx 容器并运行</p><ol><li><p>停止之前运行的 <code>nginx</code>容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a | grep nginx<br>docker stop nginx<br>docker <span class="hljs-built_in">rm</span> nginx<br>docker <span class="hljs-built_in">rm</span> -f nginx <span class="hljs-comment"># 删除正在运行的容器</span><br></code></pre></td></tr></table></figure></li><li><p>运行实际的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>-p 80:80 \<br>--name nginx \<br>-v /root/deploy/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v /root/deploy/docker/nginx/conf/conf.d:/etc/nginx/conf.d \<br>-v /root/deploy/docker/nginx/log:/var/log/nginx \<br>-v /root/deploy/docker/nginx/html:/usr/share/nginx/html \<br>-d nginx:latest<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="8-Dockerfile"><a href="#8-Dockerfile" class="headerlink" title="8. Dockerfile"></a>8. Dockerfile</h2><h3 id="8-1-什么是Dockerfile"><a href="#8-1-什么是Dockerfile" class="headerlink" title="8.1 什么是Dockerfile"></a>8.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p><p><img src="https://i.imgur.com/teEfIcy.png" alt="img"></p><ul><li>通过架构图可以看出Docker file 可以直接构建镜像</li></ul><h3 id="8-2-Docker-file解析过程"><a href="#8-2-Docker-file解析过程" class="headerlink" title="8.2 Docker file解析过程"></a>8.2 Docker file解析过程</h3><p><img src="https://i.imgur.com/4y60ija.png" alt="img"></p><h3 id="8-3-Dockerfile的保留命令"><a href="#8-3-Dockerfile的保留命令" class="headerlink" title="8.3 Dockerfile的保留命令"></a>8.3 Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left">保留字</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left"><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td align="left">MAINTAINER</td><td align="left">镜像维护者的姓名和邮箱地址</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left"><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left"><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td align="left"><strong>WORKDIR</strong></td><td align="left"><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left"><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td align="left"><strong>ADD</strong></td><td align="left"><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left"><strong>类似于ADD，拷贝文件和目录到镜像中 将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td align="left"><strong>VOLUME</strong></td><td align="left"><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td align="left"><strong>CMD</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="8-3-1-FROM-命令"><a href="#8-3-1-FROM-命令" class="headerlink" title="8.3.1 FROM 命令"></a>8.3.1 FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>  &lt;image&gt;<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-2-MAINTAINER-命令"><a href="#8-3-2-MAINTAINER-命令" class="headerlink" title="8.3.2 MAINTAINER 命令"></a>8.3.2 MAINTAINER 命令</h4><ul><li><p>镜像维护者的姓名和邮箱地址[废弃]</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-3-RUN-命令"><a href="#8-3-3-RUN-命令" class="headerlink" title="8.3.3 RUN 命令"></a>8.3.3 RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; (shell form, the <span class="hljs-built_in">command</span> is run <span class="hljs-keyword">in</span> a shell, <span class="hljs-built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> hello</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-4-EXPOSE-命令"><a href="#8-3-4-EXPOSE-命令" class="headerlink" title="8.3.4 EXPOSE 命令"></a>8.3.4 EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-5-CMD-命令"><a href="#8-3-5-CMD-命令" class="headerlink" title="8.3.5 CMD 命令"></a>8.3.5 CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form, this is the preferred form)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 (shell form)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-6-WORKDIR-命令"><a href="#8-3-6-WORKDIR-命令" class="headerlink" title="8.3.6 WORKDIR 命令"></a>8.3.6 WORKDIR 命令</h4><ul><li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br>`注意:<span class="hljs-keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-7-ENV-命令"><a href="#8-3-7-ENV-命令" class="headerlink" title="8.3.7 ENV 命令"></a>8.3.7 ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-8-ADD-命令"><a href="#8-3-8-ADD-命令" class="headerlink" title="8.3.8 ADD 命令"></a>8.3.8 ADD 命令</h4><ul><li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-9-COPY-命令"><a href="#8-3-9-COPY-命令" class="headerlink" title="8.3.9 COPY 命令"></a>8.3.9 COPY 命令</h4><ul><li><p>用来将context目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-10-VOLUME-命令"><a href="#8-3-10-VOLUME-命令" class="headerlink" title="8.3.10 VOLUME 命令"></a>8.3.10 VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂在到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-11-ENTRYPOINT-命令"><a href="#8-3-11-ENTRYPOINT-命令" class="headerlink" title="8.3.11 ENTRYPOINT 命令"></a>8.3.11 ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和CMD类似</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-4-Dockerfile构建SpringBoot应用"><a href="#8-4-Dockerfile构建SpringBoot应用" class="headerlink" title="8.4 Dockerfile构建SpringBoot应用"></a>8.4 Dockerfile构建SpringBoot应用</h3><ol><li><p>创建Spring Boot应用</p></li><li><p>执行打包命令</p></li><li><p>创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-spring-boot-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-spring-boot-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-springboot-demo .<br></code></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8081:8080 docker-springboot-demo<br></code></pre></td></tr></table></figure></li><li><p>访问项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location <span class="hljs-string">&#x27;http://localhost:8081/index&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker网络"><a href="#9-Docker网络" class="headerlink" title="9. Docker网络"></a>9. Docker网络</h2><p>当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。</p><p>我们在启动docker的时候，主机会有增加一个docker0的网络</p><p><img src="https://i.imgur.com/nZMAhP9.png" alt="image-20240513221855243"></p><blockquote><p>默认网络</p></blockquote><p>安装 Docker 以后，会默认创建三种网络，可以通过 <code>docker network ls</code> 查看。</p><p><img src="https://i.imgur.com/HNAdhQ7.png" alt="image-20240513222000607"></p><ul><li><p>bridge 网络模式</p><p>在该模式中，Docker 守护进程创建了一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包，并为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code></p><p>虚拟网桥，默认为该模式</p></li><li><p>host 网络模式</p><p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</p></li><li><p>none 网络模式</p><p>容器具有独立的Network namespace, 但并没有对其进行任何网络设置，如分配veth part和网桥连接，IP等</p></li><li><p>container 网络模式</p><p>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</p></li></ul><h3 id="9-1-Docker-网络常用命令"><a href="#9-1-Docker-网络常用命令" class="headerlink" title="9.1 Docker 网络常用命令"></a>9.1 Docker 网络常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network --<span class="hljs-built_in">help</span><br><br>Usage:  docker network COMMAND<br><br>Manage networks<br><br>Commands:<br>  connect     Connect a container to a network<br>  create      Create a network<br>  disconnect  Disconnect a container from a network<br>  inspect     Display detailed information on one or more networks<br>  <span class="hljs-built_in">ls</span>          List networks<br>  prune       Remove all unused networks<br>  <span class="hljs-built_in">rm</span>          Remove one or more networks<br><br>Run <span class="hljs-string">&#x27;docker network COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h3 id="9-2-Docker-网络能干嘛"><a href="#9-2-Docker-网络能干嘛" class="headerlink" title="9.2 Docker 网络能干嘛"></a>9.2 Docker 网络能干嘛</h3><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不收到任何影响</li></ul><h3 id="9-3-Docker-容器之间内部的通信"><a href="#9-3-Docker-容器之间内部的通信" class="headerlink" title="9.3 Docker 容器之间内部的通信"></a>9.3 Docker 容器之间内部的通信</h3><blockquote><p>Tips 通过自建网络实现</p></blockquote><ol><li><p>准备所需要环境</p><p>笔者使用ubuntu镜像实现，需要先拉取对应镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull ubuntu<br>docker images<br></code></pre></td></tr></table></figure><blockquote><p>如果出现docker search 可以使用，docker pull 失败的问题可以尝试看看是否是DNS的问题 &#x2F;etc</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/6BhHiZO.png" alt="image-20240514184217779"></p></li><li><p>创建网络</p><p>如果不清楚docker network命令可以使用<code>docker network --help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create test-network<br></code></pre></td></tr></table></figure><p>创建网络之后执行<code>docker network ls</code>看看是否执行成功</p></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动两个docker容器</span><br>docker run -it --name u1 --network test-network --network-alias ubuntu1  ubuntu bash<br>docker run -it --name u2 --network test-network --network-alias ubuntu2  ubuntu bash<br>   <br></code></pre></td></tr></table></figure><ul><li>–network 指定网络</li><li>–network-alias 指定网络名称（类似于主机名称，后续可以直接通过<code>ping</code>这个主机）</li></ul></li><li><p>安装容器环境</p><p>启动的容器是没有<code>ifconfig</code>,<code>ping</code>这些命令的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y net-tools &amp;&amp; apt install -y iputils-ping<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动两个容器，并进入<code>shell</code>，进入容器命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [container_id] bash<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://i.imgur.com/C9PS4pG.jpeg" alt="image-20240514184129680"></p></li></ol><h2 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><h3 id="9-2-docker-compose-安装"><a href="#9-2-docker-compose-安装" class="headerlink" title="9.2 docker-compose 安装"></a>9.2 docker-compose 安装</h3><blockquote><p>官网： <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>下载地址：<a href="https://docs.docker.com/compose/install">https://docs.docker.com/compose/install</a></p></blockquote><h3 id="9-3-docker-compose"><a href="#9-3-docker-compose" class="headerlink" title="9.3 docker compose"></a>9.3 docker compose</h3><ol><li><p>To download and install Compose standalone, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Apply executable permissions to the standalone binary in the target path for the installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Test and execute compose commands using <code>docker-compose</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose --version<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/CxmN9fd.png" alt="image-20240514212055991"></p></li></ol><h3 id="9-4-docker-compose常用命令"><a href="#9-4-docker-compose常用命令" class="headerlink" title="9.4 docker-compose常用命令"></a>9.4 docker-compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -h <span class="hljs-comment"># 查看帮助</span><br>docker-compose up <span class="hljs-comment"># 启动所有服务</span><br>docker-compose up -d <span class="hljs-comment"># 启动所有docker-compose服务并后台运行</span><br>docker-compose down <span class="hljs-comment"># 停止并删除容器、网络、卷、镜像</span><br>docker-compose <span class="hljs-built_in">exec</span> [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 进入容器实例内部</span><br>docker-compose ps <span class="hljs-comment"># 展示当前docker-compose编排过的运行的容器</span><br>docker-compose top <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程</span><br><br>docker-compose logs [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 查看容器输出日志</span><br>docker-compose config <span class="hljs-comment"># 检查配置</span><br>docker-compose config -q <span class="hljs-comment"># 检查配置，有问题才输出</span><br>docker-compose restart <span class="hljs-comment"># 重启服务</span><br>docker-compose start <span class="hljs-comment"># 启动服务</span><br>docker-compose stop <span class="hljs-comment"># 停止服务</span><br></code></pre></td></tr></table></figure><h3 id="9-5-docker-compose-使用"><a href="#9-5-docker-compose-使用" class="headerlink" title="9.5 docker-compose 使用"></a>9.5 docker-compose 使用</h3><ol><li><p>构建镜像（基于Spring Boot）</p><ol><li><p>编写代码</p></li><li><p>配置文件修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">docker-compose</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc://mysql:13306/compose?useUnicode=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure></li><li><p>编写Dockerfile、docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-compose-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-compose-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">composeService:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker-compose:1.6</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">dc1.6</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6001:6001&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/java-demo:/java-demo</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&quot;no&quot;</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&quot;compose&quot;</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&quot;root&quot;</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/db:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/conf/my.cnf:/etc/my.cnf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/init:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span> <span class="hljs-comment"># 解决外部无法访问</span><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">compose_net:</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>上传镜像和相关文件</p></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-compose:1.6 .<br></code></pre></td></tr></table></figure></li><li><p>执行核心操作</p><ul><li>docker-compose up -d</li></ul></li></ol><blockquote><p>总结 尽量不要使用docker-compose 不好用</p></blockquote><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用<br>Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid<br></code></pre></td></tr></table></figure><blockquote><p>这个错误的原因是因为系统的时间和docker hub时间不一致，需要做系统时间与网络时间同步</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装时间同步</span><br><span class="hljs-built_in">sudo</span> yum -y install ntp ntpdate<br><span class="hljs-comment"># 2.同步时间</span><br><span class="hljs-built_in">sudo</span> ntpdate cn.pool.ntp.org<br><span class="hljs-comment"># 3.查看本机时间</span><br><span class="hljs-built_in">date</span><br><span class="hljs-comment"># 4.重新测试</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>运维</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 常用扩展点</title>
    <link href="/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <url>/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-常用扩展点"><a href="#Spring-常用扩展点" class="headerlink" title="Spring 常用扩展点"></a>Spring 常用扩展点</h1><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><p>这篇文章总结了 <code>Spring</code>所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。</p><h2 id="1-调用顺序"><a href="#1-调用顺序" class="headerlink" title="1. 调用顺序"></a>1. 调用顺序</h2><p>以下按 Spring 容器生命周期阶段分类整理了常见扩展点及其方法，便于理解执行时机和作用。</p><h3 id="🟦-1-容器初始化阶段（ApplicationContext-初始化前）"><a href="#🟦-1-容器初始化阶段（ApplicationContext-初始化前）" class="headerlink" title="🟦 1. 容器初始化阶段（ApplicationContext 初始化前）"></a>🟦 1. 容器初始化阶段（<code>ApplicationContext</code> 初始化前）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ApplicationContextInitializer</code></td><td><code>initialize()</code></td><td>初始化 <code>ApplicationContext</code> 之前执行，通常配合 SpringBoot 使用</td></tr><tr><td><code>AbstractApplicationContext</code></td><td><code>refresh()</code></td><td>启动容器的主流程入口方法</td></tr></tbody></table><hr><h3 id="🟦-2-Bean-定义阶段（Bean-还未实例化）"><a href="#🟦-2-Bean-定义阶段（Bean-还未实例化）" class="headerlink" title="🟦 2. Bean 定义阶段（Bean 还未实例化）"></a>🟦 2. Bean 定义阶段（Bean 还未实例化）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BeanDefinitionRegistryPostProcessor</code></td><td><code>postProcessBeanDefinitionRegistry()</code></td><td>可动态注册&#x2F;修改 Bean 定义</td></tr><tr><td><code>BeanDefinitionRegistryPostProcessor</code></td><td><code>postProcessBeanFactory()</code></td><td>可操作 BeanFactory</td></tr><tr><td><code>BeanFactoryPostProcessor</code></td><td><code>postProcessBeanFactory()</code></td><td>可修改 BeanDefinition 的属性</td></tr></tbody></table><hr><h3 id="🟧-3-Bean-实例化前阶段（对象还没创建）"><a href="#🟧-3-Bean-实例化前阶段（对象还没创建）" class="headerlink" title="🟧 3. Bean 实例化前阶段（对象还没创建）"></a>🟧 3. Bean 实例化前阶段（对象还没创建）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessBeforeInstantiation()</code></td><td>创建实例前，可返回代理对象短路流程</td></tr><tr><td><code>SmartInstantiationAwareBeanPostProcessor</code></td><td><code>determineCandidateConstructors()</code></td><td>决定使用哪个构造函数创建实例</td></tr></tbody></table><h3 id="🟨-4-Bean-实例化后阶段（已创建但未填充属性）"><a href="#🟨-4-Bean-实例化后阶段（已创建但未填充属性）" class="headerlink" title="🟨 4. Bean 实例化后阶段（已创建但未填充属性）"></a>🟨 4. Bean 实例化后阶段（已创建但未填充属性）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>MergedBeanDefinitionPostProcessor</code></td><td><code>postProcessMergedBeanDefinition()</code></td><td>处理合并后的 Bean 定义，常用于注解支持</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessAfterInstantiation()</code></td><td>实例化后，属性注入前</td></tr><tr><td><code>SmartInstantiationAwareBeanPostProcessor</code></td><td><code>getEarlyBeanReference()</code></td><td>提供早期引用，解决循环依赖</td></tr><tr><td><code>BeanFactoryAware</code></td><td><code>setBeanFactory()</code></td><td>注入 <code>BeanFactory</code> 实例</td></tr></tbody></table><hr><h3 id="🟩-5-属性注入和初始化阶段"><a href="#🟩-5-属性注入和初始化阶段" class="headerlink" title="🟩 5. 属性注入和初始化阶段"></a>🟩 5. 属性注入和初始化阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessPropertyValues()</code></td><td>属性填充时调用</td></tr><tr><td><code>ApplicationContextAwareProcessor</code></td><td><code>invokeAwareInterfaces()</code></td><td>注入如 <code>ApplicationContext</code>, <code>BeanName</code> 等 Aware 接口</td></tr><tr><td><code>BeanNameAware</code></td><td><code>setBeanName()</code></td><td>注入当前 Bean 的名称</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessBeforeInitialization()</code></td><td>初始化方法调用前</td></tr><tr><td><code>@PostConstruct</code></td><td>注解方法</td><td>初始化注解（JSR-250）</td></tr><tr><td><code>InitializingBean</code></td><td><code>afterPropertiesSet()</code></td><td>初始化回调</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessAfterInitialization()</code></td><td>初始化方法调用后，常用于生成代理</td></tr></tbody></table><hr><h3 id="🟦-6-特殊-Bean-处理阶段"><a href="#🟦-6-特殊-Bean-处理阶段" class="headerlink" title="🟦 6. 特殊 Bean 处理阶段"></a>🟦 6. 特殊 Bean 处理阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>FactoryBean</code></td><td><code>getObject()</code></td><td>提供特殊 Bean 的工厂接口</td></tr><tr><td><code>SmartInitializingSingleton</code></td><td><code>afterSingletonsInstantiated()</code></td><td>所有单例对象初始化完毕后执行</td></tr></tbody></table><hr><h3 id="🟥-7-应用运行与销毁阶段"><a href="#🟥-7-应用运行与销毁阶段" class="headerlink" title="🟥 7. 应用运行与销毁阶段"></a>🟥 7. 应用运行与销毁阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>CommandLineRunner</code></td><td><code>run()</code></td><td>SpringBoot 启动后立即执行逻辑</td></tr><tr><td><code>DisposableBean</code></td><td><code>destroy()</code></td><td>Bean 销毁回调方法，容器关闭时触发</td></tr></tbody></table><h2 id="2-常用扩展点示例"><a href="#2-常用扩展点示例" class="headerlink" title="2. 常用扩展点示例"></a>2. 常用扩展点示例</h2><h3 id="1-ApplicationContextInitializer"><a href="#1-ApplicationContextInitializer" class="headerlink" title="1. ApplicationContextInitializer"></a>1. ApplicationContextInitializer</h3><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。<br>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><p><strong>扩展方式为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[ApplicationContextInitializer]&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><p>这个接口可以在 Spring Boot 等基于 Spring 框架的应用中使用，用于在应用启动时进行一些配置或初始化操作，例如加载配置文件、设置系统属性、注册自定义的 Bean 等。</p><h3 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2. BeanDefinitionRegistryPostProcessor"></a>2. BeanDefinitionRegistryPostProcessor</h3><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。<br>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><p>这个接口可以在 Spring Boot 等基于 Spring 框架的应用中使用，用于在应用启动时进行一些配置或初始化操作，例如加载配置文件、设置系统属性、注册自定义的 Bean 等。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[ApplicationContextInitializer]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li>在启动类中用springApplication.addInitializers(new TestApplicationContextInitializer())语句加入</li><li>配置文件配置context.initializer.classes&#x3D;com.example.demo.TestApplicationContextInitializer</li><li>Spring SPI扩展，在spring.factories中加入org.springframework.context.ApplicationContextInitializer&#x3D;com.example.demo.TestApplicationContextInitializer</li></ul><h3 id="3-BeanDefinitionRegistryPostProcessor"><a href="#3-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3. BeanDefinitionRegistryPostProcessor"></a>3. BeanDefinitionRegistryPostProcessor</h3><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点</p><p>使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean</p><p>扩展方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;</span>);    <br>    &#125;    <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="4-BeanFactoryPostProcessor"><a href="#4-BeanFactoryPostProcessor" class="headerlink" title="4. BeanFactoryPostProcessor"></a>4. BeanFactoryPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanFactoryPostProcessor]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="5-InstantiationAwareBeanPostProcessor"><a href="#5-InstantiationAwareBeanPostProcessor" class="headerlink" title="5. InstantiationAwareBeanPostProcessor"></a>5. InstantiationAwareBeanPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了BeanPostProcess接口，区别如下：</p><p>BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：实例化阶段和初始化阶段，下面一起进行说明，按调用顺序为：</p><ul><li>postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前</li><li>postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后</li><li>postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现</li><li>postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前</li><li>postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后</li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InstantiationAwareBeanPostProcessor</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> pvs;    <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-SmartInstantiationAwareBeanPostProcessor"><a href="#6-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="6. SmartInstantiationAwareBeanPostProcessor"></a>6. SmartInstantiationAwareBeanPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li>predictBeanType：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li><li>determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li><li>getEarlyBeanReference：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</li></ul><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInstantiationAwareBeanPostProcessor</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> beanClass;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="7-BeanFactoryAware"><a href="#7-BeanFactoryAware" class="headerlink" title="7. BeanFactoryAware"></a>7. BeanFactoryAware</h3><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanFactoryAware</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestBeanFactoryAware] &quot;</span> + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());    <br>    &#125;    <br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="8-ApplicationContextAwareProcessor"><a href="#8-ApplicationContextAwareProcessor" class="headerlink" title="8. ApplicationContextAwareProcessor"></a>8. ApplicationContextAwareProcessor</h3><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p>图片<br>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。所以这里应该来说是有6个扩展点，这里就放一起来说了</p><ul><li>EnvironmentAware：用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li><li>EmbeddedValueResolverAware：用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。</li><li>ResourceLoaderAware：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li><li>ApplicationEventPublisherAware：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。</li></ul><p>MessageSourceAware：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</p><p>ApplicationContextAware：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。</p><h3 id="9-BeanNameAware"><a href="#9-BeanNameAware" class="headerlink" title="9. BeanNameAware"></a>9. BeanNameAware</h3><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName</p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>&#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NormalBeanA</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;NormalBean constructor&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanNameAware] &quot;</span> + name);    <br>    &#125;    <br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="10-PostConstruct"><a href="#10-PostConstruct" class="headerlink" title="10. @PostConstruct"></a>10. @PostConstruct</h3><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NormalBeanA</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;NormalBean constructor&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@PostConstruct</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;    <br>        System.out.println(<span class="hljs-string">&quot;[PostConstruct] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="11-InitializingBean"><a href="#11-InitializingBean" class="headerlink" title="11. InitializingBean"></a>11. InitializingBean</h3><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>&#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[InitializingBean] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="12-FactoryBean"><a href="#12-FactoryBean" class="headerlink" title="12. FactoryBean"></a>12. FactoryBean</h3><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。</p><p>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。扩展：SpringBoot内容聚合</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> TestFactoryBean.TestFactoryInnerBean <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[FactoryBean] getObject&quot;</span>);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestFactoryBean</span>.TestFactoryInnerBean();    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;    <br>        <span class="hljs-keyword">return</span> TestFactoryBean.TestFactoryInnerBean.class;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFactoryInnerBean</span>&#123;    <br>    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-SmartInitializingSingleton"><a href="#13-SmartInitializingSingleton" class="headerlink" title="13. SmartInitializingSingleton"></a>13. SmartInitializingSingleton</h3><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法afterSingletonsInstantiated，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为postProcessAfterInitialization之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSmartInitializingSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInitializingSingleton</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInitializingSingleton]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="14-CommandLineRunner"><a href="#14-CommandLineRunner" class="headerlink" title="14. CommandLineRunner"></a>14. CommandLineRunner</h3><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：run(String… args)，触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestCommandLineRunner]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="15-DisposableBean"><a href="#15-DisposableBean" class="headerlink" title="15. DisposableBean"></a>15. DisposableBean</h3><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：destroy()，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisposableBean</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[DisposableBean] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="16-ApplicationListener"><a href="#16-ApplicationListener" class="headerlink" title="16.ApplicationListener"></a>16.ApplicationListener</h3><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，ApplicationListener可以监听某个事件的event，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。</p><p>但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li><p>ContextRefreshedEvent</p><p>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。</p></li><li><p>ContextStartedEvent</p><p>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent</p><p>当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p></li><li><p>ContextClosedEvent</p><p>当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p></li><li><p>RequestHandledEvent</p><p>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux &amp; Hyperland</title>
    <link href="/2024/05/15/Linux/Arch%20linux%20&amp;%20Hyperland/"/>
    <url>/2024/05/15/Linux/Arch%20linux%20&amp;%20Hyperland/</url>
    
    <content type="html"><![CDATA[<h1 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h1><h2 id="发行版选择"><a href="#发行版选择" class="headerlink" title="发行版选择"></a>发行版选择</h2><p>Arch Linux 有很多发行版，笔者采用 <strong>EndeavourOS</strong></p><p><strong>EndeavourOS</strong>是轻量级的，并且附带了最少数量的预装应用程序。一块近乎空白的画布，随时可以个性化。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装教程有很多，在这不做过多阐述，笔者推荐一个做启动盘的工具。<a href="https://www.ventoy.net/en/index.html">ventoy</a></p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>笔者最开始安装 Arch Linux 发行版，遇到了很多问题，尝试使用 Docker 安装 <code>V2rayA</code>，来走 <code>tun</code>代理，但是失败了，后面通过 <code>yay</code> 安装 <code>clash verge rev</code>来实现代理，下面展示安装步骤</p><h3 id="Clash-Verge-rev"><a href="#Clash-Verge-rev" class="headerlink" title="Clash Verge rev"></a>Clash Verge rev</h3><blockquote><p>由于安装 <code>clash verge rev</code>需要从 <code>github</code>下载，因此需要使用代理，笔者因为还有其他电脑，再其他电脑上开启了局域网代理</p></blockquote><p><img src="https://i.imgur.com/9RksGFa.png" alt="image-20250515100402352"></p><p>然后再 linux 上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=http://xxx:7890 http_proxy=http://xxx:7890 all_proxy=socks5://xxx:7890<br></code></pre></td></tr></table></figure><p>安装 <code>clash verge rev</code></p><ol><li><p>paru</p><ol><li><p>安装 <code>paru</code></p><ol><li><p>在 <code>/etc/pacman.conf</code> 文件中写入下列内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[archlinuxcn]<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.hit.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://repo.huaweicloud.com/archlinuxcn/<span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure></li><li><p>在终端运行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman-key --lsign-key <span class="hljs-string">&quot;farseerfc@archlinux.org&quot;</span><br><span class="hljs-built_in">sudo</span> pacman -S archlinuxcn-keyring<br><span class="hljs-built_in">sudo</span> pacman -S paru<br></code></pre></td></tr></table></figure></li></ol></li><li><p>安装 <code>clash-verge-rev-bin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>yay</code></p><ol><li><p>安装 <code>yay</code></p><ol><li><p>在 <code>/etc/pacman.conf</code> 文件中写入下列内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[archlinuxcn]<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.hit.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://repo.huaweicloud.com/archlinuxcn/<span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure></li><li><p>在终端运行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman-key --lsign-key <span class="hljs-string">&quot;farseerfc@archlinux.org&quot;</span><br><span class="hljs-built_in">sudo</span> pacman -S archlinuxcn-keyring<br><span class="hljs-built_in">sudo</span> pacman -S yay<br></code></pre></td></tr></table></figure></li></ol></li><li><p>安装 <code>clash-verge-rev-bin</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li><p>安装 docker、docker-compose</p></li><li><p>docker-compose.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">v2ray:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mzz2017/v2raya</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">host</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">v2ray</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/v2ray/:/etc/v2raya</span><br></code></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker-compose up -d<br></code></pre></td></tr></table></figure></li><li><p>使用方法 </p><p>参考<a href="https://v2raya.org/docs/prologue/installation/docker/">v2rayA</a></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://clashverge.uk/install/install">Arch Linux 下载</a></p></li><li><p><a href="https://www.ventoy.net/en/index.html">ventoy</a></p></li><li><p><a href="https://v2raya.org/docs/prologue/installation/docker/">v2rayA</a></p></li></ul><h1 id="Hyperland"><a href="#Hyperland" class="headerlink" title="Hyperland"></a>Hyperland</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>笔者使用的是 <a href="https://github.com/HyDE-Project/HyDE">Hyde</a>，一键安装即可</p><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>安装完成 Hyperland，可以开始处理中文输入法，笔者使用 <code>fcitx5</code></p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fctix5-im fcitx5-chinese-addons<br></code></pre></td></tr></table></figure></li><li><p>配置</p><ol><li><p>设置启动使用 <code>fctix5</code></p><p>在 <code>~/.config/hypr/hyprland.conf</code> 里添加，然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exec-once=fcitx5 --replace -d<br></code></pre></td></tr></table></figure></li><li><p>wayland 在 electron 应用下可能会存在问题，需要设置 electron 参数</p><p>编辑 <code>~/.config/electron-flags.conf</code>，然后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">--enable-features=UseOzonePlatform<br>--ozone-platform=wayland<br>--enable-wayland-ime<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>笔者遇到的问题，每次开机可能都需要输入 wifi 密码，需要切换到 KDE 下，将 wifi 设置为所有账户可以连接，然后再切换到 Hyperland</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/HyDE-Project/HyDE">Hyperland 配置</a></li><li><a href="https://www.bilibili.com/opus/817423840849166391">输入法安装</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
      <category>Linux</category>
      
      <category>Hyperland</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>钉钉单点登录</title>
    <link href="/2024/05/15/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/%E9%92%89%E9%92%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <url>/2024/05/15/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/%E9%92%89%E9%92%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="钉钉单点登录"><a href="#钉钉单点登录" class="headerlink" title="钉钉单点登录"></a>钉钉单点登录</h1><p>公司需要通过自建应用实现应用单点到我们系统，在此基础上通过创建钉钉应用，实现单点登录，以及发送消息等功能。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><pre><code class=" mermaid">sequenceDiagram    participant User as 用户    participant App as 应用系统    participant DingTalk as 钉钉    participant Backend as 后端服务    User-&gt;&gt;App: 访问登录页    App-&gt;&gt;DingTalk: 跳转钉钉扫码登录页面    User-&gt;&gt;DingTalk: 使用钉钉扫码授权    DingTalk--&gt;&gt;App: 回调授权码（auth_code）    App-&gt;&gt;Backend: 携带 auth_code 请求登录    Backend-&gt;&gt;DingTalk: 使用 auth_code 请求用户信息    DingTalk--&gt;&gt;Backend: 返回用户信息（userId、unionId等）    Backend--&gt;&gt;App: 返回登录成功状态 + 用户信息    App--&gt;&gt;User: 登录成功，进入系统</code></pre><h3 id="1-创建自定义应用"><a href="#1-创建自定义应用" class="headerlink" title="1. 创建自定义应用"></a>1. 创建自定义应用</h3><blockquote><p>需要拥有开发者或则管理员权限 </p><p>钉钉开放平台:<a href="https://open-dev.dingtalk.com/fe/app?hash=%23/corp/app#/corp/app">https://open-dev.dingtalk.com/fe/app?hash=%23%2Fcorp%2Fapp#/corp/app</a></p></blockquote><p>钉钉开放平台-&gt;创建应用</p><p><img src="https://i.imgur.com/vsLHIv9.png" alt="image-20250512154727832"></p><p><img src="https://i.imgur.com/gzK6JzV.png" alt="image-20250512154756148"></p><h3 id="2-给应用申请权限"><a href="#2-给应用申请权限" class="headerlink" title="2. 给应用申请权限"></a>2. 给应用申请权限</h3><p>点击刚创建的应用-&gt;权限管理<br><img src="https://i.imgur.com/WV5HakS.png" alt="image-20250512154853116"></p><p>申请权限列表为：</p><ol><li>Contact.User.Read</li><li>fieldEmail</li><li>qyapi_get_member</li><li>qyapi_get_omp_sso_userinfo</li><li>open_app_api_base</li><li>api_get_member_by_mobile</li></ol><p>应该这几个就行了，可能实际会有变化</p><p>输入框中输入上述code点击申请（已申请按钮会变成移除权限）</p><h3 id="3-添加网页应用能力"><a href="#3-添加网页应用能力" class="headerlink" title="3. 添加网页应用能力"></a>3. 添加网页应用能力</h3><h3 id="4-添加网页应用能力"><a href="#4-添加网页应用能力" class="headerlink" title="4. 添加网页应用能力"></a>4. 添加网页应用能力</h3><p>填写网页地址，地址为：<a href="https://wiki.chenhailong.com/workBench?in=dingtalk&orgId=%E6%9C%BA%E6%9E%84%E5%8F%B7id">https://wiki.chenhailong.com/workBench?in=dingtalk&amp;orgId=机构号id</a></p><p><img src="https://i.imgur.com/QH53eiR.png" alt="image-20250512154955250"></p><p><img src="https://i.imgur.com/GEGmnP1.png" alt="image-20250512155042874"></p><h3 id="5-分享设置"><a href="#5-分享设置" class="headerlink" title="5. 分享设置"></a>5. 分享设置</h3><blockquote><p>域名为：<a href="https://wiki.chenhailong.com/">https://wiki.chenhailong.com</a></p></blockquote><p>在分享设置中设置域名（表示当前应用对那些域名可见）</p><p><img src="https://i.imgur.com/oaUFFCZ.png" alt="image-20250512155257515"></p><h3 id="6-发送消息"><a href="#6-发送消息" class="headerlink" title="6. 发送消息"></a>6. 发送消息</h3><p>需要提供 appID 和 corpID</p><ul><li><p>appID<br><img src="https://i.imgur.com/173rw26.png" alt="image-20250512155440848"></p></li><li><p>corpID</p><p><img src="https://i.imgur.com/vayv9wE.png" alt="image-20250512155513766"></p></li></ul><h1 id="单点登录方案"><a href="#单点登录方案" class="headerlink" title="单点登录方案"></a>单点登录方案</h1><h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><ol><li><p>应用创建配置网页应用携带了 <code>in=dingtalk&amp;orgId=chenhailong</code></p><ol><li><code>dingtalk</code>: 表示从dingtalk 平台进行登录，业务前端如果识别到当前未处于登录态，需要调用后端接口 <code>oauth_uri</code> 来进行跳转</li><li><code>orgId</code>: 多租户时使用</li></ol></li><li><p>调用 <code>oauth_uri</code>接口，返回钉钉的一个跳转页面，然后进行跳转</p></li><li><p>钉钉确认登录之后会调用后台接口 <code>call_back</code>，然后拿到用户信息</p></li><li><p>前提： 需要在后台数据库中存放租户下的钉钉配置，后续是需要使用的</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>钉钉</category>
      
      <category>单点登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
