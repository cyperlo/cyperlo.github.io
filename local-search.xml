<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring 常用扩展点</title>
    <link href="/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <url>/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-常用扩展点"><a href="#Spring-常用扩展点" class="headerlink" title="Spring 常用扩展点"></a>Spring 常用扩展点</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flag</title>
    <link href="/2025/05/09/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/flag/"/>
    <url>/2025/05/09/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/flag/</url>
    
    <content type="html"><![CDATA[<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC</title>
    <link href="/2024/12/01/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/"/>
    <url>/2024/12/01/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC-介绍"><a href="#gRPC-介绍" class="headerlink" title="gRPC 介绍"></a>gRPC 介绍</h2><p>gPRC 官网（<a href="https://grpc.io/%EF%BC%89%E4%B8%8A%E7%9A%84">https://grpc.io/）上的</a> Slogan 是：A high performance, open source universal RPC framework。就是：一个高性能、开源的通用 RPC 框架。</p><p>支持多数主流语言：C#、C++、Dart、<strong>Go</strong>、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby。其中 Go 支持 Windows, Linux, Mac 上的 Go 1.13+ 版本。</p><p>gRPC 是一个 Google 开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一步，将设备、移动应用程序和浏览器与后端服务接。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 <code>goctl</code> 可以一键安装 <code>protoc</code>，<code>protoc-gen-go</code>，<code>protoc-gen-go-grpc</code> 相关组件，你可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsh">goctl env check --install --verbose --force<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h3><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 用于序列化结构化数据的成熟开源机制（尽管它可以与 JSON 等其他数据格式一起使用）。</p><blockquote><p>Protocol Buffers 的文档：<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p></blockquote><p>使用 Protocol Buffers 的基本步骤是</p><ol><li>使用 protocol buffers 语法定义消息，消息是用于传递的数据</li><li>使用 protocol buffers 语法定义服务，服务是 RPC 方法的集合，来使用消息</li><li>使用 Protocol Buffer编 译工具 <code>protoc</code> 来编译，生成对应语言的代码，例如 Go 的代码</li></ol><p>使用 Protocol Buffers 的第一步是在 <code>.proto</code> 文件中定义序列化的数据的结构，.proto 文件是普通的文本文件。Protocol Buffers 数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的 name-value 对。</p><p>除了核心内容外，<code>.proto</code> 文件还需要指定语法版本，目前主流的也是最新的 proto3 版本。在 <code>.proto</code> 文件的开头指定。</p><p>一个简单的产品信息示例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> user; <span class="hljs-comment">// 默认包名</span><br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./user&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserReq</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserResp</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">string</span> phone = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetUser(GetUserReq) <span class="hljs-keyword">returns</span> (GetUserResp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>protoc</code> 工具将 <code>.proto</code> 定义的消息和包含 rpc 方法的服务编译为目标语言的代码，我们选择 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go-grpc_out=. --go_out=. ./user.proto<br><span class="hljs-comment"># --go_out *.pb.go 目录</span><br><span class="hljs-comment"># --go-grpc_out *_grpc.pb.go 目录</span><br></code></pre></td></tr></table></figure><h4 id="消息类型的定义"><a href="#消息类型的定义" class="headerlink" title="消息类型的定义"></a>消息类型的定义</h4><p>以一个简单的请求消息为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先指定版本 proto3，否则编译器默认为 proto2。版本指定为文件的第一非空白、非注释行。</p><p>message 关键字用于定义消息，需要指定消息类型的名称。</p><p>消息由多个名称&#x2F;值对组成，称为字段，每个字段要指定名字和类型。string、int32 是典型的标量类型，除了标量类型 protobuf 还支持构造类型，例如枚举或其他消息类型。</p><p>应该为每个字段分配唯一的字段序号，用于在二进制编码中标识该字段。序号范围1-15会消耗1个字节的存储，16-2047 会消耗2个字节。因此应该将常用的字段分配1-15字段序号。编号全部的范围是1到2^29-1，其中19000到19999是 proto编译器保留序号，不要使用。</p><p>消息的字段分为单一和重复两种规则：</p><ul><li><p>单一 Singular，proto3 中字段的默认规则。一个消息中仅可以包含0或1个该字段，就是字段不能重复。</p></li><li><p>重复的 repeated，该规则说明此字段可以重复多次（包含0次）。重复值的顺序是保留的。</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> keywords = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>.proto</code> 文件支持 C&#x2F;C++ 风格的注释 <code>//</code> 和 <code>/* ... */</code></p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量消息字段可以具有以下类型之一。该表显示了 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p><table><thead><tr><th align="left">.proto Type</th><th>说明</th><th align="left">Go Type</th></tr></thead><tbody><tr><td align="left">double</td><td></td><td align="left">float64</td></tr><tr><td align="left">float</td><td></td><td align="left">float32</td></tr><tr><td align="left">int32</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint32</td><td align="left">int32</td></tr><tr><td align="left">int64</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint64</td><td align="left">int64</td></tr><tr><td align="left">uint32</td><td>变长编码</td><td align="left">uint32</td></tr><tr><td align="left">uint64</td><td>变长编码</td><td align="left">uint64</td></tr><tr><td align="left">sint32</td><td>变长编码，带符号的 int 值。这些比常规 int32 更有效地编码负数</td><td align="left">int32</td></tr><tr><td align="left">sint64</td><td>变长编码，带符号的 int 值。这些比常规 int64 更有效地编码负数</td><td align="left">int64</td></tr><tr><td align="left">fixed32</td><td>固定4个字节，如果值通常大于 2^28，则比 uint32 更有效</td><td align="left">uint32</td></tr><tr><td align="left">fixed64</td><td>固定8个字节，如果值通常大于 2^56，则比 uint64 更有效</td><td align="left">uint64</td></tr><tr><td align="left">sfixed32</td><td>固定4个字节</td><td align="left">int32</td></tr><tr><td align="left">sfixed64</td><td>固定8个字节</td><td align="left">int64</td></tr><tr><td align="left">bool</td><td></td><td align="left">bool</td></tr><tr><td align="left">string</td><td>始终包含 UTF-8 编码或 7 位 ASCII 文本，并且长度不能超过 2^32</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td>可以包含不超过 2^32 的任意字节序列</td><td align="left">[]byte</td></tr></tbody></table><p>解析消息时，如果编码的消息不包含特定元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是基于类型的：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数字类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，必须为 0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参阅生成的代码指南。</li><li>重复字段的默认值为空（通常是相应语言的空列表）。</li></ul><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>在定义消息类型时，您可能希望其字段之一仅具有预定义的值列表之一。例如，假设您要为每个 SearchRequest 添加一个 <code>corpus</code> 字段，其中值可以是 UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS 或 VIDEO。您可以通过在消息定义中添加一个枚举来非常简单地做到这一点，每个可能的值都有一个常量。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  Corpus corpus = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值列表的第一常量值必须为0，这样可以更好的处理默认值。（也为了向下兼容）</p><p>也可以为同一个枚举值分配不同的常量，称为别名。需要使用选项 <code>option allow_alias = true</code> 来启用别名设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">MyMessage1</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">EnumAllowingAlias</span> &#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    UNKNOWN = <span class="hljs-number">0</span>;<br>    STARTED = <span class="hljs-number">1</span>;<br>    RUNNING = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h5><p>当某些字段不再使用时，例如更新消息类型时移除了某些字段，为了防止其他人重新使用了之前的字段名或字段序号而导致逻辑混乱的问题，可以把这些不用的字段设置为保留字段，关键字 <code>reserved</code> 用来设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;<br>  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，以上的序号和字段名就不能后续使用了，避免了逻辑混乱。</p><h5 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将不同类型的消息定义在不同的 .proto 文件中，需要时导入进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">import &quot;myproject/other_protos.proto&quot;;<br></code></pre></td></tr></table></figure><h5 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h5><p>未知字段是格式良好的 Protocol Buffer 序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p><p>最初，proto3 消息在解析过程中总是丢弃未知字段，但在 3.5 版本中，我们重新引入了保留未知字段以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析期间保留并包含在序列化输出中。</p><h5 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h5><p>Any 消息类型允许您将消息用作嵌入类型，而无需定义它们的 .proto。 Any 包含作为 <code>Bytes</code> 的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要导入 google&#x2F;protobuf&#x2F;any.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ErrorStatus</span> &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">repeated</span> google.protobuf.Any details = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Onef"><a href="#Onef" class="headerlink" title="Onef"></a>Onef</h5><p>如果您有一条包含多个字段的消息，并且最多同时设置一个字段，您可以强制执行此行为并使用 <code>oneof</code> 功能节省内存。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SampleMessage</span> &#123;<br>  <span class="hljs-keyword">oneof</span> test_oneof &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">4</span>;<br>    SubMessage sub_message = <span class="hljs-number">9</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>如果您想创建关联映射作为数据定义的一部分，protocol buffers 提供了一种方便的快捷语法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;<span class="hljs-type">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="语法指导"><a href="#语法指导" class="headerlink" title="语法指导"></a>语法指导</h4><h5 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h5><p>您可以将可选的 <code>package</code> 说明符添加到 .proto 文件中，以防止协议消息类型之间的名称冲突。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> foo.bar;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Open</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>在 GO 中，该软件包被用作 GO 软件包名称，除非您在 .proto 文件中明确提供 <code>option go_package</code>。</p><h5 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h5><p>如果您想在 RPC（远程过程调用）系统中使用您的消息类型，您可以在 .proto 文件中定义一个 RPC 服务接口，并且协议缓冲区编译器将以您选择的语言生成服务接口代码和存根。因此，例如，如果您想使用获取 SearchRequest 并返回 SearchResponse 的方法定义 RPC 服务，您可以在 .proto 文件中定义它，如下所示：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 Proto Buffers 一起使用的最直接的 RPC 系统是 gRPC：由 Google 开发的一种语言和平台中立的开源 RPC 系统。 gRPC 特别适用于协议缓冲区，并允许您使用特殊的协议缓冲区编译器插件直接从 .proto 文件生成相关的 RPC 代码。</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>.proto 文件中支持定义选项。全部的选项定义在 <code>google/protobuf/descriptor.proto</code> 中。</p><p>例如我们使用 option go_package 选项来控制生成的 go 代码所在的 package。</p><h3 id="gRPC-支持四种定义服务的方法"><a href="#gRPC-支持四种定义服务的方法" class="headerlink" title="gRPC 支持四种定义服务的方法"></a>gRPC 支持四种定义服务的方法</h3><h4 id="一元-RPC"><a href="#一元-RPC" class="headerlink" title="一元 RPC"></a>一元 RPC</h4><p>首先考虑最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。</p><ol><li>一旦客户端调用了一个存根方法，服务器就会被通知该 RPC 已被调用，其中包含该调用的客户端元数据、方法名称和指定的截止日期（如果适用）。</li><li>然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。</li><li>一旦服务器收到客户端的请求消息，它就会执行任何必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选状态消息）和可选尾随元数据一起返回（如果成功）给客户端。</li><li>如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。</li></ol><blockquote><p>一元  RPC，其中客户端向服务器发送单个请求并获得单个响应，就像正常的函数调用一样</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="服务器流式-RPC"><a href="#服务器流式-RPC" class="headerlink" title="服务器流式 RPC"></a>服务器流式 RPC</h4><p>服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有所有服务器消息后完成。</p><blockquote><p>服务器流式 RPC，其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 gRPC 保证单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器响应一条消息（连同其状态详细信息和可选的尾随元数据），通常但不一定是在它收到所有客户端的消息之后</p><blockquote><p>客户端流式 RPC，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成了消息的写入，它就会等待服务器读取它们并返回它的响应。 gRPC 再次保证了单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>在双向流式 RPC 中，调用由调用方法的客户端和接收客户端元数据、方法名称和截止日期的服务器发起。服务器可以选择发回其初始元数据或等待客户端开始流式传输消息。</p><p>客户端和服务器端流处理是特定于应用程序的。<strong>由于这两个流是独立的，客户端和服务器可以以任意顺序读写消息</strong>。例如，服务器可以等到它收到客户端的所有消息后再写入它的消息，或者服务器和客户端可以玩 “ping-pong”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。</p><blockquote><p>双向流式 RPC，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> BidiHello(stream HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期指的是 gRPC 客户端调用 gRPC 服务端方法的过程。区别于不同的4种服务定义，过程如下：</p><h4 id="截止日期-超时"><a href="#截止日期-超时" class="headerlink" title="截止日期&#x2F;超时"></a>截止日期&#x2F;超时</h4><p>gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误而终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询特定的 RPC 是否已超时，或者还剩多少时间来完成 RPC。指定期限或超时是特定于语言的：一些语言 API 根据超时（持续时间）工作，而一些语言 API 根据期限（固定时间点）工作，可能有也可能没有默认期限。</p><h4 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h4><p>在 gRPC 中，客户端和服务器都对调用是否成功做出独立的本地判断，并且它们的结论可能不匹配。这意味着，例如，您可能有一个 RPC 在服务器端成功完成（“我已经发送了所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务器也可以在客户端发送所有请求之前决定完成。</p><h4 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h4><p>客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，以便不再进行任何工作。</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><blockquote><p> http2 是 gRPC 中的关键协议</p></blockquote><h3 id="HTTP1-存在的问题"><a href="#HTTP1-存在的问题" class="headerlink" title="HTTP1 存在的问题"></a>HTTP1 存在的问题</h3><ul><li>低效的 TCP 利用<ul><li>连接是一次性的，不能重复使用</li></ul></li><li>臃肿的消息首部<ul><li>请求行（url、请求头、版本）</li><li>首部行</li><li>空行</li><li>实体主体</li></ul></li><li>明文传输<ul><li>可以通过加 SSL 证书，将请求转成 HTTPS</li></ul></li><li>传输效率低</li></ul><h3 id="HTP2-改进的地方"><a href="#HTP2-改进的地方" class="headerlink" title="HTP2 改进的地方"></a>HTP2 改进的地方</h3><ul><li><p>传输的改进</p><ul><li>HTTP1 中一次处理一个请求，并且不能停止解析</li><li>HTTP1 中对于服务端来说无法预判使用多少内存</li><li>HTTP1 冗余过多的 LF 分隔符</li><li>HTTP2 中tcp连接之后不会断掉<ul><li>会将一次请求分成一定数量的帧，给关键帧打上标识，然后客户端会根据这些标识组装数据</li></ul></li></ul></li><li><p>请求头优化</p><ul><li><p>HTTP1 是属于无状态的，每次都需要将所有请求头发送到服务方（ http2 在将请求头帧发送到服务后，后续的帧只会发送不同的东西）</p><p><img src="https://i.imgur.com/qqbaMCU.png" alt="image-20241031212104738"></p></li><li><p>多路复用</p><ul><li>HTTP1 连接是一次性的，打开一个网页会发起多次请求，每个请求完之后就会关闭</li><li>HTTP2 在请求过程中只会建立一次连接，后续的请求都可以通过这个连接进行发送</li></ul></li><li><p>服务端可推送</p><ul><li><p>HTTP1 不支持</p></li><li><p>HTTP2 服务端与客户端会保持长连接</p></li></ul></li></ul></li></ul><h2 id="gRPC-实战"><a href="#gRPC-实战" class="headerlink" title="gRPC 实战"></a>gRPC 实战</h2><h3 id="gRPC-的服务端连接调度实现原理分析"><a href="#gRPC-的服务端连接调度实现原理分析" class="headerlink" title="gRPC 的服务端连接调度实现原理分析"></a>gRPC 的服务端连接调度实现原理分析</h3><h4 id="自定义服务加载"><a href="#自定义服务加载" class="headerlink" title="自定义服务加载"></a>自定义服务加载</h4><p><img src="https://i.imgur.com/DW8LO8s.png" alt="image-20241031212647536"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User_ServiceDesc is the grpc.ServiceDesc for User service.</span><br><span class="hljs-comment">// It&#x27;s only intended for direct use with grpc.RegisterService,</span><br><span class="hljs-comment">// and not to be introspected or modified (even as a copy)</span><br><span class="hljs-keyword">var</span> User_ServiceDesc = grpc.ServiceDesc&#123;<br>    ServiceName: <span class="hljs-string">&quot;user.User&quot;</span>,<br>    HandlerType: (*UserServer)(<span class="hljs-literal">nil</span>),<br>    Methods: []grpc.MethodDesc&#123;<br>       &#123;<br>          MethodName: <span class="hljs-string">&quot;GetUser&quot;</span>,<br>          Handler:    _User_GetUser_Handler,<br>       &#125;,<br>    &#125;,<br>    Streams:  []grpc.StreamDesc&#123;&#125;,<br>    Metadata: <span class="hljs-string">&quot;user.proto&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">User_GetUser_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    in := <span class="hljs-built_in">new</span>(GetUserReq)<br>    <span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, in)<br>    &#125;<br>    info := &amp;grpc.UnaryServerInfo&#123;<br>       Server:     srv,<br>       FullMethod: User_GetUser_FullMethodName,<br>    &#125;<br>    handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, req.(*GetUserReq))<br>    &#125;<br>    <span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br><br><span class="hljs-comment">// RegisterService registers a service and its implementation to the gRPC</span><br><span class="hljs-comment">// server. It is called from the IDL generated code. This must be called before</span><br><span class="hljs-comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span><br><span class="hljs-comment">// ensure it implements sd.HandlerType.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> RegisterService(sd *ServiceDesc, ss any) &#123;<br>    <span class="hljs-keyword">if</span> ss != <span class="hljs-literal">nil</span> &#123;<br>       ht := reflect.TypeOf(sd.HandlerType).Elem()<br>       st := reflect.TypeOf(ss)<br>       <span class="hljs-keyword">if</span> !st.Implements(ht) &#123;<br>          logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)<br>       &#125;<br>    &#125;<br>    s.register(sd, ss)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> register(sd *ServiceDesc, ss any) &#123;<br>    s.mu.Lock()<br>    <span class="hljs-keyword">defer</span> s.mu.Unlock()<br>    s.printf(<span class="hljs-string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)<br>    <span class="hljs-keyword">if</span> s.serve &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    <span class="hljs-keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    info := &amp;serviceInfo&#123;<br>       serviceImpl: ss,<br>       methods:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*MethodDesc),<br>       streams:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*StreamDesc),<br>       mdata:       sd.Metadata,<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Methods &#123;<br>       d := &amp;sd.Methods[i]<br>       info.methods[d.MethodName] = d<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Streams &#123;<br>       d := &amp;sd.Streams[i]<br>       info.streams[d.StreamName] = d<br>    &#125;<br>    s.services[sd.ServiceName] = info<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a>服务初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">s := grpc.NewServer()<br><br><br><br><span class="hljs-comment">// NewServer creates a gRPC server which has no service registered and has not</span><br><span class="hljs-comment">// started to accept requests yet.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opt ...ServerOption)</span></span> *Server &#123;<br>    opts := defaultServerOptions<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> globalServerOptions &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opt &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    s := &amp;Server&#123;<br>       lis:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[net.Listener]<span class="hljs-type">bool</span>),<br>       opts:     opts,<br>       conns:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[transport.ServerTransport]<span class="hljs-type">bool</span>),<br>       services: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*serviceInfo),<br>       quit:     grpcsync.NewEvent(),<br>       done:     grpcsync.NewEvent(),<br>       channelz: channelz.RegisterServer(<span class="hljs-string">&quot;&quot;</span>),<br>    &#125;<br>    chainUnaryServerInterceptors(s)<br>    chainStreamServerInterceptors(s)<br>    s.cv = sync.NewCond(&amp;s.mu)<br>    <span class="hljs-keyword">if</span> EnableTracing &#123;<br>       _, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>       s.events = newTraceEventLog(<span class="hljs-string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line))<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> s.opts.numServerWorkers &gt; <span class="hljs-number">0</span> &#123;<br>       s.initServerWorkers()<br>    &#125;<br><br>    channelz.Info(logger, s.channelz, <span class="hljs-string">&quot;Server created&quot;</span>)<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrInterceptor</span><span class="hljs-params">(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp any, err <span class="hljs-type">error</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;err begin&quot;</span>)<br>    resp, err = handler(ctx, req)<br>    fmt.Println(<span class="hljs-string">&quot;err end&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br><br>    s := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor.LogInterceptor, interceptor.ErrInterceptor))<br>    user.RegisterUserServer(s, <span class="hljs-built_in">new</span>(UserService))<br>    log.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请求监听处理"><a href="#请求监听处理" class="headerlink" title="请求监听处理"></a>请求监听处理</h4><p><img src="https://i.imgur.com/ImC3Tbc.png" alt="image-20241031212849420"></p><h3 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h3><blockquote><p>对 go-zero的安装不做赘述</p></blockquote><h4 id="实践-go-zero-基础功能案例（api-rpc）"><a href="#实践-go-zero-基础功能案例（api-rpc）" class="headerlink" title="实践 go-zero 基础功能案例（api&#x2F;rpc）"></a>实践 go-zero 基础功能案例（api&#x2F;rpc）</h4><ol><li><p>编写.proto文件</p></li><li><p>构建 rpc 服务</p></li><li><p>编写 api 文件</p><ol><li><p>构建 api 服务</p><ol><li><p>构建 rpc 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl rpc new user<br></code></pre></td></tr></table></figure></li><li><p>构建 api 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl api new api<br></code></pre></td></tr></table></figure></li><li><p>一般情况是编写 <code>.api</code> 文件和编写 <code>.proto</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">      goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.<br>      goctl api go -api user.api -<span class="hljs-built_in">dir</span> . -style gozero<br><br>2. 服务联调<br><br>   ```yaml<br>   <span class="hljs-comment"># api etc user.yaml</span><br>   Name: User<br>   Host: 0.0.0.0<br>   Port: 8888<br>   <br>   UserRpc:<br>     Etcd:<br>       Hosts:<br>         - 117.50.179.8:2379<br>       Key: user.rpc<br>       User: <span class="hljs-string">&quot;root&quot;</span><br>       Pass: <span class="hljs-string">&quot;fghf987....&quot;</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// internal config config.go</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>rest.RestConf<br><br>UserRpc zrpc.RpcClientConf<br>&#125;<br><br><br><span class="hljs-comment">// svc servicecontext.go</span><br><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>Config     config.Config<br>UserClient userclient.User<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceContext</span><span class="hljs-params">(c config.Config)</span></span> *ServiceContext &#123;<br><span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>Config:     c,<br>UserClient: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// logic userlogic.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *UserLogic)</span></span> User(req *types.UserReq) (resp *types.UserResp, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// todo: add your logic here and delete this line</span><br>getUserResp, err := l.svcCtx.UserClient.GetUser(l.ctx, &amp;user.GetUserReq&#123;<br>Id: req.Id,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;types.UserResp&#123;<br>Id:    getUserResp.Id,<br>Name:  getUserResp.Name,<br>Phone: getUserResp.Phone,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><ol><li><p>编写 <em>.sql</em> 文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `<span class="hljs-keyword">user</span>` (<br>                        `id` <span class="hljs-type">BIGINT</span> UNSIGNED AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用户ID，主键&#x27;</span>,<br>                        `username` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>                        `email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;电子邮箱&#x27;</span>,<br>                        `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;密码（加密存储）&#x27;</span>,<br>                        `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>                        `status` TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态：1=启用，0=禁用&#x27;</span>,<br>                        `created_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>                        `updated_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>                        <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>生成 model</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl model mysql ddl --src user.sql --<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;./models/&quot;</span> -c<br></code></pre></td></tr></table></figure><p><code>-c</code>表示使用缓存</p></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><p>core</p><p>工具集包含数据处理、熔断器、服务发现等工具</p></li><li><p>internal</p><p>包含框架处理、请求编码、健康检测等功能</p></li><li><p>zrpc</p><p>是rpc服务端与客户端的核心代码</p></li></ul><h5 id="go-zero-如何适配grpc"><a href="#go-zero-如何适配grpc" class="headerlink" title="go-zero 如何适配grpc"></a>go-zero 如何适配grpc</h5><h5 id="服务如何初始化"><a href="#服务如何初始化" class="headerlink" title="服务如何初始化"></a>服务如何初始化</h5><h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2024/10/31/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/"/>
    <url>/2024/10/31/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="golang中的-RPC"><a href="#golang中的-RPC" class="headerlink" title="golang中的 RPC"></a>golang中的 RPC</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id,omitempty&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name,omitempty&quot;`</span><br>    Phone <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;phone&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> users = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*User&#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;1&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xx&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;2&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;2&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-keyword">type</span> UserServer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserServer)</span></span> GetUser(req GetUserReq, resp *GetUserResp) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> u, ok := users[req.Id]; ok &#123;<br>        *resp = GetUserResp&#123;<br>            Id:    u.Id,<br>            Name:  u.Name,<br>            Phone: u.Phone,<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;未找到用户&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    userServer := <span class="hljs-built_in">new</span>(UserServer)<br>    rpc.Register(userServer)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;监听客户端连接失败&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> rpc.ServeConn(conn)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> client.Close()<br>    <span class="hljs-keyword">var</span> (<br>        req = GetUserReq&#123;<br>            Id: <span class="hljs-string">&quot;3&quot;</span>,<br>        &#125;<br>        res GetUserResp<br>    )<br>    err = client.Call(<span class="hljs-string">&quot;UserServer.GetUser&quot;</span>, req, &amp;res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;请求异常&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    log.Println(res)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="怎么分析这一块的源码？"><a href="#怎么分析这一块的源码？" class="headerlink" title="怎么分析这一块的源码？"></a>怎么分析这一块的源码？</h3><blockquote><p>源码分析三步</p></blockquote><ol><li><p>目的</p><ol><li>客户端为啥能直接调用服务端的方法</li><li>客户端与服务端的交互的数据格式确定</li></ol></li><li><p>构思实现：</p><ol><li><p>Rpc 之间通讯的数据格式与传输参数</p></li><li><p>Rpc 之间的的通讯数据格式与传输参数</p><p>标准库是通过 json 实现的，需要考虑其他类型转换情况</p></li><li><p>接受到请求消息之后是如何运行对应服务的</p><p>​    <img src="https://i.imgur.com/PTGAkaq.png" alt="image-20241031203029336"></p></li></ol></li><li><p>直接阅读源码</p></li></ol><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p><img src="https://i.imgur.com/cE6mxPs.png" alt="image-20241031203127867"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构</title>
    <link href="/2024/07/12/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/07/12/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="微服务架构整体感受"><a href="#微服务架构整体感受" class="headerlink" title="微服务架构整体感受"></a>微服务架构整体感受</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>什么是微服务架构？</li><li>服务应该如何拆分？</li><li>微服务架构带来了哪些问题？以及如何去解决这些问题。</li></ol><h3 id="典型架构图"><a href="#典型架构图" class="headerlink" title="典型架构图"></a>典型架构图</h3><p><img src="https://i.imgur.com/JXw7vLg.png" alt="image-20240710222819833"></p><p>微服务架构知识内容：</p><ol><li>应用由多个服务构成。</li><li>服务独享自身数据。</li><li>服务会共享配置，使用配置中心来支持。</li><li>服务还会共享中间件，主要缓存、消息队列、搜索、日志等。</li><li>服务间需要通信，第一步需要找到目标服务。需要服务注册中心，提供服务注册和发现。</li><li>服务需要通信，规范通信协议，典型的协议：gRPC，RestFul API，HTTP、MQ。</li><li>应用要响应外部的请求，并将请求转发给目标服务。需要 API 网关技术。</li><li>服务请求需要被控制的管理，使用负载均衡、限流、熔断、降级等控制。</li><li>服务间数据一致性的问题，通常需要分布式事务、分布式锁、分布式 Session。</li><li>服务需要被监控、需要链路追踪、监控平台、日志分析。</li></ol><h3 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h3><ol><li>Go 核心语法，我们需要用 go 编写测试用例。</li><li>Linux 基础操作，需要的程序软件大都安装在 linux 上。</li><li>Web 相关编程技术，需要使用 http 请求响应相关操作。</li></ol><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><h3 id="巨石架构"><a href="#巨石架构" class="headerlink" title="巨石架构"></a>巨石架构</h3><p>早期，大部分的应用程序是将全部的功能模块作为一个整体进行打包、发布、运行。这样程序会越来越大，像一块大石头一样，因此称为巨石架构（the monolithic architecture）。例如，一个商城系统可能包含：分类、商品、购物车、订单、支付、物流、评价、售后、会员、推广、商户等功能模块。那么程序的架构就是：</p><p><img src="https://i.imgur.com/6GYGacV.png" alt="image-20240710223242786"></p><p>巨石应用的劣势：</p><ul><li>更新局部，需要重新部署整体</li><li>整体发布时间过长，包括编译、发布等</li><li>回归测试周期过长</li><li>不利于新技术应用，否则需要重构整体应用</li></ul><p>巨石应用也有自己的优势，例如部署容易，整体打包，整体部署即可；IDE 友好，测试容易、监控方便。</p><h3 id="微服务架构-1"><a href="#微服务架构-1" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MicroServices Architecture Pattern）的目的是将大型的、复杂的、长期运行的应用程序（巨石应用）构建为一组相互配合的服务，每个服务都可以很容易得局部改良。<strong>Micro</strong> 意味着服务应该足够小，服务的大小应该从业务逻辑上衡量，而不是用代码量。符合 SRP （单一职责原则）的才叫微服务。</p><p>微服务是去中心化的分布式软件架构。微服务通常是无状态服务。</p><p>微服务架构的优势：</p><ul><li>服务可以使用不同技术栈研发</li><li>每个微服务都可以独立优化，部署或扩展</li><li>更好的故障处理和错误检测</li><li>服务复用性强</li><li>服务扩展性强</li></ul><p>单体应用拆解成大量的微服务，带来的新问题是服务间通信和一致性等问题，通常需要通过服务注册发现、服务网格、分布式锁、分布式事务来解决。</p><p>上面的应用，拆分之后：</p><p><img src="https://i.imgur.com/84ZJjjR.png" alt="image-20240710223419599"></p><h3 id="SOA-与服务"><a href="#SOA-与服务" class="headerlink" title="SOA 与服务"></a>SOA 与服务</h3><p>SOA（Service-Oriented Architecture，面向服务的架构）是一种在计算机环境中设计、开发、部署和管理离散模型的方法。在 SOA 模型中，所有的功能都被定义成了独立的服务，所有的服务通过企业服务总线(ESB, Enterprise Service Bus)或流程管理器来连接。</p><p>带有 ESB 的架构典型如下：</p><p><img src="https://i.imgur.com/8K6F5ei.png" alt="image-20240710223558517"></p><p>微服务架构与 SOA 架构最重要的区别是：</p><ul><li>微服务架构是去中心化的分布式架构</li><li>SOA 是中心化的分布式架构。</li></ul><h3 id="云原生中的微服务"><a href="#云原生中的微服务" class="headerlink" title="云原生中的微服务"></a>云原生中的微服务</h3><p>微服务是云原生技术的核心部分，在微服务架构上运行的现代云原生应用程序依赖于以下关键组件：</p><ul><li>容器化，通过将服务分成多个进程来进行有效的管理和部署，例如 Docker 类平台。</li><li>编排，用于配置、分配和管理服务的可用系统资源，例如 Kubernetes 类平台。</li><li>服务网格，通过服务代理网格进行服务间通信，连接，管理和保护微服务，例如 Istio 类平台。</li></ul><p>以上三个是微服务架构在云原生中最重要的组件，这些组件允许云原生中的应用程序在负载下扩展，甚至在故障期间也能执行。</p><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>微服务是化整为零、分而治之的思想。</p><p>拆分原则一览：</p><p><strong>业务拆分：</strong></p><p>业务逻辑拆分，单一职责，服务自身可治理数据库。</p><p>独立功能用例拆分，独立的二方或三方用例，通常拆分为独立服务。例如二方的账号服务和三方的支付服务。</p><p><strong>技术拆分：</strong></p><p>服务的并发性，考虑持续并发、瞬时并发，拆分服务独立。</p><p>服务处理的数据，考虑数据量、读写操作的数据、冷热数据量、边长定长数据类型，将服务拆分。</p><p>服务的安全等级，考虑服务业务、数据的安全等级、采用不同的安全策略，来进行拆分。</p><p>服务需要的资源，考虑服务需要计算、I&#x2F;O、网络、存储等资源、来进行拆分。</p><p>服务扩展性，考虑服务中技术、业务等的更新率、扩展率，进行拆分。</p><p>架构的稳定性，考虑单体服务的技术架构稳定性。</p><p>便于测试，测试可集成、可回溯。</p><p>便于监控，便于日志分析、指标监控等。</p><p><strong>项目拆分：</strong></p><p>团队（开发、测试、运维）小而美。小指的是规模，团队通常 10 人左右；美指的是团队可自治，与其他团队人员协调尽量少。</p><p>成本因素，考虑技术（学习）成本、人力成本、时间成本、设施成本，来拆分服务。</p><h3 id="AKF-扩展立方体"><a href="#AKF-扩展立方体" class="headerlink" title="AKF 扩展立方体"></a>AKF 扩展立方体</h3><p>立方体图：</p><p><img src="https://i.imgur.com/VWvqOOl.png" alt="image-20240711113639989"></p><h4 id="X-轴，克隆扩展（水平复制）"><a href="#X-轴，克隆扩展（水平复制）" class="headerlink" title="X 轴，克隆扩展（水平复制）"></a>X 轴，克隆扩展（水平复制）</h4><p>X轴，代表无差别服务和数据的克隆，也称水平扩展。它指的是，相同的服务部署多个，通过负载均衡器在多个应用间做选择。</p><p>图例：</p><p><img src="https://i.imgur.com/98Xf4y3.png" alt="image-20240711113729258"></p><h4 id="Y-轴，功能拆分扩展"><a href="#Y-轴，功能拆分扩展" class="headerlink" title="Y 轴，功能拆分扩展"></a>Y 轴，功能拆分扩展</h4><p>Y轴，代表依据资源、服务或功能进行拆分。指的是把任何特定功能的操作以及操作所需的数据资源从整体（或其他操作）中分离出来。X 轴体现的是相同功能的复制，而 Y 轴体现的是多个不同功能的组合。</p><p>如图：用户购买商品，需要浏览商品信息、购买、订单管理、支付等操作，依据功能将应用拆分为：</p><p><img src="https://i.imgur.com/lyE8H0n.png" alt="image-20240711113804383"></p><p>这种拆分，就是典型微服务架构中业务逻辑的拆分方案，每个服务负责具体的某个特定功能，整体应用由多个服务组成。</p><p>同样，若某个服务需要更多的资源，也可以采用 X 轴扩展模式，例如上图中的订单服务。</p><h4 id="Z-轴，数据拆分扩展"><a href="#Z-轴，数据拆分扩展" class="headerlink" title="Z 轴，数据拆分扩展"></a>Z 轴，数据拆分扩展</h4><p>当业务基于 X、Y 做了克隆或拆分后，数据存储的压力需要通过 Z 轴扩展解决。Z 轴扩展通常指的是数据库拆分。数据库拆分如依据地域划分、依据不同功能的表划分或将表中的记录依据主键hash（或其他分区算法）划分等。</p><p>地域：</p><p><img src="https://i.imgur.com/njoLZmv.png" alt="image-20240711113907153"></p><p>基于功能：</p><p><img src="https://i.imgur.com/7XsuXnX.png" alt="image-20240711113957121"></p><p>记录划分：</p><p><img src="https://i.imgur.com/j1C2q2p.png" alt="image-20240711114009105"></p><h4 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h4><p>坐标原点 (0, 0, 0) 表示应用系统的最小扩展性。</p><h3 id="SRP-单一职责原则"><a href="#SRP-单一职责原则" class="headerlink" title="SRP 单一职责原则"></a>SRP 单一职责原则</h3><p>单一职责原则，应该表达最朴素的一个原则了，顾名思义，就是一个服务负责单独的一个职责，就意味着我们的设计满足单一职责。</p><p>SRP，Single Responsibility Principle，单一职责原则来自于面向对象设计的基本原则，是这么说的：</p><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>映射到我们微服务其实就是：对于服务而言，应该只有一个理由引起它的变化。</p><p>也就是，一个服务的功能要单一，只做与之相关的事情，在服务的设计过程中要按照职责进行设计。如果需要更多功能呢，那么就需要更多的服务，服务彼此互不干涉。</p><p>单一职责原则在使用时，要注意粒度，也就是我们应该将单体服务的规模设计多大。如果粒度过细，会导致在开发、测试、部署上都会带来额外的负担。同样若粒度过粗，那么特定功能的更新，直接会导致整体服务更新。因此，我们在拆分服务时，除了要考虑功能性，还要考虑和预测需求的变化点、变化率，以及数据增长点、并发热点等，相互结合，设计出相对平衡的独立服务。</p><p>例如，对于商品服务，商品的品牌、标签、属性、库存等，是否需要独立设计为一个服务呢？这个需要基于我们自身的业务逻辑进行设计。这个例子中，库存通常需要独立服务设计的，因为库存在订单生成和仓库管理时，会被高频率使用。而其他功能，通常隶属于商品服务的范畴。</p><p>SRP 原则通常也会被表述为服务设计的高内聚低耦合。内聚度是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好只做一件事，高内聚就是一个类封装的很完善，每个类只完成一项任务，也就是常说的单一责任原则。   耦合度是对模块间关联程度的度量，模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系，模块间联系越多，耦合性越强，模块的独立性越差。</p><h3 id="DDD-领域设计"><a href="#DDD-领域设计" class="headerlink" title="DDD 领域设计"></a>DDD 领域设计</h3><h2 id="微服务架构需要解决的问题"><a href="#微服务架构需要解决的问题" class="headerlink" title="微服务架构需要解决的问题"></a>微服务架构需要解决的问题</h2><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h3 id="服务间发现"><a href="#服务间发现" class="headerlink" title="服务间发现"></a>服务间发现</h3><h3 id="服务间通讯"><a href="#服务间通讯" class="headerlink" title="服务间通讯"></a>服务间通讯</h3><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="熔断和降级"><a href="#熔断和降级" class="headerlink" title="熔断和降级"></a>熔断和降级</h3>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务概览</title>
    <link href="/2024/05/11/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/"/>
    <url>/2024/05/11/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务-一-微服务概览"><a href="#微服务-一-微服务概览" class="headerlink" title="微服务(一) 微服务概览"></a>微服务(一) 微服务概览</h1><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h3 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1:为什么会有微服务？"></a>Q1:为什么会有微服务？</h3><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h3 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2:微服务是什么？"></a>Q2:微服务是什么？</h3><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li>**单一职责，**一个服务只做一件事情</li><li>**尽可能的早的创建原型，**先定义 API，达成契约</li><li>**可移植性比效率更重要，**通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术</strong></li></ul></li></ul><h3 id="Q3-微服务可以带来哪些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来哪些好处，又有哪些缺点？" class="headerlink" title="Q3:微服务可以带来哪些好处，又有哪些缺点？"></a>Q3:微服务可以带来哪些好处，又有哪些缺点？</h3><ul><li><p>优点</p><ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li>**原子服务，**一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li>**独立进程，**一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li>**隔离部署，**每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li>去中心化服务治理<ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>服务之间的依赖关系复杂成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。</p><ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li><p>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</p><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><p>会有分布式事务问题，</p><p>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦</p><ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><p>测试会非常复杂，</p><p>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题</p><ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li><p>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。</p><ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><p>对基础建设的要求很高，</p><p>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等</p><ul><li>常见解决方案：上云</li></ul></li></ul><h3 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: <strong>微服务如何构建？</strong></h3><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h3 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5:微服务如何对外暴露？"></a>Q5:<strong>微服务如何对外暴露？</strong></h3><p><img src="https://i.imgur.com/qejM7Jh.png" alt="1718629799961"></p></li></ul><h4 id="流量链路是什么？"><a href="#流量链路是什么？" class="headerlink" title="流量链路是什么？"></a>流量链路是什么？</h4><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><h4 id="为什么我们的服务不直接对外进行暴露？"><a href="#为什么我们的服务不直接对外进行暴露？" class="headerlink" title="为什么我们的服务不直接对外进行暴露？"></a>为什么我们的服务不直接对外进行暴露？</h4><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><h4 id="为什么需要最外层的-api-gateway"><a href="#为什么需要最外层的-api-gateway" class="headerlink" title="为什么需要最外层的 api gateway?"></a>为什么需要最外层的 api gateway?</h4><ul><li>基础库的同学非常痛苦，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h3 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: <strong>微服务如何拆分？</strong></h3><ul><li><p>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong></p><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li><p>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</p></li><li><p>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</p></li><li><p>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</p></li><li><p>还可以根据读写进行划分</p><ul><li><p>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</p><p><img src="https://i.imgur.com/k83Ex8Q.png" alt="1718630014302"></p></li></ul></li></ul><h3 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7:如何保证微服务之间的安全？"></a>Q7:<strong>如何保证微服务之间的安全？</strong></h3><p><img src="https://i.imgur.com/aUAJjYf.png" alt="1718630058407"></p><p>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
