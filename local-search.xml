<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rag</title>
    <link href="/2025/10/23/python/rag/"/>
    <url>/2025/10/23/python/rag/</url>
    
    <content type="html"><![CDATA[<h1 id="基于-Ollama-实现-Rag-系统"><a href="#基于-Ollama-实现-Rag-系统" class="headerlink" title="基于 Ollama 实现 Rag 系统"></a>基于 Ollama 实现 Rag 系统</h1><h2 id="安装-ollama-及相关模型"><a href="#安装-ollama-及相关模型" class="headerlink" title="安装 ollama 及相关模型"></a>安装 ollama 及相关模型</h2><p>安装部分可查询官方文档<a href="https://docs.ollama.com/">https://docs.ollama.com/</a>, ollama相当于是一个能够快速在本地部署大模型的工具</p><h3 id="下载模型："><a href="#下载模型：" class="headerlink" title="下载模型："></a>下载模型：</h3><p>在命令行执行如下两个命令来下载模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ollama pull nomic-embed-text:latest<br>ollama pull qwen:4b<br></code></pre></td></tr></table></figure><ul><li><code>nomic-embed-text:latest</code>是一个文本转向量的模型：<a href="https://link.zhihu.com/?target=https://ollama.com/library/nomic-embed-text">https://ollama.com/library/nomic-embed-text</a></li><li><code>qwen:4b</code>就是阿里开源的千问大模型：<a href="https://link.zhihu.com/?target=https://ollama.com/library/qwen">https://ollama.com/library/qwen</a></li></ul><h3 id="启动-ollama-服务"><a href="#启动-ollama-服务" class="headerlink" title="启动 ollama 服务"></a>启动 ollama 服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ollama serve<br></code></pre></td></tr></table></figure><p>执行如上命令会在本机的11434端口启动ollama的http服务：</p><p>可以直接通过http请求也就是REST API来集成ollama提供的服务: <a href="https://link.zhihu.com/?target=https://github.com/ollama/ollama/blob/main/docs/api.md">https://github.com/ollama/ollama/blob/main/docs/api.md</a></p><p>也可以通过ollama的python API来继承ollama的服务：<a href="https://link.zhihu.com/?target=https://github.com/ollama/ollama-python">https://github.com/ollama/ollama-python</a></p><p>本文的ollama-rag项目采用的是后一种方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>使用版本是 <code>Python3.8</code>，需要事先安装依赖</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">ollama<br>faiss-cpu==1.8.0<br>tqdm<br></code></pre></td></tr></table></figure><p>本文使用的测试文档为<code>预警模型.txt</code>，文档内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">复制状态异常: 严重级别为 serious，可通过 pg_state_get_stream_replications 查看实例复制状态细节 detail_information<br></code></pre></td></tr></table></figure><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> faiss<br><span class="hljs-keyword">import</span> ollama<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">return</span> ollama.embeddings(model=<span class="hljs-string">&#x27;nomic-embed-text&#x27;</span>, prompt=text)[<span class="hljs-string">&#x27;embedding&#x27;</span>]<br><br><br><span class="hljs-comment"># 读取文档并分段</span><br>chunks = []<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;告警规则.txt&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>    line = line.strip()<br>    <span class="hljs-keyword">if</span> line:<br>        chunks.append(line.strip())<br>file.close()<br><br><span class="hljs-comment"># 计算每个分段的embedding</span><br>chunk_embeddings = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(chunks)), desc=<span class="hljs-string">&#x27;计算chunks的embedding&#x27;</span>):<br>    chunk_embeddings.append(encode(chunks[i]))<br>chunk_embeddings = np.array(chunk_embeddings)<br>chunk_embeddings = chunk_embeddings.astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br><br><span class="hljs-comment"># 建立faiss索引</span><br>faiss.normalize_L2(chunk_embeddings)<br>faiss_index = faiss.index_factory(chunk_embeddings.shape[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Flat&quot;</span>, faiss.METRIC_INNER_PRODUCT)<br>faiss_index.add(chunk_embeddings)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 提示用户输入</span><br>    question = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个问题: &quot;</span>)<br>    <span class="hljs-built_in">print</span>(question)<br><br>    <span class="hljs-comment"># 将问题编码</span><br>    question_embedding = encode(question)<br><br>    <span class="hljs-comment"># 检索到最相关的top1分段</span><br>    question_embedding = np.array([question_embedding])<br>    question_embedding = question_embedding.astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    faiss.normalize_L2(question_embedding)<br>    _, index_matrix = faiss_index.search(question_embedding, k=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 构造prompt</span><br>    prompt = <span class="hljs-string">f&#x27;根据参考文档回答问题，回答尽量简洁，不超过200个字\n&#x27;</span> \<br>             <span class="hljs-string">f&#x27;问题是：&quot;<span class="hljs-subst">&#123;question&#125;</span>&quot;\n&#x27;</span> \<br>             <span class="hljs-string">f&#x27;参考文档是：&quot;<span class="hljs-subst">&#123;chunks[index_matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]&#125;</span>&quot;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;prompt:\n<span class="hljs-subst">&#123;prompt&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-comment"># 获取答案</span><br>    stream = ollama.chat(model=<span class="hljs-string">&#x27;qwen:4b&#x27;</span>, messages=[&#123;<span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: prompt&#125;], stream=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;answer:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:<br>        <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>], end=<span class="hljs-string">&#x27;&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前代码暂时只实现了读取本地文件，实际开发中，会使用到向量数据库，因为此处文本数量比较小，如果文本数量比较多、比较大的化，会导致程序启动比较缓慢</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>rag</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rag</tag>
      
      <tag>ollma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2025/10/22/python/python/"/>
    <url>/2025/10/22/python/python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>此处忽略<code>Python</code>基础部分</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在 Python 中，<strong>装饰器</strong>（Decorator）是一种高级功能，用于在不修改原有函数或类代码的情况下，动态地扩展或修改其行为。装饰器本质上是一个高阶函数，通常接受一个函数作为输入，并返回一个新的函数（或包装后的函数）。它广泛用于代码复用、日志记录、性能监控、权限验证等场景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在函数执行前做点什么&quot;</span>)<br>        func()  <span class="hljs-comment"># 调用原函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在函数执行后做点什么&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><br>say_hello()<br></code></pre></td></tr></table></figure><p>带参数的函数装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;调用函数 <span class="hljs-subst">&#123;func.__name__&#125;</span>，参数: <span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;函数执行完毕&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@my_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>在 Python 中，上下文管理器（Context Manager）是一种用于管理资源的工具，通常用于确保资源在使用后被正确清理。它通过 with 语句实现，能够简化异常处理和资源管理（如文件、网络连接、数据库等）的代码。</p><p>自定义上下文管理器：</p><ol><li><p>通过类实现</p><p>通过定义一个类并实现<code>__enter__</code> 和 <code>__exit__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContextManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入上下文&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>  <span class="hljs-comment"># 返回的对象会绑定到 as 后的变量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出上下文&quot;</span>)<br>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发生异常: <span class="hljs-subst">&#123;exc_type&#125;</span>, <span class="hljs-subst">&#123;exc_value&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 返回 True 表示抑制异常，返回 False 表示抛出异常</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">with</span> MyContextManager() <span class="hljs-keyword">as</span> cm:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在上下文内执行&quot;</span>)<br>    <span class="hljs-comment"># raise ValueError(&quot;测试异常&quot;)  # 取消注释以测试异常处理</span><br></code></pre></td></tr></table></figure></li><li><p>通过 <code>contextlib</code> 模块</p><p><code>Python</code> 的 <code>contextlib</code> 模块提供了一种更简洁的方式来创建上下文管理器，通常使用 <code>@contextmanager</code> 装饰器和生成器函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_context_manager</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入上下文&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;传递的值&quot;</span>  <span class="hljs-comment"># yield 的值会绑定到 as 后的变量</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出上下文&quot;</span>)<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">with</span> my_context_manager() <span class="hljs-keyword">as</span> value:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;在上下文内执行，接收到: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="Python-项目管理"><a href="#Python-项目管理" class="headerlink" title="Python 项目管理"></a>Python 项目管理</h2><h3 id="pipx"><a href="#pipx" class="headerlink" title="pipx"></a>pipx</h3><h3 id="poetry"><a href="#poetry" class="headerlink" title="poetry"></a>poetry</h3><h3 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h3>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/2025/09/25/%E5%89%8D%E7%AB%AF/React/React/"/>
    <url>/2025/09/25/%E5%89%8D%E7%AB%AF/React/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><code>jsx</code> 是 <code>JavaScript</code> 的语法扩展，<code>Jsx</code> 使得我们可以以类似于 <code>html</code> 的形式去使用 <code>js</code>。<code>jsx</code>便是<code>React</code>中声明式编程的体现方式。声明式编程，简单理解就是以结果为导向的编程。使用<code>jsx</code>将我们所期望的网页结构编写出来，然后<code>React</code>再根据<code>jsx</code>自动生成<code>js</code>代码。所以我们所编写的<code>jsx</code>代码，最终都会转换为以调用<code>React.createElement()</code>创建元素的代码。</p><ol><li><p>定义虚拟<code>DOM</code>，<code>jsx</code>不是字符串，不要加引号</p></li><li><p>标签中混入<code>JS表达式</code>的时候使用{}</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">id = &#123;myId.<span class="hljs-title function_">toUpperCase</span>()&#125;<br></code></pre></td></tr></table></figure></li><li><p>样式的类名指定不能使用class，使用<code>className</code></p></li><li><p>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">style=&#123;&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;skyblue&#x27;</span>,<span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;24px&#x27;</span>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>不能有多个根标签，只能有一个根标签</p></li><li><p><code>jsx</code>的标签必须正确结束（自结束标签必须写&#x2F;）</p></li><li><p><code>jsx</code>中<code>html</code>标签应该小写，<code>React</code>组件应该大写开头。如果小写字母开头，就将标签转化为 <code>html</code> 同名元素，如果 <code>html</code> 中无该标签对应的元素，就报错；如果是大写字母开头，<code>React</code> 就去渲染对应的组件，如果没有就报错</p></li><li><p>如果表达式是空值、布尔值、undefined，将不会显示</p></li></ol><blockquote><p>关于JS表达式和JS语句：</p><ul><li>JS表达式：返回一个值，可以放在任何一个需要值的地方 a a+b demo(a) arr.map() function text(){}</li><li>JS语句：if(){} for(){} while(){} swith(){} 不会返回一个值</li></ul></blockquote><ol start="9"><li>注释</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 写在花括号里面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    &#123;/*注释...*/&#125;</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><ol start="10"><li><p><code>class</code>需要<code>className</code>代替</p></li><li><p><code>style</code>中必须使用对象设置<code> style=&#123;&#123;background:'red'&#125;&#125;</code></p></li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p><p>只有两种方式的组件</p><ul><li>函数组件</li><li>类式组件</li></ul><p><strong>注意</strong></p><ol><li>组件名必须是首字母大写（React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div &#x2F;&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome &#x2F;&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code>）</li><li>虚拟DOM元素只能有一个根元素</li><li>虚拟DOM元素必须有结束标签 <code>&lt; /&gt;</code></li></ol><p><strong>渲染类组件标签的基本流程</strong></p><ol><li>React 内部会创建组件实例对象</li><li>调用<code>render()</code>得到虚拟 DOM ,并解析为真实 DOM</li><li>插入到指定的页面元素内部</li></ol><h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>定义组件最简单的方式就是编写 <code>JavaScript</code>函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//1.创建函数式组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//此处的this是undefined，因为babel编译后开启了严格模式</span><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">//2.渲染组件到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><p>让我们来回顾一下这个例子中发生了什么：</p><ol><li>React解析组件标签，找到了MyComponent组件。</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</li></ol><h4 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h4><blockquote><p><strong>将函数组件转换成 class 组件</strong></p><p>通过以下五步将 <code>Clock</code> 的函数组件转成 class 组件：</p><ol><li>创建一个同名的 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>，并且继承于 <code>React.Component</code>。</li><li>添加一个空的 <code>render()</code> 方法。</li><li>将函数体移动到 <code>render()</code> 方法之中。</li><li>在 <code>render()</code> 方法中使用 <code>this.props</code> 替换 <code>props</code>。</li><li>删除剩余的空函数声明。</li></ol></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render中的this:&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>          <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>        &#125;<br>      &#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;MyComponent/&gt;</code> ，就仅有一个 <code>MyComponent</code> 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p><p><strong>执行过程：</strong></p><ol><li>React解析组件标签，找到相应的组件</li><li>发现组件是类定义的，随后new出来的类的实例，并通过该实例调用到原型上的render方法</li><li>将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中</li></ol><h4 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h4><p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。</p><p>例如，我们可以创建一个可以多次渲染 <code>Welcome</code> 组件的 <code>App</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Cahal&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Edite&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>常来说，每个新的 React 应用程序的顶层组件都是 <code>App</code> 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 <code>Button</code> 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。</p><h4 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h4><p>将组件拆分为更小的组件。</p><p>例如，参考如下 <code>Comment</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) &#123;<br>        <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toLocaleString</span>()<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Commment&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.author.avatarUrl&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;width:</span> &#x27;<span class="hljs-attr">200px</span>&#x27;, <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100px</span>&#x27;&#125;&#125;/&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> comment = &#123;<br>        <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;I hope you enjoy learning React!&#x27;</span>,<br>        <span class="hljs-attr">author</span>: &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hello Kitty&#x27;</span>,<br>            <span class="hljs-attr">avatarUrl</span>: <span class="hljs-string">&#x27;https://t7.baidu.com/it/u=1819248061,230866778&amp;fm=193&amp;f=GIF&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">date</span>=<span class="hljs-string">&#123;comment.date&#125;</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&#123;comment.text&#125;</span> <span class="hljs-attr">author</span>=<span class="hljs-string">&#123;comment.author&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>该组件用于描述一个社交媒体网站上的评论功能，它接收 <code>author</code>（对象），<code>text</code> （字符串）以及 <code>date</code>（日期）作为 props。</p><p>该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。</p><p>首先，我们将提取 <code>Avatar</code> 组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span>      <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span>      <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span>    /&gt;</span></span>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Avatar</code> 不需知道它在 <code>Comment</code> 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：<code>user</code>，而不是 <code>author</code>。</p><p>我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。</p><p>我们现在针对 <code>Comment</code> 做些微小调整：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.author.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们将提取 <code>UserInfo</code> 组件，该组件在用户名旁渲染 <code>Avatar</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.user.name&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步简化 <code>Comment</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Avatar</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.user.avatarUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.user.name&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Avatar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.user&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;</span>&#123;props.user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Comment</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;props.author&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;</span>&#123;props.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;</span>&#123;formatDate(props.date)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>我们都说React是一个状态机，体现是什么地方呢，就是体现在state上，通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了。state是组件的私有属性。</p><p>在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，用户的界面会随着状态的改变而改变。</p><p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p><p>简单的说就是组件的状态，也就是该组件所存储的数据</p><p>案例：</p><p>需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p><p>核心代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/react.development.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/react-dom.development.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;./srcripts/babel.min.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id = &quot;test&quot;&gt;&lt;/div&gt;<br>&lt;script type=&quot;text/babel&quot;&gt;<br>    class Weather extends React.Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;isHot: true&#125;<br>            this.changeWeather = this.changeWeather.bind(this)<br>        &#125;<br>        render()&#123;<br>            return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;&lt;/h1&gt;<br>        &#125;<br><br>        changeWeather()&#123;<br>            // 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined<br>            const isHot = this.state.isHot<br>            this.setState(&#123;isHot: !isHot&#125;)<br>            console.log(isHot)<br>        &#125;<br>    &#125;<br>    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在<strong>类式组件</strong>的函数中，直接修改<code>state</code>值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><blockquote><p>页面的渲染靠的是<code>render</code>函数</p></blockquote><p>这时候会发现页面内容不会改变，原因是 React 中不建议 <code>state</code>不允许直接修改，而是通过类的原型对象上的方法 <code>setState()</code></p><p><strong>注意：</strong></p><ol><li>组件的构造函数，必须要传递一个props参数</li><li>特别关注this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this就是undefined</li><li>想要改变state,需要使用setState进行修改，如果只是修改state的部分属性，则不会影响其他的属性，这个只是合并并不是覆盖。</li></ol><p><strong>在优化过程中遇到的问题</strong></p><ol><li>组件中的 render 方法中的 this 为组件实例对象</li><li>组件自定义方法中由于开启了严格模式，this 指向<code>undefined</code>如何解决<ol><li>通过 bind 改变 this 指向</li><li>推荐采用箭头函数，箭头函数的 <code>this</code> 指向</li></ol></li><li>state 数据不能直接修改或者更新</li></ol><h5 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h5><p>this.State()，该方法接收两种参数：对象或函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(partialState, [callback]);<br></code></pre></td></tr></table></figure><ul><li>partialState: 需要跟新状态的部分对象，可以是<code>function</code></li><li>callback: 更新完状态后的回调函数</li></ul><p><strong>有两种写法:</strong></p><ol><li>对象：即要修改的state</li><li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state参数</li></ol><h5 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h5><ol><li><p>state 的赋值可以不在构造函数中进行</p><p><a href="https://gitee.com/link?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields">公有类字段</a></p></li><li><p>使用了箭头函数，将 this 的指向改变</p><blockquote><p>箭头函数中的this会指向调用此箭头函数的外层</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./srcripts/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;</span><br><span class="language-javascript">        state = &#123;<span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">super</span>(props);</span><br><span class="language-javascript">            <span class="hljs-comment">// this.changeWeather = this.changeWeather.bind(this)</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>天气&#123;this.state.isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 箭头函数</span></span><br><span class="language-javascript">        changeWeather = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 由于changWeather 是作为onClick的调用 并不是通过实例调用的 此时方法中this是 undefined</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> isHot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">isHot</span>: !isHot&#125;)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isHot)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Weather</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>​ </p><h5 id="state-的更新可能是异步的"><a href="#state-的更新可能是异步的" class="headerlink" title="state 的更新可能是异步的"></a>state 的更新可能是异步的</h5><p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout&#x2F;setInterval等</strong>。</p><blockquote><p>18版本中测试setTimeout回调函数中也是异步更新的</p></blockquote><p><strong>大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        count : <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addCount&#125;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            &#123;<br>                <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>            &#125;<br>        )<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><p>上面的案例中预期setState使得count变成了11，输出也应该是11。然而在控制台打印的却是10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p><p><strong>React怎么调用同步或者异步的呢？</strong></p><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p><p><strong>如果是同步更新，每一个setState对调用一个render，并且如果多次调用setState会以最后调用的为准，前面的将会作废；如果是异步更新，多个setSate会统一调用一次render</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">dem = <span class="hljs-function">() =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">444</span><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">isHot</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isHot</span> + <span class="hljs-number">1</span><br><br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isHot</span>:  <span class="hljs-number">888</span>,<br>        <span class="hljs-attr">cont</span>:<span class="hljs-number">888</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的最后会输出：isHot是888，cont是888</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>count</code>初始值为1，当执行addCount后值变成2，也就是前面两部的setState并没有执行</p><p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用render，这样每一次更新都会 **</p><h5 id="异步更新导致的问题解决方案"><a href="#异步更新导致的问题解决方案" class="headerlink" title="异步更新导致的问题解决方案"></a>异步更新导致的问题解决方案</h5><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p><p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p><p>例如，此代码可能会无法更新计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Wrong</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">increment</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br> addCount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面使用了<a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，不过使用普通的函数也同样可以：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Correct</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">state, props</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span><br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h5><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p><p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">FormattedDate</span> date=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">date</span>&#125; /&gt;<br></code></pre></td></tr></table></figure><p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FormattedDate</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p><p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p><p>为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 <code>Clock</code> 的 <code>App</code> 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>      </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>    </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Clock</code> 组件都会单独设置它自己的计时器并且更新它。</p><p>在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然</p><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><blockquote><p>只读</p></blockquote><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而 <code>props</code> 是外部传入的数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>      )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//传递数据</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tom&quot;</span> <span class="hljs-attr">age</span> = <span class="hljs-string">&#123;41&#125;</span> <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><p>如果传递的数据是一个对象，可以更加简便的使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;this.props.sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> &#123;<span class="hljs-attr">...p</span>&#125;/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>… 这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr1 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>arr2 = [...arr,...arr1];  <span class="hljs-comment">//arr2 = [1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><p>但是他还有其他的用法：</p><ol><li><p>复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>在复制的时候，合并其中的属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> p1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;<br><span class="hljs-keyword">const</span> p2 = &#123;...p1,name : <span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-attr">hua</span>:<span class="hljs-string">&quot;ss&quot;</span>&#125;;<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;sss&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2)  <span class="hljs-comment">//&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p><p><strong>props传递一个对象，是因为babel+react使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p><h5 id="props-限制"><a href="#props-限制" class="headerlink" title="props 限制"></a>props 限制</h5><blockquote><p>注意：</p><p>自 React v15.5 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <a href="https://gitee.com/link?target=https://www.npmjs.com/package/prop-types"><code>prop-types</code> 库</a> 代替。</p><p>我们提供了一个 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html%23migrating-from-reactproptypes">codemod 脚本</a>来做自动转换。</p></blockquote><p>随着你的应用程序不断增长，你可以通过类型检查捕获大量错误。对于某些应用程序来说，你可以使用 <a href="https://gitee.com/link?target=https://flow.org/">Flow</a> 或 <a href="https://gitee.com/link?target=https://www.typescriptlang.org/">TypeScript</a> 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 <code>propTypes</code> 属性：</p><p>react对此提供了相应的解决方法：</p><ul><li>propTypes:类型检查，还可以限制不能为空</li><li>defaultProps：默认值</li></ul><blockquote><p>从 ES2022 开始，你也可以在 React 类组件中将 <code>defaultProps</code> 声明为静态属性。欲了解更多信息，请参阅 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields%23public_static_fields">class public static fields</a>。这种现代语法需要添加额外的编译步骤才能在老版浏览器中工作。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//对标签属性进行类型、必要性的限制</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span><br>    <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span><br>    <span class="hljs-attr">speak</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<span class="hljs-comment">//限制speak为函数</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-comment">//指定默认标签属性值</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;<br>    <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span><br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p><p><code>defaultProps</code> 用于确保 <code>this.props.sex</code> 在父组件没有指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p><h6 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h6><p>以下提供了使用不同验证器的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span><br>  <span class="hljs-comment">// 这些属性都是可选的。</span><br>  <span class="hljs-attr">optionalArray</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>,<br>  <span class="hljs-attr">optionalBool</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">bool</span>,<br>  <span class="hljs-attr">optionalFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,<br>  <span class="hljs-attr">optionalNumber</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>  <span class="hljs-attr">optionalObject</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">object</span>,<br>  <span class="hljs-attr">optionalString</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>  <span class="hljs-attr">optionalSymbol</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">symbol</span>,<br><br>  <span class="hljs-comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span><br>  <span class="hljs-comment">// (或 Fragment) 也包含这些类型。</span><br>  <span class="hljs-attr">optionalNode</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">node</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素。</span><br>  <span class="hljs-attr">optionalElement</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>,<br><br>  <span class="hljs-comment">// 一个 React 元素类型（即，MyComponent）。</span><br>  <span class="hljs-attr">optionalElementType</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">elementType</span>,<br><br>  <span class="hljs-comment">// 你也可以声明 prop 为类的实例，这里使用</span><br>  <span class="hljs-comment">// JS 的 instanceof 操作符。</span><br>  <span class="hljs-attr">optionalMessage</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>),<br><br>  <span class="hljs-comment">// 你可以让你的 prop 只能是特定的值，指定它为</span><br>  <span class="hljs-comment">// 枚举类型。</span><br>  <span class="hljs-attr">optionalEnum</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOf</span>([<span class="hljs-string">&#x27;News&#x27;</span>, <span class="hljs-string">&#x27;Photos&#x27;</span>]),<br><br>  <span class="hljs-comment">// 一个对象可以是几种类型中的任意一个类型</span><br>  <span class="hljs-attr">optionalUnion</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOfType</span>([<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<br>    <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Message</span>)<br>  ]),<br><br>  <span class="hljs-comment">// 可以指定一个数组由某一类型的元素组成</span><br>  <span class="hljs-attr">optionalArrayOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由某一类型的值组成</span><br>  <span class="hljs-attr">optionalObjectOf</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">objectOf</span>(<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>),<br><br>  <span class="hljs-comment">// 可以指定一个对象由特定的类型值组成</span><br>  <span class="hljs-attr">optionalObjectWithShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">shape</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 具有额外属性警告的对象</span><br>  <span class="hljs-attr">optionalObjectWithStrictShape</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">exact</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<br>    <span class="hljs-attr">quantity</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span><br>  &#125;),<br><br>  <span class="hljs-comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span><br>  <span class="hljs-comment">// 这个 prop 没有被提供时，会打印警告信息。</span><br>  <span class="hljs-attr">requiredFunc</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 任意类型的必需数据</span><br>  <span class="hljs-attr">requiredAny</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">any</span>.<span class="hljs-property">isRequired</span>,<br><br>  <span class="hljs-comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `oneOfType` 中不会起作用。</span><br>  <span class="hljs-attr">customProp</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">props, propName, componentName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(props[propName])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span><br>  <span class="hljs-comment">// 它应该在验证失败时返回一个 Error 对象。</span><br>  <span class="hljs-comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span><br>  <span class="hljs-comment">// 第一个是数组或对象本身</span><br>  <span class="hljs-comment">// 第二个是他们当前的键。</span><br>  <span class="hljs-attr">customArrayProp</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">arrayOf</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">propValue, key, componentName, location, propFullName</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.<span class="hljs-title function_">test</span>(propValue[key])) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="hljs-string">&#x27;` supplied to&#x27;</span> +<br>        <span class="hljs-string">&#x27; `&#x27;</span> + componentName + <span class="hljs-string">&#x27;`. Validation failed.&#x27;</span><br>      );<br>    &#125;<br>  &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="限制单个元素"><a href="#限制单个元素" class="headerlink" title="限制单个元素"></a>限制单个元素</h6><p>你可以通过 <code>PropTypes.element</code> 来确保传递给组件的 children 中只包含一个元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 这必须只有一个元素，否则控制台会打印警告。</span><br>    <span class="hljs-keyword">const</span> children = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;children&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">propTypes</span> = &#123;<br>  <span class="hljs-attr">children</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">element</span>.<span class="hljs-property">isRequired</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>简写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!-- 准备好一个“容器” --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//创建组件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(props);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">super</span>(props)</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//对标签属性进行类型、必要性的限制</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> propTypes = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>,<span class="hljs-comment">//限制sex为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,<span class="hljs-comment">//限制age为数值</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//指定默认标签属性值</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">static</span> defaultProps = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// console.log(this);</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">const</span> &#123;name,age,sex&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> (</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">            )</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//渲染组件到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span>/&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在使用的时候可以通过 <code>this.props</code>来获取值 类式组件的 <code>props</code>:</p><ol><li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li><li>在构造器里的<code>props</code>参数里可以获取到 <code>props</code></li><li>可以分别设置 <code>propTypes</code> 和 <code>defaultProps</code> 两个属性来分别操作 <code>props</code>的规范和默认值，两者都是直接添加在类式组件的<strong>原型对象</strong>上的（所以需要添加 <code>static</code>）</li><li>同时可以通过<code>...</code>运算符来简化</li></ol><h5 id="函数组件的使用"><a href="#函数组件的使用" class="headerlink" title="函数组件的使用"></a>函数组件的使用</h5><blockquote><p>函数在使用props的时候，是作为参数进行使用的(props)</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>对props进行限制<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//创建组件</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">props</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> &#123; name, age, sex &#125; = props</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> (</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">propTypes</span> = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>, <span class="hljs-comment">//限制name必传，且为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">sex</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>, <span class="hljs-comment">//限制sex为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>, <span class="hljs-comment">//限制age为数值</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//指定默认标签属性值</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Person</span>.<span class="hljs-property">defaultProps</span> = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-comment">//sex默认值为男</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">//age默认值为18</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//渲染组件到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test1&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>函数组件的 <code>props</code>定义:</p><ol><li>在组件标签中传递 <code>props</code>的值</li><li>组件函数的参数为 <code>props</code></li><li>对 <code>props</code>的限制和默认值同样设置在原型对象上</li></ol><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p><p>在典型的 React 数据流中，<a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/components-and-props.html">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p><blockquote><p>在我们正常的操作节点时，需要采用DOM API 来查找元素，但是这样违背了 React 的理念，因此有了<code>refs</code></p></blockquote><p><strong>何时使用 Refs</strong></p><p>下面是几个适合使用 refs 的情况：</p><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p><p><strong>有三种操作<code>refs</code>的方法，分别为：</strong></p><ul><li>字符串形式</li><li>回调形式</li><li><code>createRef</code>形式</li></ul><p><strong>勿过度使用 Refs</strong></p><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/lifting-state-up.html">状态提升</a> 以获取更多有关示例。</p><h5 id="字符串形式"><a href="#字符串形式" class="headerlink" title="字符串形式"></a>字符串形式</h5><p>在想要获取到一个DOM节点，可以直接在这个节点上添加ref属性。利用该属性进行获取该节点的值。</p><p>案例：给需要的节点添加ref属性，此时该实例对象的refs上就会有这个值。就可以利用实例对象的refs获取已经添加节点的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">ref</span> = <span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;失去焦点提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>不建议使用它，因为 string 类型的 refs 存在 <a href="https://gitee.com/link?target=https://github.com/facebook/react/pull/8333%23issuecomment-271648615">一些问题</a>。它已过时并可能会在未来的版本被移除。</p><p>如果你目前还在使用 <code>this.refs.textInput</code> 这种方式访问 refs ，我们建议用<a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/refs-and-the-dom.html%23callback-refs">回调函数</a>或 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/refs-and-the-dom.html%23creating-refs"><code>createRef</code> API</a> 的方式代替。</p><h5 id="回调形式"><a href="#回调形式" class="headerlink" title="回调形式"></a>回调形式</h5><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p><p>这种方式会将该DOM作为参数传递过去。</p><p>组件实例的<code>ref</code>属性传递一个回调函数<code>c =&gt; this.input1 = c </code>（箭头函数简写），这样会在实例的属性中存储对DOM节点的引用，使用时可通过<code>this.input1</code>来使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><p><code>current</code>会接收到当前节点作为参数，然后将当前节点赋值给<code>input1</code>实例属性上</p><p><strong>关于回调 refs 的说明</strong></p><p>如果 <code>ref</code> 回调函数是以<code>内联函数</code>的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。<strong>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的</strong>。</p><p><code>class的绑定函数</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    saveInput = <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>, c)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.saveInput&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    showData = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>tips: 其实就相当于是匿名函数对于react来说，每次的函数都是不一样的，基于类绑定的方式，使用的是一个固定的实例函数，因此对于他来说没必要有清空之前绑定的这一步</p></blockquote><h5 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h5><blockquote><p>React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点 </p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    myRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>    state = &#123;<br>        <span class="hljs-attr">isHot</span>: <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-keyword">const</span> &#123;isHot&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今天天气很&#123;isHot?&#x27;热&#x27;:&#x27;冷&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                &#123;/*<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;current</span> =&gt;</span> &#123;</span><br><span class="language-xml">                    this.input1 = current; console.log(&#x27;@&#x27;, current)</span><br><span class="language-xml">                &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;*/&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;this.myRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeWeather&#125;</span>&gt;</span>修改天气<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>    changeWeather = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-variable language_">this</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;@ ref&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span>.<span class="hljs-property">current</span>)<br>        <span class="hljs-keyword">const</span> &#123;<br>            isHot<br>        &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">isHot</span>: !isHot<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>逻辑：最开始创建一个实例的ref，后续通过ref关键字，react发现ref是通过<code>React.crateRef</code>创建的，然后他会把当前的节点赋值给myRef，如果有多个节点的话，他就需要创建多个ref</p></blockquote><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>Refs与函数组件</p><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyFunctionComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">textInput</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// This will *not* work!</span><br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyFunctionComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.textInput&#125;</span> /&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/forwarding-refs.html"><code>forwardRef</code></a>（可与 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/hooks-reference.html%23useimperativehandle"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p><p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomTextInput</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 才可以引用它</span><br>  <span class="hljs-keyword">const</span> textInput = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    textInput.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;textInput&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Focus the text input&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>React的事件是通过onXxx属性指定事件处理函数，React 使用的是自定义事件，而不是原生的 DOM 事件，React 的事件是通过事件委托方式处理的（为了更加的高效），可以通过事件的 <code>event.target</code>获取发生的 DOM 元素对象，可以尽量减少 <code>refs</code>的使用，事件中必须返回的是函数</p><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li><li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li></ul><p>例如，传统的html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;activateLasers()&quot;</span>&gt;</span><br>  Activate Lasers<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 React 中略微不同：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;activateLasers&#125;&gt;  <br>   <span class="hljs-title class_">Activate</span> <span class="hljs-title class_">Lasers</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式地使用 <code>preventDefault</code>。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;console.log(&#x27;You clicked submit.&#x27;); return false&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 React 中，可能是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You clicked submit.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>e</code> 是一个合成事件。React 根据 <a href="https://gitee.com/link?target=https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href="https://gitee.com/link?target=https://zh-hans.reactjs.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南。</p><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p><h3 id="类式组件绑定事件"><a href="#类式组件绑定事件" class="headerlink" title="类式组件绑定事件"></a>类式组件绑定事件</h3><p>当你使用 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    state = &#123;<br>        <span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">                &#123;this.state.isToggleOn?&#x27;ON&#x27;: &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>        )<br>    &#125;<br><br>    handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>            <span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;<br>                <span class="hljs-attr">isToggleOn</span>: !state.<span class="hljs-property">isToggleOn</span><br>            &#125;)<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span>/&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>))<br><br></code></pre></td></tr></table></figure><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述两种方式是等价的，分别通过<a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://gitee.com/link?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p><p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">saveName = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">name</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br>savePwd = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">pwd</span>:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>&#125;<br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">            用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.name&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveName&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">            密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.pwd&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.savePwd&#125;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;password&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p><p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>非受控组件其实就是表单元素的值不会更新state。输入数据都是现用现取的。</p><p>如下：下面并没有使用state来控制属性，使用的是事件来控制表单的属性值。</p><blockquote><p>表单提交同样需要通过事件来处理，提交表单的事件通过form标签的onSubmit事件来绑定，处理表单的方式因情况而已，但是一定要注意，必须要取消默认行为，否则会触发表单的默认提交行为：</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br><br>    login = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span>&#123;<br>        event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">//阻止表单默认事件</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-property">value</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pwd</span>.<span class="hljs-property">value</span>);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> (<br>                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.login&#125;</span>&gt;</span></span><br><span class="language-xml">                用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.name =e &#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="language-xml">                密码：  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;e</span> =&gt;</span> this.pwd =e &#125; type = &quot;password&quot; name =&quot;password&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>            )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h3><p><strong>高级函数</strong></p><ol><li>如果函数的参数是函数</li><li>如果函数返回一个函数</li></ol><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p><p>如下，我们将上面的案例简化，创建高级函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;this.saveType(</span>&#x27;<span class="hljs-attr">name</span>&#x27;)&#125; <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure><p>不使用函数柯里化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    state = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">pwd</span>:<span class="hljs-string">&quot;&quot;</span>&#125;;<br><br>    <span class="hljs-comment">//返回一个函数</span><br>    saveType = <span class="hljs-function">(<span class="hljs-params">type,event</span>) =&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;[type]:event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">//因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span> = <span class="hljs-string">&#123;event</span> =&gt;</span> this.saveType(&#x27;name&#x27;,event)&#125; type = &quot;text&quot;/&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http 请求中 Header 存放中文会发生的问题</title>
    <link href="/2025/09/12/%E5%B7%A5%E4%BD%9C/Http%20%E8%AF%B7%E6%B1%82%E4%B8%AD%20Header%20%E5%AD%98%E6%94%BE%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/09/12/%E5%B7%A5%E4%BD%9C/Http%20%E8%AF%B7%E6%B1%82%E4%B8%AD%20Header%20%E5%AD%98%E6%94%BE%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Http-请求中-Header-存放中文会发生的问题"><a href="#Http-请求中-Header-存放中文会发生的问题" class="headerlink" title="Http 请求中 Header 存放中文会发生的问题"></a>Http 请求中 Header 存放中文会发生的问题</h1><p>背景：遇到了一个场景，现在请求打到网关，然后网关中有一个过滤器，过滤器会向请求中的<code>header</code>存放一个类似于 <code>X-User-Data</code>字段，然后值是一个<code>json</code>字符串，然后将请求转发到另一台服务器，另一台服务器去解析这个json字符串，但此时出现了一个意外的情况，解析之后<code>json</code>字符串中的中文会变成<code>???</code>，然后排查了很多情况，因为也有序列化的定制，最后逐一排查没有问题，发现是因为 <code>header</code>中存放的问题。</p><blockquote><p>其实笔者很难理解为啥要把用户信息变成json字符串存放到header中</p></blockquote><h2 id="为什么会出现这种情况？"><a href="#为什么会出现这种情况？" class="headerlink" title="为什么会出现这种情况？"></a>为什么会出现这种情况？</h2><h3 id="1-HTTP-Header-的历史规范"><a href="#1-HTTP-Header-的历史规范" class="headerlink" title="1. HTTP Header 的历史规范"></a>1. HTTP Header 的历史规范</h3><ol><li><p>早期 HTTP&#x2F;1.1 的 RFC 2616（1999 年）要求 Header 值必须是 <strong>ISO-8859-1 (Latin-1)</strong>，即单字节字符集，只能表示西欧字符。</p></li><li><p>后来 RFC 7230（2014 年）放宽了要求，允许 Header 使用 ASCII，但仍然没有正式规定 UTF-8。</p></li><li><p>到现在的 RFC 9110（HTTP&#x2F;1.1 最新规范，2022 年）里才明确：Header 的语义值可以是 <strong>Unicode（UTF-8）</strong>，但实现上仍要考虑兼容性。</p></li></ol><h3 id="2-一些服务器仍然不支持-“UTF-8”"><a href="#2-一些服务器仍然不支持-“UTF-8”" class="headerlink" title="2. 一些服务器仍然不支持 “UTF-8”"></a>2. 一些服务器仍然不支持 “UTF-8”</h3><p><strong>老旧的 Web 服务器</strong></p><ul><li>例如某些版本的 Apache、Tomcat、IIS，仍然默认用 ISO-8859-1 解析 Header。</li><li>如果你传中文 UTF-8（多字节），它会逐字节解码 → 乱码。</li></ul><p><strong>反向代理 &#x2F; API 网关</strong></p><ul><li>比如 Nginx 默认认为 Header 是 ASCII，如果配置不对，转发时可能丢掉或截断非 ASCII。</li><li>某些企业级 API 网关（如 Zuul、Kong）也会拒绝包含非 ASCII 的 Header。</li></ul><p><strong>编程语言库</strong></p><ul><li>Go 的 <code>net/http</code> 是支持 UTF-8 Header 的（不会报错）</li><li>但 Java 的 <code>HttpURLConnection</code> 或一些老的 Servlet 容器可能会用 ISO-8859-1 处理，中文就会乱码。</li></ul><h3 id="3-兼容性问题"><a href="#3-兼容性问题" class="headerlink" title="3. 兼容性问题"></a>3. 兼容性问题</h3><p>不同的服务和中间件处理方式不一样：</p><ul><li><strong>浏览器 &#x2F; 常见 HTTP 客户端库</strong>：有些会自动尝试转义，有些会直接报错。</li><li><strong>Nginx &#x2F; Apache</strong>：可能会拒绝请求（<code>400 Bad Request</code>）或者把中文替换成 <code>?</code>。</li><li><strong>反向代理 &#x2F; 网关（如 Kong、Zuul、Envoy）</strong>：可能会直接丢掉该 header，或者导致整个请求失败。</li><li><strong>跨语言服务</strong>：比如后端是 Go，网关是 Java，某些语言解析时直接报错。</li></ul><h2 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h2><blockquote><p>因为解决问题比较简单，笔者只提供思路</p></blockquote><ol><li>在 <code>Header</code>中只存放<code>用户id</code>等关键信息，一方面是避免请求过大，导致请求性能降低，另一方面符合 <code>Http</code>规范，后续其他服务通过<code>用户id</code>等关键信息可以再次获取用户信息</li><li>如果现在架构已经设计好了，已经没有办法修改了，现在可以采用把整个带中文的<code>json字符串</code>通过<code>BSER64</code>加密之后传输，跟<code>http</code>中<code>url</code>携带中文类似</li></ol>]]></content>
    
    
    <categories>
      
      <category>经验</category>
      
      <category>工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Centos7下 Golang 环境搭建</title>
    <link href="/2025/07/14/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Centos%207%20%E4%B8%8B%20golang%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/07/14/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Centos%207%20%E4%B8%8B%20golang%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Centos7下-Golang-环境搭建"><a href="#Centos7下-Golang-环境搭建" class="headerlink" title="Centos7下 Golang 环境搭建"></a>Centos7下 Golang 环境搭建</h1><h2 id="yum-安装-【不推荐】"><a href="#yum-安装-【不推荐】" class="headerlink" title="yum 安装 【不推荐】"></a>yum 安装 【不推荐】</h2><ol><li>用yum指令安装缺点是：不是最新版</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install golang<br></code></pre></td></tr></table></figure><h2 id="使用二进制文件安装"><a href="#使用二进制文件安装" class="headerlink" title="使用二进制文件安装"></a>使用二进制文件安装</h2><p>标准官网：<a href="https://golang.org/">https://golang.org/</a> 需要墙<br>镜像官网：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a> 【国内推荐】</p><ol><li><p>下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://golang.google.cn/dl/go1.23.0.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压文件到 &#x2F;usr&#x2F;local<br>  【重要】如果之前已经安装过go的版本，先清空下go下面src，不然可能会报一些previous declaration at &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;internal&#x2F;atomic&#x2F;atomic_amd64.go:16:24的错误</p></li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /usr/local/go<br></code></pre></td></tr></table></figure><ol start="3"><li><p>解压 go 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxf go1.17.linux-amd64.tar.gz -C /usr/local<br></code></pre></td></tr></table></figure></li><li><p>配置环境变量，vim 命令编辑 &#x2F;etc&#x2F;profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>在 <code>/etc/profile</code>文件末尾添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#golang config</span><br><span class="hljs-built_in">export</span> GOROOT=/usr/local/go <br><span class="hljs-built_in">export</span> GOPATH=/data/gopath<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin<br></code></pre></td></tr></table></figure></li><li><p>创建 &#x2F;data&#x2F;gopath 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /data/gopath<br></code></pre></td></tr></table></figure></li><li><p><code>source /etc/profile</code></p></li><li><p>设置 <code>golang</code>代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Linux</tag>
      
      <tag>Centos 7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2025/07/07/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/vim/"/>
    <url>/2025/07/07/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>背景介绍，公司开发使用主要使用的是 Golang，很多小伙伴会使用 <code>LazyVim</code>进行开发，因此在公司我也尝试自己配置了一个出来。</p><p>下面是一些<code>debug</code>配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> &#123;<br>  &#123; <span class="hljs-string">&quot;nvim-neotest/nvim-nio&quot;</span> &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;mfussenegger/nvim-dap&quot;</span>,<br><br>    dependencies = &#123;<br><br>      <span class="hljs-comment">-- fancy UI for the debugger</span><br>      &#123;<br>        <span class="hljs-string">&quot;rcarriga/nvim-dap-ui&quot;</span>,<br>      <span class="hljs-comment">-- stylua: ignore</span><br>      keys = &#123;<br>        &#123; <span class="hljs-string">&quot;&lt;leader&gt;du&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>).toggle(&#123; &#125;) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Dap UI&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;&lt;leader&gt;de&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>).eval() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Eval&quot;</span>, mode = &#123;<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;v&quot;</span>&#125; &#125;,<br>      &#125;,<br>        opts = &#123;&#125;,<br>        <span class="hljs-built_in">config</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, opts)</span></span><br>          <span class="hljs-comment">-- setup dap config by VsCode launch.json file</span><br>          <span class="hljs-comment">-- require(&quot;dap.ext.vscode&quot;).load_launchjs()</span><br>          <span class="hljs-keyword">local</span> dap = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>)<br>          <span class="hljs-keyword">local</span> dapui = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dapui&quot;</span>)<br>          dapui.setup(opts)<br>          dap.listeners.after.event_initialized[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">open</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>          dap.listeners.before.event_terminated[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>          dap.listeners.before.event_exited[<span class="hljs-string">&quot;dapui_config&quot;</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            dapui.<span class="hljs-built_in">close</span>(&#123;&#125;)<br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span>,<br>      &#125;,<br><br>      <span class="hljs-comment">-- virtual text for the debugger</span><br>      &#123;<br>        <span class="hljs-string">&quot;theHamsta/nvim-dap-virtual-text&quot;</span>,<br>        opts = &#123;&#125;,<br>      &#125;,<br><br>      <span class="hljs-comment">-- which key integration</span><br>      &#123;<br>        <span class="hljs-string">&quot;folke/which-key.nvim&quot;</span>,<br>        optional = <span class="hljs-literal">true</span>,<br>        opts = &#123;<br>          defaults = &#123;<br>            [<span class="hljs-string">&quot;&lt;leader&gt;d&quot;</span>] = &#123; name = <span class="hljs-string">&quot;+debug&quot;</span> &#125;,<br>          &#125;,<br>        &#125;,<br>      &#125;,<br><br>      <span class="hljs-comment">-- mason.nvim integration</span><br>      &#123;<br>        <span class="hljs-string">&quot;jay-babu/mason-nvim-dap.nvim&quot;</span>,<br>        dependencies = <span class="hljs-string">&quot;mason.nvim&quot;</span>,<br>        cmd = &#123; <span class="hljs-string">&quot;DapInstall&quot;</span>, <span class="hljs-string">&quot;DapUninstall&quot;</span> &#125;,<br>        opts = &#123;<br>          <span class="hljs-comment">-- Makes a best effort to setup the various debuggers with</span><br>          <span class="hljs-comment">-- reasonable debug configurations</span><br>          automatic_installation = <span class="hljs-literal">true</span>,<br><br>          <span class="hljs-comment">-- You can provide additional configuration to the handlers,</span><br>          <span class="hljs-comment">-- see mason-nvim-dap README for more information</span><br>          handlers = &#123;&#125;,<br><br>          <span class="hljs-comment">-- You&#x27;ll need to check that you have the required things installed</span><br>          <span class="hljs-comment">-- online, please don&#x27;t ask me how to install them :)</span><br>          ensure_installed = &#123;<br>            <span class="hljs-comment">-- Update this to ensure that you have the debuggers for the langs you want</span><br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br><br>  <span class="hljs-comment">-- stylua: ignore</span><br>  keys = &#123;<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dB&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).set_breakpoint(vim.fn.<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Breakpoint condition: &#x27;</span>)) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Breakpoint Condition&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;db&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).toggle_breakpoint() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Toggle Breakpoint&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).continue() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Continue&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;da&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).continue(&#123; before = get_args &#125;) <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run with Args&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dC&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).run_to_cursor() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run to Cursor&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dg&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).goto_() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Go to line (no execute)&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;di&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_into() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Into&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dj&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).down() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Down&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dk&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).up() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Up&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dl&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).run_last() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Run Last&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;do&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_out() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Out&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dO&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).step_over() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Step Over&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dp&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).pause() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Pause&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dr&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).repl.toggle() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Toggle REPL&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;ds&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).session() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Session&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dt&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap&quot;</span>).terminate() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Terminate&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;&lt;leader&gt;dw&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dap.ui.widgets&quot;</span>).hover() <span class="hljs-keyword">end</span>, desc = <span class="hljs-string">&quot;Widgets&quot;</span> &#125;,<br>  &#125;,<br><br>    <span class="hljs-built_in">config</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>      <span class="hljs-keyword">local</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lazyvim.config&quot;</span>)<br>      vim.api.nvim_set_hl(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;DapStoppedLine&quot;</span>, &#123; default = <span class="hljs-literal">true</span>, link = <span class="hljs-string">&quot;Visual&quot;</span> &#125;)<br><br>      <span class="hljs-keyword">for</span> name, sign <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(Config.icons.dap) <span class="hljs-keyword">do</span><br>        sign = <span class="hljs-built_in">type</span>(sign) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">and</span> sign <span class="hljs-keyword">or</span> &#123; sign &#125;<br>        vim.fn.sign_define(<br>          <span class="hljs-string">&quot;Dap&quot;</span> .. name,<br>          &#123; text = sign[<span class="hljs-number">1</span>], texthl = sign[<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;DiagnosticInfo&quot;</span>, linehl = sign[<span class="hljs-number">3</span>], numhl = sign[<span class="hljs-number">3</span>] &#125;<br>        )<br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">require(&quot;dap-go&quot;).setup(&#123;</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">Additional</span> <span class="hljs-string">dap</span> <span class="hljs-string">configurations</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">added.</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">dap_configurations</span> <span class="hljs-string">accepts</span> <span class="hljs-string">a</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">tables</span> <span class="hljs-string">where</span> <span class="hljs-string">each</span> <span class="hljs-string">entry</span><br>  <span class="hljs-string">dap_configurations</span> <span class="hljs-string">=</span> &#123;<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowServer&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/server/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowJob&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/job/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowGRPC&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/grpc/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;MeflowMigrate&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/migrate/main.go&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;go&quot;</span>,<br>      <span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;Integhub&quot;</span>,<br>      <span class="hljs-string">request</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>      <span class="hljs-string">program</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;./cmd/server/main.go&quot;</span>,<br>    &#125;,<br>  &#125;<span class="hljs-string">,</span> <span class="hljs-string">--</span> <span class="hljs-attr">represents a dap configuration. For more details do:</span><br>  <span class="hljs-string">--</span> <span class="hljs-string">:help</span> <span class="hljs-string">dap-configuration</span><br><br>  <span class="hljs-string">--</span> <span class="hljs-string">delve</span> <span class="hljs-string">configurations</span><br>  <span class="hljs-string">delve</span> <span class="hljs-string">=</span> &#123;<br>    <span class="hljs-string">--</span> <span class="hljs-string">the</span> <span class="hljs-string">path</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">executable</span> <span class="hljs-string">dlv</span> <span class="hljs-string">which</span> <span class="hljs-string">will</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">for</span> <span class="hljs-string">debugging.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">by</span> <span class="hljs-string">default</span>, <span class="hljs-string">this</span> <span class="hljs-string">is</span> <span class="hljs-string">the</span> <span class="hljs-string">&quot;dlv&quot;</span> <span class="hljs-string">executable</span> <span class="hljs-string">on</span> <span class="hljs-string">your</span> <span class="hljs-string">PATH.</span><br>    <span class="hljs-string">path</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;dlv&quot;</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">time</span> <span class="hljs-string">to</span> <span class="hljs-string">wait</span> <span class="hljs-string">for</span> <span class="hljs-string">delve</span> <span class="hljs-string">to</span> <span class="hljs-string">initialize</span> <span class="hljs-string">the</span> <span class="hljs-string">debug</span> <span class="hljs-string">session.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">default</span> <span class="hljs-string">to</span> <span class="hljs-number">20</span> <span class="hljs-string">seconds</span><br>    <span class="hljs-string">initialize_timeout_sec</span> <span class="hljs-string">=</span> <span class="hljs-number">20</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">a</span> <span class="hljs-string">string</span> <span class="hljs-string">that</span> <span class="hljs-string">defines</span> <span class="hljs-string">the</span> <span class="hljs-string">port</span> <span class="hljs-string">to</span> <span class="hljs-string">start</span> <span class="hljs-string">delve</span> <span class="hljs-string">debugger.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">default</span> <span class="hljs-string">to</span> <span class="hljs-string">string</span> <span class="hljs-string">&quot;$&#123;port&#125;&quot;</span> <span class="hljs-string">which</span> <span class="hljs-string">instructs</span> <span class="hljs-string">nvim-dap</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">to</span> <span class="hljs-string">start</span> <span class="hljs-string">the</span> <span class="hljs-string">process</span> <span class="hljs-string">in</span> <span class="hljs-string">a</span> <span class="hljs-string">random</span> <span class="hljs-string">available</span> <span class="hljs-string">port</span><br>    <span class="hljs-string">port</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;$&#123;port&#125;&quot;</span>,<br>    <span class="hljs-string">--</span> <span class="hljs-string">additional</span> <span class="hljs-string">args</span> <span class="hljs-string">to</span> <span class="hljs-string">pass</span> <span class="hljs-string">to</span> <span class="hljs-string">dlv</span><br>    <span class="hljs-string">args</span> <span class="hljs-string">=</span> &#123;&#125;,<br>    <span class="hljs-string">--</span> <span class="hljs-string">the</span> <span class="hljs-string">build</span> <span class="hljs-string">flags</span> <span class="hljs-string">that</span> <span class="hljs-string">are</span> <span class="hljs-string">passed</span> <span class="hljs-string">to</span> <span class="hljs-string">delve.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">defaults</span> <span class="hljs-string">to</span> <span class="hljs-string">empty</span> <span class="hljs-string">string</span>, <span class="hljs-string">but</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">to</span> <span class="hljs-string">provide</span> <span class="hljs-string">flags</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">such</span> <span class="hljs-string">as</span> <span class="hljs-string">&quot;-tags=unit&quot;</span> <span class="hljs-string">to</span> <span class="hljs-string">make</span> <span class="hljs-string">sure</span> <span class="hljs-string">the</span> <span class="hljs-string">test</span> <span class="hljs-string">suite</span> <span class="hljs-string">is</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">compiled</span> <span class="hljs-string">during</span> <span class="hljs-string">debugging</span>, <span class="hljs-string">for</span> <span class="hljs-string">example.</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">passing</span> <span class="hljs-string">build</span> <span class="hljs-string">flags</span> <span class="hljs-string">using</span> <span class="hljs-string">args</span> <span class="hljs-string">is</span> <span class="hljs-string">ineffective</span>, <span class="hljs-string">as</span> <span class="hljs-string">those</span> <span class="hljs-string">are</span><br>    <span class="hljs-string">--</span> <span class="hljs-string">ignored</span> <span class="hljs-string">by</span> <span class="hljs-string">delve</span> <span class="hljs-string">in</span> <span class="hljs-string">dap</span> <span class="hljs-string">mode.</span><br>    <span class="hljs-string">build_flags</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;<span class="hljs-string">,</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log/slog&quot;</span><br><br><span class="hljs-string">&quot;github.com/traefik/yaegi/interp&quot;</span><br><span class="hljs-string">&quot;github.com/traefik/yaegi/stdlib&quot;</span><br><br><span class="hljs-string">&quot;powerlaw.ai/ae/integhub/pkg/param&quot;</span><br><span class="hljs-string">&quot;powerlaw.ai/ae/integhub/runtime/yaegi&quot;</span>. <span class="hljs-comment">// 导入包</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">code2Runnable</span><span class="hljs-params">(code <span class="hljs-type">string</span>)</span></span> (runFunc, <span class="hljs-type">error</span>) &#123;<br>i := interp.New(interp.Options&#123;&#125;)<br><span class="hljs-keyword">if</span> err := loadLibs(i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to load libs: %w&quot;</span>, err)<br>&#125;<br><br>_, err := i.Eval(code)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to eval code: %w&quot;</span>, err)<br>&#125;<br><br>v, err := i.Eval(<span class="hljs-string">&quot;goapp.Run&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to get DemoGoApp: %w&quot;</span>, err)<br>&#125;<br>slog.Debug(<span class="hljs-string">&quot;app loaded&quot;</span>, <span class="hljs-string">&quot;app&quot;</span>, v)<br><br>rf, ok := v.Interface().(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>))<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrSignatureMismatch<br>&#125;<br><br><span class="hljs-keyword">return</span> rf, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadLibs</span><span class="hljs-params">(i *interp.Interpreter)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := i.Use(stdlib.Symbols); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to use stdlib: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := i.Use(yaegi.Symbols); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to use plibs: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2025/07/07/Docker/"/>
    <url>/2025/07/07/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul><li>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li><li>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></li></ul><h2 id="1-Docker的基本概念"><a href="#1-Docker的基本概念" class="headerlink" title="1. Docker的基本概念"></a>1. Docker的基本概念</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><h3 id="1-2-为什么是Docker"><a href="#1-2-为什么是Docker" class="headerlink" title="1.2 为什么是Docker"></a>1.2 为什么是Docker</h3><ul><li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p><p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势1: 一致的运行环境,更轻松的迁移</strong></p></li><li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p><p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p></li><li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p><p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p><p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p></li></ul><h3 id="1-3-Docker和虚拟机的区别"><a href="#1-3-Docker和虚拟机的区别" class="headerlink" title="1.3 Docker和虚拟机的区别"></a>1.3 Docker和虚拟机的区别</h3><blockquote><p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p></blockquote><p><img src="https://i.imgur.com/pwU9rfo.png" alt="img"></p><p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p><table><thead><tr><th align="left"></th><th align="left">传统虚拟机</th><th align="left">Docker容器</th></tr></thead><tbody><tr><td align="left">磁盘占用</td><td align="left">几个GB到几十个GB左右</td><td align="left">几十MB到几百MB左右</td></tr><tr><td align="left">CPU内存占用</td><td align="left">虚拟操作系统非常占用CPU和内存</td><td align="left">Docker引擎占用极低</td></tr><tr><td align="left">启动速度</td><td align="left">（从开机到运行项目）几分钟</td><td align="left">（从开启容器到运行项目）几秒</td></tr><tr><td align="left">安装管理</td><td align="left">需要专门的运维技术</td><td align="left">安装、管理方便</td></tr><tr><td align="left">应用部署</td><td align="left">每次部署都费时费力</td><td align="left">从第二次部署开始轻松简捷</td></tr><tr><td align="left">耦合性</td><td align="left">多个应用服务安装到一起，容易互相影响</td><td align="left">每个应用服务一个容器，达成隔离</td></tr><tr><td align="left">系统依赖</td><td align="left">无</td><td align="left">需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><hr><h2 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2. Docker的安装"></a>2. Docker的安装</h2><blockquote><p>以centos7为例 文档： <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p></blockquote><ul><li><p>卸载原始docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>安装docker依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y yum-utils<br><span class="hljs-built_in">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo <span class="hljs-comment"># 国内可能无法使用 可以使用下面的镜像源</span><br><span class="hljs-comment"># sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure></li><li><p>兼容性卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 卸载旧版本的docker</span><br>yum remove docker \<br>           docker-client \<br>           docker-client-latest \<br>           docker-common \<br>           docker-latest \<br>           docker-latest-logrotate \<br>           docker-logrotate \<br>           docker-selinux \<br>           docker-engine-selinux \<br>           docker-engine<br><span class="hljs-comment"># 卸载新版本的docker（叫docker-ce）</span><br>yum remove docker-ce \<br>           docker-ce-cli \<br>           containerd<br><br><span class="hljs-comment"># 停止删除服务</span><br>systemctl stop docker<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service.d<br><span class="hljs-built_in">rm</span> -rf /etc/systemd/system/docker.service<br><span class="hljs-built_in">rm</span> -rf /var/lib/docker<br><span class="hljs-built_in">rm</span> -rf /var/run/docker<br><span class="hljs-built_in">rm</span> -rf /usr/local/docker<br><span class="hljs-built_in">rm</span> -rf /etc/docker<br><span class="hljs-built_in">rm</span> -rf /usr/bin/docker* /usr/bin/containerd* /usr/bin/runc /usr/bin/ctr<br></code></pre></td></tr></table></figure><p>删除之后再进行<strong>安装</strong>可能会遇到报错</p><p><img src="https://i.imgur.com/k9kZxJn.png" alt="image-20240528220125947"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看冲突的依赖包</span><br>yum list installed | grep docker<br><span class="hljs-comment"># 删除后安装其他指定版本</span><br>rpm -e docker-client.x86_64、rpm -e docker-common.x86_64<br></code></pre></td></tr></table></figure></li></ul><p>​<img src="https://i.imgur.com/6t0ZMvR.png" alt="image-20240528220350909"></p><h2 id="3-Docker的核心架构"><a href="#3-Docker的核心架构" class="headerlink" title="3. Docker的核心架构"></a>3. Docker的核心架构</h2><p><img src="https://i.imgur.com/qULQy2h.png" alt="img"></p><ul><li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li><li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li><li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li><li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li><li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li></ul><h2 id="4-Docker配置阿里云镜像加速"><a href="#4-Docker配置阿里云镜像加速" class="headerlink" title="4. Docker配置阿里云镜像加速"></a>4. Docker配置阿里云镜像加速</h2><ul><li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><code>验证docker的镜像加速是否生效</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br>   Registry Mirrors:<br>    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;<br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5. 常用命令"></a>5. 常用命令</h2><h3 id="5-1-辅助命令"><a href="#5-1-辅助命令" class="headerlink" title="5.1 辅助命令"></a>5.1 辅助命令</h3><pre><code class="hljs">docker version--------------------------查看docker的信息docker info--------------------------查看更详细的信息docker --help--------------------------帮助命令</code></pre><h3 id="5-2-Images-镜像命令"><a href="#5-2-Images-镜像命令" class="headerlink" title="5.2 Images 镜像命令"></a>5.2 Images 镜像命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看本机中所有镜像</span><br>docker images--------------------------列出本地所有镜像<br>-a列出所有镜像（包含中间映像层）<br>  -q只显示镜像<span class="hljs-built_in">id</span><br><span class="hljs-comment"># 2.搜索镜像</span><br>docker search [options] 镜像名-------------------去dockerhub上查询当前镜像<br>-s 指定值列出收藏数不少于指定值的镜像<br>  --no-trunc  显示完整的镜像信息<br><span class="hljs-comment"># 3.从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]----------------- 下载镜像<br><span class="hljs-comment"># 4.删除镜像</span><br>docker rmi 镜像名--------------------------  删除镜像<br>-f强制删除<br></code></pre></td></tr></table></figure><h3 id="5-3-Container命令"><a href="#5-3-Container命令" class="headerlink" title="5.3 Container命令"></a>5.3 Container命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.运行容器</span><br>docker run 镜像名--------------------------镜像名新建并启动容器<br>    --name 别名为容器起一个名字<br>    -d启动守护式容器（在后台启动容器）<br>    -p 映射端口号：原始端口号 指定端口号启动<br><br>例：docker run -it --name myTomcat -p 8888:8080 tomcat<br>    docker run -d --name myTomcat -P tomcat<br><br><span class="hljs-comment"># 2.查看运行的容器</span><br>docker ps--------------------------列出所有正在运行的容器<br>    -a正在运行的和历史运行过的容器<br>    -q静默模式，只显示容器编号<br><br><span class="hljs-comment"># 3.停止|关闭|重启容器</span><br>docker start   容器名字或者容器<span class="hljs-built_in">id</span>  --------------- 开启容器<br>docker restart 容器名或者容器<span class="hljs-built_in">id</span>    --------------- 重启容器<br>docker stop  容器名或者容器<span class="hljs-built_in">id</span>     ------------------ 正常停止容器运行<br>docker <span class="hljs-built_in">kill</span>  容器名或者容器<span class="hljs-built_in">id</span>      ------------------ 立即停止容器运行<br><br><span class="hljs-comment"># 4.删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f 容器<span class="hljs-built_in">id</span>和容器名     <br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)--------------------------删除所有容器<br><br><span class="hljs-comment"># 5.查看容器内进程</span><br>docker top 容器<span class="hljs-built_in">id</span>或者容器名 ------------------ 查看容器内的进程<br><br><span class="hljs-comment"># 6.查看查看容器内部细节</span><br>docker inspect 容器<span class="hljs-built_in">id</span> ------------------ 查看容器内部细节<br><br><span class="hljs-comment"># 7.查看容器的运行日志</span><br>docker logs [OPTIONS] 容器<span class="hljs-built_in">id</span>或容器名------------------ 查看容器日志<br>    -t 加入时间戳<br>    -f 跟随最新的日志打印<br>    --<span class="hljs-built_in">tail</span>  数字显示最后多少条<br><br><span class="hljs-comment"># 8.进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> [options] 容器<span class="hljs-built_in">id</span> 容器内命令 ------------------ 进入容器执行命令<br>-i以交互模式运行容器，通常与-t一起使用<br>    -t分配一个伪终端    shell窗口   bash <br><br><span class="hljs-comment"># 9.容器和宿主机之间复制文件</span><br>docker <span class="hljs-built_in">cp</span> 文件|目录 容器<span class="hljs-built_in">id</span>:容器路径           -----------------   将宿主机复制到容器内部<br>docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上<br><br><span class="hljs-comment"># 10.数据卷(volum)实现与宿主机共享目录</span><br>docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名<br>注意: <br>    1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容<br>    2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中<br><br><span class="hljs-comment"># 11.打包镜像</span><br>docker save 镜像名 -o  名称.tar<br><br><span class="hljs-comment"># 12.载入镜像</span><br>docker load -i   名称.tar<br><br><span class="hljs-comment"># 13.容器打包成新的镜像</span><br>docker commit -m <span class="hljs-string">&quot;描述信息&quot;</span> -a <span class="hljs-string">&quot;作者信息&quot;</span>   （容器<span class="hljs-built_in">id</span>或者名称）打包的镜像名称:标签<br><br><span class="hljs-comment"># 14. 容器重新命名</span><br>docker tag [镜像<span class="hljs-built_in">id</span>] [新镜像名称]:[新镜像标签]<br></code></pre></td></tr></table></figure><h2 id="6-Docker镜像的原理"><a href="#6-Docker镜像的原理" class="headerlink" title="6. Docker镜像的原理"></a>6. Docker镜像的原理</h2><h3 id="6-1-镜像是什么"><a href="#6-1-镜像是什么" class="headerlink" title="6.1 镜像是什么"></a>6.1 镜像是什么</h3><blockquote><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p></blockquote><h3 id="6-2-Docker的镜像原理"><a href="#6-2-Docker的镜像原理" class="headerlink" title="6.2 Docker的镜像原理"></a>6.2 Docker的镜像原理</h3><blockquote><p><strong>docker的镜像实际是由一层一层的文件系统组成。</strong></p></blockquote><ul><li>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</li><li>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</li><li>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</li></ul><p><img src="https://i.imgur.com/mYIKz3o.png" alt="img"></p><p><code>UnionFS</code> (联合文件系统)： Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同的目录挂载到同一个虚拟机文件系统下，Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以用来制作各种具体的应用镜像。</p><p>特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>怎么理解？当我们执行docker pull 的时候会拉取很多模块</p></blockquote><h2 id="7-Docker安装常用服务"><a href="#7-Docker安装常用服务" class="headerlink" title="7. Docker安装常用服务"></a>7. Docker安装常用服务</h2><h3 id="7-1-ETCD"><a href="#7-1-ETCD" class="headerlink" title="7.1 ETCD"></a>7.1 ETCD</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/docker/etcd/data ~/docker/etcd/conf<br><br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/data <br><span class="hljs-built_in">chmod</span> -R 777 ~/docker/etcd/conf<br></code></pre></td></tr></table></figure></li><li><p>准备配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/docker/etcd/conf/etcd.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#成员名称</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">etcd01</span><br><span class="hljs-comment"># 数据保存路径</span><br><span class="hljs-attr">data-dir:</span> <span class="hljs-string">/data</span><br><span class="hljs-comment">#对外提供服务的地址</span><br><span class="hljs-attr">listen-client-urls:</span> <span class="hljs-string">http://0.0.0.0:2379</span><br><span class="hljs-comment">#成员之间通信地址</span><br><span class="hljs-attr">listen-peer-urls:</span> <span class="hljs-string">http://0.0.0.0:2380</span><br><span class="hljs-comment">#此成员的客户端URL列表，用于通告群集的其余部分。这些URL可以包含域名</span><br><span class="hljs-attr">advertise-client-urls:</span> <span class="hljs-string">http://etcd01:2379</span><br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name etcd -p 2379:2379 -p 2380:2380 \<br>-e ALLOW_NONE_AUTHENTICATION=<span class="hljs-built_in">yes</span> \<br>-e ETCD_CONFIG_FILE=/opt/bitnami/etcd/conf/etcd.yml \<br>-v ~/docker/etcd/data:/data \<br>-v ~/docker/etcd/conf:/opt/bitnami/etcd/conf \<br>bitnami/etcd:3.5.9<br></code></pre></td></tr></table></figure></li><li><p>进入 ETCD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -u root -it etcd /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker update --restart=always etcd<br></code></pre></td></tr></table></figure></li><li><p>其他</p><p><a href="https://xie.infoq.cn/link?target=https://github.com/etcd-io/etcd/blob/main/etcd.conf.yml.sample">详细配置文件地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证安装</span><br>etcd --version<br></code></pre></td></tr></table></figure><ol><li><p>增加认证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下命令都需要进入 etcd 容器 shell</span><br>etcdctl user add root --interactive <span class="hljs-comment"># 增加用户 并以命令行形式设置密码</span><br>etcdctl role add root <span class="hljs-comment"># 增加root</span><br>etcdctl user grant-role root root <span class="hljs-comment"># 给 root 设置 root权限</span><br>etcdctl auth <span class="hljs-built_in">enable</span> <span class="hljs-comment"># 开启认证</span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="7-2-MySQL"><a href="#7-2-MySQL" class="headerlink" title="7.2 MySQL"></a>7.2 MySQL</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br></code></pre></td></tr></table></figure></li><li><p>准备挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /root/docker/mysql/data /root/docker/mysql/conf.d:/etc/mysql/conf.d <br></code></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name mysql -v /root/docker/mysql/data:/var/lib/mysql -v /root/docker/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 13306:3306 -d mysql:5.7<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-Nginx"><a href="#7-3-Nginx" class="headerlink" title="7.3 Nginx"></a>7.3 Nginx</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx:latest<br></code></pre></td></tr></table></figure></li><li><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/conf<br><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/log<br><span class="hljs-built_in">mkdir</span> ~/deploy/docker/nginx/html<br></code></pre></td></tr></table></figure></li><li><p>获取 nginx 文件</p><ol><li><p>临时运行一个 <code>nginx</code> 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name nginx -p 9001:80 -d nginx<br></code></pre></td></tr></table></figure></li><li><p>将容器中的文件复制出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/nginx.conf /root/deploy/docker/nginx/conf/nginx.conf<br>docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/conf.d /root/deploy/docker/nginx/conf/conf.d<br>docker <span class="hljs-built_in">cp</span> nginx:/usr/share/nginx/html /root/deploy/docker/nginx<br></code></pre></td></tr></table></figure></li></ol></li><li><p>创建 Nginx 容器并运行</p><ol><li><p>停止之前运行的 <code>nginx</code>容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a | grep nginx<br>docker stop nginx<br>docker <span class="hljs-built_in">rm</span> nginx<br>docker <span class="hljs-built_in">rm</span> -f nginx <span class="hljs-comment"># 删除正在运行的容器</span><br></code></pre></td></tr></table></figure></li><li><p>运行实际的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run \<br>-p 80:80 \<br>--name nginx \<br>-v /root/deploy/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v /root/deploy/docker/nginx/conf/conf.d:/etc/nginx/conf.d \<br>-v /root/deploy/docker/nginx/log:/var/log/nginx \<br>-v /root/deploy/docker/nginx/html:/usr/share/nginx/html \<br>-d nginx:latest<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="8-Dockerfile"><a href="#8-Dockerfile" class="headerlink" title="8. Dockerfile"></a>8. Dockerfile</h2><h3 id="8-1-什么是Dockerfile"><a href="#8-1-什么是Dockerfile" class="headerlink" title="8.1 什么是Dockerfile"></a>8.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p><p><img src="https://i.imgur.com/teEfIcy.png" alt="img"></p><ul><li>通过架构图可以看出Docker file 可以直接构建镜像</li></ul><h3 id="8-2-Docker-file解析过程"><a href="#8-2-Docker-file解析过程" class="headerlink" title="8.2 Docker file解析过程"></a>8.2 Docker file解析过程</h3><p><img src="https://i.imgur.com/4y60ija.png" alt="img"></p><h3 id="8-3-Dockerfile的保留命令"><a href="#8-3-Dockerfile的保留命令" class="headerlink" title="8.3 Dockerfile的保留命令"></a>8.3 Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><table><thead><tr><th align="left">保留字</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left"><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td align="left">MAINTAINER</td><td align="left">镜像维护者的姓名和邮箱地址</td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left"><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left"><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td align="left"><strong>WORKDIR</strong></td><td align="left"><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left"><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td align="left"><strong>ADD</strong></td><td align="left"><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left"><strong>类似于ADD，拷贝文件和目录到镜像中 将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td align="left"><strong>VOLUME</strong></td><td align="left"><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td align="left"><strong>CMD</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left"><strong>指定一个容器启动时要运行的命令 ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><h4 id="8-3-1-FROM-命令"><a href="#8-3-1-FROM-命令" class="headerlink" title="8.3.1 FROM 命令"></a>8.3.1 FROM 命令</h4><ul><li><p>基于哪个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span>  &lt;image&gt;<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest<br><span class="hljs-keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-2-MAINTAINER-命令"><a href="#8-3-2-MAINTAINER-命令" class="headerlink" title="8.3.2 MAINTAINER 命令"></a>8.3.2 MAINTAINER 命令</h4><ul><li><p>镜像维护者的姓名和邮箱地址[废弃]</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-3-RUN-命令"><a href="#8-3-3-RUN-命令" class="headerlink" title="8.3.3 RUN 命令"></a>8.3.3 RUN 命令</h4><ul><li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;<span class="hljs-built_in">command</span>&gt; (shell form, the <span class="hljs-built_in">command</span> is run <span class="hljs-keyword">in</span> a shell, <span class="hljs-built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> hello</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo hello&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-4-EXPOSE-命令"><a href="#8-3-4-EXPOSE-命令" class="headerlink" title="8.3.4 EXPOSE 命令"></a>8.3.4 EXPOSE 命令</h4><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>/udp<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-5-CMD-命令"><a href="#8-3-5-CMD-命令" class="headerlink" title="8.3.5 CMD 命令"></a>8.3.5 CMD 命令</h4><ul><li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p></li><li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (<span class="hljs-built_in">exec</span> form, this is the preferred form)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 (shell form)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-6-WORKDIR-命令"><a href="#8-3-6-WORKDIR-命令" class="headerlink" title="8.3.6 WORKDIR 命令"></a>8.3.6 WORKDIR 命令</h4><ul><li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br>`注意:<span class="hljs-keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-7-ENV-命令"><a href="#8-3-7-ENV-命令" class="headerlink" title="8.3.7 ENV 命令"></a>8.3.7 ENV 命令</h4><ul><li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-8-ADD-命令"><a href="#8-3-8-ADD-命令" class="headerlink" title="8.3.8 ADD 命令"></a>8.3.8 ADD 命令</h4><ul><li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-9-COPY-命令"><a href="#8-3-9-COPY-命令" class="headerlink" title="8.3.9 COPY 命令"></a>8.3.9 COPY 命令</h4><ul><li><p>用来将context目录中指定文件复制到镜像的指定目录中</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-10-VOLUME-命令"><a href="#8-3-10-VOLUME-命令" class="headerlink" title="8.3.10 VOLUME 命令"></a>8.3.10 VOLUME 命令</h4><ul><li><p>用来定义容器运行时可以挂在到宿主机的目录</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-3-11-ENTRYPOINT-命令"><a href="#8-3-11-ENTRYPOINT-命令" class="headerlink" title="8.3.11 ENTRYPOINT 命令"></a>8.3.11 ENTRYPOINT 命令</h4><ul><li><p>用来指定容器启动时执行命令和CMD类似</p></li><li><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="8-4-Dockerfile构建SpringBoot应用"><a href="#8-4-Dockerfile构建SpringBoot应用" class="headerlink" title="8.4 Dockerfile构建SpringBoot应用"></a>8.4 Dockerfile构建SpringBoot应用</h3><ol><li><p>创建Spring Boot应用</p></li><li><p>执行打包命令</p></li><li><p>创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-spring-boot-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-spring-boot-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-springboot-demo .<br></code></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8081:8080 docker-springboot-demo<br></code></pre></td></tr></table></figure></li><li><p>访问项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location <span class="hljs-string">&#x27;http://localhost:8081/index&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker网络"><a href="#9-Docker网络" class="headerlink" title="9. Docker网络"></a>9. Docker网络</h2><p>当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。</p><p>我们在启动docker的时候，主机会有增加一个docker0的网络</p><p><img src="https://i.imgur.com/nZMAhP9.png" alt="image-20240513221855243"></p><blockquote><p>默认网络</p></blockquote><p>安装 Docker 以后，会默认创建三种网络，可以通过 <code>docker network ls</code> 查看。</p><p><img src="https://i.imgur.com/HNAdhQ7.png" alt="image-20240513222000607"></p><ul><li><p>bridge 网络模式</p><p>在该模式中，Docker 守护进程创建了一个虚拟以太网桥 <code>docker0</code>，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包，并为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code></p><p>虚拟网桥，默认为该模式</p></li><li><p>host 网络模式</p><p>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</p></li><li><p>none 网络模式</p><p>容器具有独立的Network namespace, 但并没有对其进行任何网络设置，如分配veth part和网桥连接，IP等</p></li><li><p>container 网络模式</p><p>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</p></li></ul><h3 id="9-1-Docker-网络常用命令"><a href="#9-1-Docker-网络常用命令" class="headerlink" title="9.1 Docker 网络常用命令"></a>9.1 Docker 网络常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network --<span class="hljs-built_in">help</span><br><br>Usage:  docker network COMMAND<br><br>Manage networks<br><br>Commands:<br>  connect     Connect a container to a network<br>  create      Create a network<br>  disconnect  Disconnect a container from a network<br>  inspect     Display detailed information on one or more networks<br>  <span class="hljs-built_in">ls</span>          List networks<br>  prune       Remove all unused networks<br>  <span class="hljs-built_in">rm</span>          Remove one or more networks<br><br>Run <span class="hljs-string">&#x27;docker network COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h3 id="9-2-Docker-网络能干嘛"><a href="#9-2-Docker-网络能干嘛" class="headerlink" title="9.2 Docker 网络能干嘛"></a>9.2 Docker 网络能干嘛</h3><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不收到任何影响</li></ul><h3 id="9-3-Docker-容器之间内部的通信"><a href="#9-3-Docker-容器之间内部的通信" class="headerlink" title="9.3 Docker 容器之间内部的通信"></a>9.3 Docker 容器之间内部的通信</h3><blockquote><p>Tips 通过自建网络实现</p></blockquote><ol><li><p>准备所需要环境</p><p>笔者使用ubuntu镜像实现，需要先拉取对应镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull ubuntu<br>docker images<br></code></pre></td></tr></table></figure><blockquote><p>如果出现docker search 可以使用，docker pull 失败的问题可以尝试看看是否是DNS的问题 &#x2F;etc</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/6BhHiZO.png" alt="image-20240514184217779"></p></li><li><p>创建网络</p><p>如果不清楚docker network命令可以使用<code>docker network --help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create test-network<br></code></pre></td></tr></table></figure><p>创建网络之后执行<code>docker network ls</code>看看是否执行成功</p></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动两个docker容器</span><br>docker run -it --name u1 --network test-network --network-alias ubuntu1  ubuntu bash<br>docker run -it --name u2 --network test-network --network-alias ubuntu2  ubuntu bash<br>   <br></code></pre></td></tr></table></figure><ul><li>–network 指定网络</li><li>–network-alias 指定网络名称（类似于主机名称，后续可以直接通过<code>ping</code>这个主机）</li></ul></li><li><p>安装容器环境</p><p>启动的容器是没有<code>ifconfig</code>,<code>ping</code>这些命令的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install -y net-tools &amp;&amp; apt install -y iputils-ping<br><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>分别启动两个容器，并进入<code>shell</code>，进入容器命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [container_id] bash<br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://i.imgur.com/C9PS4pG.jpeg" alt="image-20240514184129680"></p></li></ol><h2 id="9-Docker-Compose"><a href="#9-Docker-Compose" class="headerlink" title="9. Docker Compose"></a>9. Docker Compose</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><h3 id="9-2-docker-compose-安装"><a href="#9-2-docker-compose-安装" class="headerlink" title="9.2 docker-compose 安装"></a>9.2 docker-compose 安装</h3><blockquote><p>官网： <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>下载地址：<a href="https://docs.docker.com/compose/install">https://docs.docker.com/compose/install</a></p></blockquote><h3 id="9-3-docker-compose"><a href="#9-3-docker-compose" class="headerlink" title="9.3 docker compose"></a>9.3 docker compose</h3><ol><li><p>To download and install Compose standalone, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Apply executable permissions to the standalone binary in the target path for the installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>Test and execute compose commands using <code>docker-compose</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose --version<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/CxmN9fd.png" alt="image-20240514212055991"></p></li></ol><h3 id="9-4-docker-compose常用命令"><a href="#9-4-docker-compose常用命令" class="headerlink" title="9.4 docker-compose常用命令"></a>9.4 docker-compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -h <span class="hljs-comment"># 查看帮助</span><br>docker-compose up <span class="hljs-comment"># 启动所有服务</span><br>docker-compose up -d <span class="hljs-comment"># 启动所有docker-compose服务并后台运行</span><br>docker-compose down <span class="hljs-comment"># 停止并删除容器、网络、卷、镜像</span><br>docker-compose <span class="hljs-built_in">exec</span> [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 进入容器实例内部</span><br>docker-compose ps <span class="hljs-comment"># 展示当前docker-compose编排过的运行的容器</span><br>docker-compose top <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程</span><br><br>docker-compose logs [yml里面的服务<span class="hljs-built_in">id</span>]  <span class="hljs-comment"># 查看容器输出日志</span><br>docker-compose config <span class="hljs-comment"># 检查配置</span><br>docker-compose config -q <span class="hljs-comment"># 检查配置，有问题才输出</span><br>docker-compose restart <span class="hljs-comment"># 重启服务</span><br>docker-compose start <span class="hljs-comment"># 启动服务</span><br>docker-compose stop <span class="hljs-comment"># 停止服务</span><br></code></pre></td></tr></table></figure><h3 id="9-5-docker-compose-使用"><a href="#9-5-docker-compose-使用" class="headerlink" title="9.5 docker-compose 使用"></a>9.5 docker-compose 使用</h3><ol><li><p>构建镜像（基于Spring Boot）</p><ol><li><p>编写代码</p></li><li><p>配置文件修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">docker-compose</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc://mysql:13306/compose?useUnicode=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure></li><li><p>编写Dockerfile、docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /java-demo</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-compose-0.0.1-SNAPSHOT.jar /java-demo</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;docker-compose-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">composeService:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker-compose:1.6</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">dc1.6</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6001:6001&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/java-demo:/java-demo</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="hljs-string">&quot;no&quot;</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">&quot;compose&quot;</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&quot;root&quot;</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/db:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/conf/my.cnf:/etc/my.cnf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/docker/compose/mysql/init:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">compose_net</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span> <span class="hljs-comment"># 解决外部无法访问</span><br><span class="hljs-attr">networks:</span><br>    <span class="hljs-attr">compose_net:</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>上传镜像和相关文件</p></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t docker-compose:1.6 .<br></code></pre></td></tr></table></figure></li><li><p>执行核心操作</p><ul><li>docker-compose up -d</li></ul></li></ol><blockquote><p>总结 尽量不要使用docker-compose 不好用</p></blockquote><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# docker search mysql 或者 docker pull 这些命令无法使用<br>Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid<br></code></pre></td></tr></table></figure><blockquote><p>这个错误的原因是因为系统的时间和docker hub时间不一致，需要做系统时间与网络时间同步</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装时间同步</span><br><span class="hljs-built_in">sudo</span> yum -y install ntp ntpdate<br><span class="hljs-comment"># 2.同步时间</span><br><span class="hljs-built_in">sudo</span> ntpdate cn.pool.ntp.org<br><span class="hljs-comment"># 3.查看本机时间</span><br><span class="hljs-built_in">date</span><br><span class="hljs-comment"># 4.重新测试</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>运维</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flag</title>
    <link href="/2025/05/09/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/flag/"/>
    <url>/2025/05/09/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/flag/</url>
    
    <content type="html"><![CDATA[<h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 常用扩展点</title>
    <link href="/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    <url>/2025/05/09/Java/Spring/Spring%20%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-常用扩展点"><a href="#Spring-常用扩展点" class="headerlink" title="Spring 常用扩展点"></a>Spring 常用扩展点</h1><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><p>这篇文章总结了 <code>Spring</code>所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。</p><h2 id="1-调用顺序"><a href="#1-调用顺序" class="headerlink" title="1. 调用顺序"></a>1. 调用顺序</h2><p>以下按 Spring 容器生命周期阶段分类整理了常见扩展点及其方法，便于理解执行时机和作用。</p><h3 id="🟦-1-容器初始化阶段（ApplicationContext-初始化前）"><a href="#🟦-1-容器初始化阶段（ApplicationContext-初始化前）" class="headerlink" title="🟦 1. 容器初始化阶段（ApplicationContext 初始化前）"></a>🟦 1. 容器初始化阶段（<code>ApplicationContext</code> 初始化前）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ApplicationContextInitializer</code></td><td><code>initialize()</code></td><td>初始化 <code>ApplicationContext</code> 之前执行，通常配合 SpringBoot 使用</td></tr><tr><td><code>AbstractApplicationContext</code></td><td><code>refresh()</code></td><td>启动容器的主流程入口方法</td></tr></tbody></table><hr><h3 id="🟦-2-Bean-定义阶段（Bean-还未实例化）"><a href="#🟦-2-Bean-定义阶段（Bean-还未实例化）" class="headerlink" title="🟦 2. Bean 定义阶段（Bean 还未实例化）"></a>🟦 2. Bean 定义阶段（Bean 还未实例化）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BeanDefinitionRegistryPostProcessor</code></td><td><code>postProcessBeanDefinitionRegistry()</code></td><td>可动态注册&#x2F;修改 Bean 定义</td></tr><tr><td><code>BeanDefinitionRegistryPostProcessor</code></td><td><code>postProcessBeanFactory()</code></td><td>可操作 BeanFactory</td></tr><tr><td><code>BeanFactoryPostProcessor</code></td><td><code>postProcessBeanFactory()</code></td><td>可修改 BeanDefinition 的属性</td></tr></tbody></table><hr><h3 id="🟧-3-Bean-实例化前阶段（对象还没创建）"><a href="#🟧-3-Bean-实例化前阶段（对象还没创建）" class="headerlink" title="🟧 3. Bean 实例化前阶段（对象还没创建）"></a>🟧 3. Bean 实例化前阶段（对象还没创建）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessBeforeInstantiation()</code></td><td>创建实例前，可返回代理对象短路流程</td></tr><tr><td><code>SmartInstantiationAwareBeanPostProcessor</code></td><td><code>determineCandidateConstructors()</code></td><td>决定使用哪个构造函数创建实例</td></tr></tbody></table><h3 id="🟨-4-Bean-实例化后阶段（已创建但未填充属性）"><a href="#🟨-4-Bean-实例化后阶段（已创建但未填充属性）" class="headerlink" title="🟨 4. Bean 实例化后阶段（已创建但未填充属性）"></a>🟨 4. Bean 实例化后阶段（已创建但未填充属性）</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>MergedBeanDefinitionPostProcessor</code></td><td><code>postProcessMergedBeanDefinition()</code></td><td>处理合并后的 Bean 定义，常用于注解支持</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessAfterInstantiation()</code></td><td>实例化后，属性注入前</td></tr><tr><td><code>SmartInstantiationAwareBeanPostProcessor</code></td><td><code>getEarlyBeanReference()</code></td><td>提供早期引用，解决循环依赖</td></tr><tr><td><code>BeanFactoryAware</code></td><td><code>setBeanFactory()</code></td><td>注入 <code>BeanFactory</code> 实例</td></tr></tbody></table><hr><h3 id="🟩-5-属性注入和初始化阶段"><a href="#🟩-5-属性注入和初始化阶段" class="headerlink" title="🟩 5. 属性注入和初始化阶段"></a>🟩 5. 属性注入和初始化阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessPropertyValues()</code></td><td>属性填充时调用</td></tr><tr><td><code>ApplicationContextAwareProcessor</code></td><td><code>invokeAwareInterfaces()</code></td><td>注入如 <code>ApplicationContext</code>, <code>BeanName</code> 等 Aware 接口</td></tr><tr><td><code>BeanNameAware</code></td><td><code>setBeanName()</code></td><td>注入当前 Bean 的名称</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessBeforeInitialization()</code></td><td>初始化方法调用前</td></tr><tr><td><code>@PostConstruct</code></td><td>注解方法</td><td>初始化注解（JSR-250）</td></tr><tr><td><code>InitializingBean</code></td><td><code>afterPropertiesSet()</code></td><td>初始化回调</td></tr><tr><td><code>InstantiationAwareBeanPostProcessor</code></td><td><code>postProcessAfterInitialization()</code></td><td>初始化方法调用后，常用于生成代理</td></tr></tbody></table><hr><h3 id="🟦-6-特殊-Bean-处理阶段"><a href="#🟦-6-特殊-Bean-处理阶段" class="headerlink" title="🟦 6. 特殊 Bean 处理阶段"></a>🟦 6. 特殊 Bean 处理阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>FactoryBean</code></td><td><code>getObject()</code></td><td>提供特殊 Bean 的工厂接口</td></tr><tr><td><code>SmartInitializingSingleton</code></td><td><code>afterSingletonsInstantiated()</code></td><td>所有单例对象初始化完毕后执行</td></tr></tbody></table><hr><h3 id="🟥-7-应用运行与销毁阶段"><a href="#🟥-7-应用运行与销毁阶段" class="headerlink" title="🟥 7. 应用运行与销毁阶段"></a>🟥 7. 应用运行与销毁阶段</h3><table><thead><tr><th>扩展点</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>CommandLineRunner</code></td><td><code>run()</code></td><td>SpringBoot 启动后立即执行逻辑</td></tr><tr><td><code>DisposableBean</code></td><td><code>destroy()</code></td><td>Bean 销毁回调方法，容器关闭时触发</td></tr></tbody></table><h2 id="2-常用扩展点示例"><a href="#2-常用扩展点示例" class="headerlink" title="2. 常用扩展点示例"></a>2. 常用扩展点示例</h2><h3 id="1-ApplicationContextInitializer"><a href="#1-ApplicationContextInitializer" class="headerlink" title="1. ApplicationContextInitializer"></a>1. ApplicationContextInitializer</h3><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。<br>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><p><strong>扩展方式为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[ApplicationContextInitializer]&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><p>这个接口可以在 Spring Boot 等基于 Spring 框架的应用中使用，用于在应用启动时进行一些配置或初始化操作，例如加载配置文件、设置系统属性、注册自定义的 Bean 等。</p><h3 id="2-BeanDefinitionRegistryPostProcessor"><a href="#2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="2. BeanDefinitionRegistryPostProcessor"></a>2. BeanDefinitionRegistryPostProcessor</h3><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。<br>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><p>这个接口可以在 Spring Boot 等基于 Spring 框架的应用中使用，用于在应用启动时进行一些配置或初始化操作，例如加载配置文件、设置系统属性、注册自定义的 Bean 等。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[ApplicationContextInitializer]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li>在启动类中用springApplication.addInitializers(new TestApplicationContextInitializer())语句加入</li><li>配置文件配置context.initializer.classes&#x3D;com.example.demo.TestApplicationContextInitializer</li><li>Spring SPI扩展，在spring.factories中加入org.springframework.context.ApplicationContextInitializer&#x3D;com.example.demo.TestApplicationContextInitializer</li></ul><h3 id="3-BeanDefinitionRegistryPostProcessor"><a href="#3-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3. BeanDefinitionRegistryPostProcessor"></a>3. BeanDefinitionRegistryPostProcessor</h3><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点</p><p>使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean</p><p>扩展方式为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;</span>);    <br>    &#125;    <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="4-BeanFactoryPostProcessor"><a href="#4-BeanFactoryPostProcessor" class="headerlink" title="4. BeanFactoryPostProcessor"></a>4. BeanFactoryPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanFactoryPostProcessor]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="5-InstantiationAwareBeanPostProcessor"><a href="#5-InstantiationAwareBeanPostProcessor" class="headerlink" title="5. InstantiationAwareBeanPostProcessor"></a>5. InstantiationAwareBeanPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了BeanPostProcess接口，区别如下：</p><p>BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：实例化阶段和初始化阶段，下面一起进行说明，按调用顺序为：</p><ul><li>postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前</li><li>postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后</li><li>postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现</li><li>postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前</li><li>postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后</li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InstantiationAwareBeanPostProcessor</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> pvs;    <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-SmartInstantiationAwareBeanPostProcessor"><a href="#6-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="6. SmartInstantiationAwareBeanPostProcessor"></a>6. SmartInstantiationAwareBeanPostProcessor</h3><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li>predictBeanType：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li><li>determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li><li>getEarlyBeanReference：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</li></ul><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInstantiationAwareBeanPostProcessor</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> beanClass;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot;</span> + beanName);    <br>        <span class="hljs-keyword">return</span> bean;    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="7-BeanFactoryAware"><a href="#7-BeanFactoryAware" class="headerlink" title="7. BeanFactoryAware"></a>7. BeanFactoryAware</h3><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanFactoryAware</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestBeanFactoryAware] &quot;</span> + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());    <br>    &#125;    <br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="8-ApplicationContextAwareProcessor"><a href="#8-ApplicationContextAwareProcessor" class="headerlink" title="8. ApplicationContextAwareProcessor"></a>8. ApplicationContextAwareProcessor</h3><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p>图片<br>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。所以这里应该来说是有6个扩展点，这里就放一起来说了</p><ul><li>EnvironmentAware：用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li><li>EmbeddedValueResolverAware：用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。</li><li>ResourceLoaderAware：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li><li>ApplicationEventPublisherAware：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。</li></ul><p>MessageSourceAware：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</p><p>ApplicationContextAware：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。</p><h3 id="9-BeanNameAware"><a href="#9-BeanNameAware" class="headerlink" title="9. BeanNameAware"></a>9. BeanNameAware</h3><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName</p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>&#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NormalBeanA</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;NormalBean constructor&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[BeanNameAware] &quot;</span> + name);    <br>    &#125;    <br>&#125;   <br></code></pre></td></tr></table></figure><h3 id="10-PostConstruct"><a href="#10-PostConstruct" class="headerlink" title="10. @PostConstruct"></a>10. @PostConstruct</h3><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NormalBeanA</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;NormalBean constructor&quot;</span>);    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@PostConstruct</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;    <br>        System.out.println(<span class="hljs-string">&quot;[PostConstruct] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="11-InitializingBean"><a href="#11-InitializingBean" class="headerlink" title="11. InitializingBean"></a>11. InitializingBean</h3><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>&#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[InitializingBean] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="12-FactoryBean"><a href="#12-FactoryBean" class="headerlink" title="12. FactoryBean"></a>12. FactoryBean</h3><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。</p><p>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。扩展：SpringBoot内容聚合</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> TestFactoryBean.TestFactoryInnerBean <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[FactoryBean] getObject&quot;</span>);    <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestFactoryBean</span>.TestFactoryInnerBean();    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;    <br>        <span class="hljs-keyword">return</span> TestFactoryBean.TestFactoryInnerBean.class;    <br>    &#125;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>    &#125;    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFactoryInnerBean</span>&#123;    <br>    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-SmartInitializingSingleton"><a href="#13-SmartInitializingSingleton" class="headerlink" title="13. SmartInitializingSingleton"></a>13. SmartInitializingSingleton</h3><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法afterSingletonsInstantiated，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为postProcessAfterInitialization之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSmartInitializingSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInitializingSingleton</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestSmartInitializingSingleton]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="14-CommandLineRunner"><a href="#14-CommandLineRunner" class="headerlink" title="14. CommandLineRunner"></a>14. CommandLineRunner</h3><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：run(String… args)，触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;    <br>    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[TestCommandLineRunner]&quot;</span>);    <br>    &#125;    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="15-DisposableBean"><a href="#15-DisposableBean" class="headerlink" title="15. DisposableBean"></a>15. DisposableBean</h3><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：destroy()，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。</p><p>扩展方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBeanA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisposableBean</span> &#123;    <br>    <span class="hljs-meta">@Override</span>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        System.out.println(<span class="hljs-string">&quot;[DisposableBean] NormalBeanA&quot;</span>);    <br>    &#125;    <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="16-ApplicationListener"><a href="#16-ApplicationListener" class="headerlink" title="16.ApplicationListener"></a>16.ApplicationListener</h3><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，ApplicationListener可以监听某个事件的event，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。</p><p>但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li><p>ContextRefreshedEvent</p><p>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。</p></li><li><p>ContextStartedEvent</p><p>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent</p><p>当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p></li><li><p>ContextClosedEvent</p><p>当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p></li><li><p>RequestHandledEvent</p><p>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC</title>
    <link href="/2024/12/01/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/"/>
    <url>/2024/12/01/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/gRPC/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="gRPC-介绍"><a href="#gRPC-介绍" class="headerlink" title="gRPC 介绍"></a>gRPC 介绍</h2><p>gPRC 官网（<a href="https://grpc.io/%EF%BC%89%E4%B8%8A%E7%9A%84">https://grpc.io/）上的</a> Slogan 是：A high performance, open source universal RPC framework。就是：一个高性能、开源的通用 RPC 框架。</p><p>支持多数主流语言：C#、C++、Dart、<strong>Go</strong>、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby。其中 Go 支持 Windows, Linux, Mac 上的 Go 1.13+ 版本。</p><p>gRPC 是一个 Google 开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一步，将设备、移动应用程序和浏览器与后端服务接。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 <code>goctl</code> 可以一键安装 <code>protoc</code>，<code>protoc-gen-go</code>，<code>protoc-gen-go-grpc</code> 相关组件，你可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsh">goctl env check --install --verbose --force<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h3><p>默认情况下，gRPC 使用 Protocol Buffers，这是 Google 用于序列化结构化数据的成熟开源机制（尽管它可以与 JSON 等其他数据格式一起使用）。</p><blockquote><p>Protocol Buffers 的文档：<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p></blockquote><p>使用 Protocol Buffers 的基本步骤是</p><ol><li>使用 protocol buffers 语法定义消息，消息是用于传递的数据</li><li>使用 protocol buffers 语法定义服务，服务是 RPC 方法的集合，来使用消息</li><li>使用 Protocol Buffer编 译工具 <code>protoc</code> 来编译，生成对应语言的代码，例如 Go 的代码</li></ol><p>使用 Protocol Buffers 的第一步是在 <code>.proto</code> 文件中定义序列化的数据的结构，.proto 文件是普通的文本文件。Protocol Buffers 数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的 name-value 对。</p><p>除了核心内容外，<code>.proto</code> 文件还需要指定语法版本，目前主流的也是最新的 proto3 版本。在 <code>.proto</code> 文件的开头指定。</p><p>一个简单的产品信息示例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> user; <span class="hljs-comment">// 默认包名</span><br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./user&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserReq</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">GetUserResp</span> &#123;<br>    <span class="hljs-type">string</span> id = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">string</span> phone = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetUser(GetUserReq) <span class="hljs-keyword">returns</span> (GetUserResp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>protoc</code> 工具将 <code>.proto</code> 定义的消息和包含 rpc 方法的服务编译为目标语言的代码，我们选择 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --go-grpc_out=. --go_out=. ./user.proto<br><span class="hljs-comment"># --go_out *.pb.go 目录</span><br><span class="hljs-comment"># --go-grpc_out *_grpc.pb.go 目录</span><br></code></pre></td></tr></table></figure><h4 id="消息类型的定义"><a href="#消息类型的定义" class="headerlink" title="消息类型的定义"></a>消息类型的定义</h4><p>以一个简单的请求消息为例：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先指定版本 proto3，否则编译器默认为 proto2。版本指定为文件的第一非空白、非注释行。</p><p>message 关键字用于定义消息，需要指定消息类型的名称。</p><p>消息由多个名称&#x2F;值对组成，称为字段，每个字段要指定名字和类型。string、int32 是典型的标量类型，除了标量类型 protobuf 还支持构造类型，例如枚举或其他消息类型。</p><p>应该为每个字段分配唯一的字段序号，用于在二进制编码中标识该字段。序号范围1-15会消耗1个字节的存储，16-2047 会消耗2个字节。因此应该将常用的字段分配1-15字段序号。编号全部的范围是1到2^29-1，其中19000到19999是 proto编译器保留序号，不要使用。</p><p>消息的字段分为单一和重复两种规则：</p><ul><li><p>单一 Singular，proto3 中字段的默认规则。一个消息中仅可以包含0或1个该字段，就是字段不能重复。</p></li><li><p>重复的 repeated，该规则说明此字段可以重复多次（包含0次）。重复值的顺序是保留的。</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> keywords = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>.proto</code> 文件支持 C&#x2F;C++ 风格的注释 <code>//</code> 和 <code>/* ... */</code></p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量消息字段可以具有以下类型之一。该表显示了 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p><table><thead><tr><th align="left">.proto Type</th><th>说明</th><th align="left">Go Type</th></tr></thead><tbody><tr><td align="left">double</td><td></td><td align="left">float64</td></tr><tr><td align="left">float</td><td></td><td align="left">float32</td></tr><tr><td align="left">int32</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint32</td><td align="left">int32</td></tr><tr><td align="left">int64</td><td>变长编码，对负数进行编码效率低下。若字段可能有负值，请改用 sint64</td><td align="left">int64</td></tr><tr><td align="left">uint32</td><td>变长编码</td><td align="left">uint32</td></tr><tr><td align="left">uint64</td><td>变长编码</td><td align="left">uint64</td></tr><tr><td align="left">sint32</td><td>变长编码，带符号的 int 值。这些比常规 int32 更有效地编码负数</td><td align="left">int32</td></tr><tr><td align="left">sint64</td><td>变长编码，带符号的 int 值。这些比常规 int64 更有效地编码负数</td><td align="left">int64</td></tr><tr><td align="left">fixed32</td><td>固定4个字节，如果值通常大于 2^28，则比 uint32 更有效</td><td align="left">uint32</td></tr><tr><td align="left">fixed64</td><td>固定8个字节，如果值通常大于 2^56，则比 uint64 更有效</td><td align="left">uint64</td></tr><tr><td align="left">sfixed32</td><td>固定4个字节</td><td align="left">int32</td></tr><tr><td align="left">sfixed64</td><td>固定8个字节</td><td align="left">int64</td></tr><tr><td align="left">bool</td><td></td><td align="left">bool</td></tr><tr><td align="left">string</td><td>始终包含 UTF-8 编码或 7 位 ASCII 文本，并且长度不能超过 2^32</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td>可以包含不超过 2^32 的任意字节序列</td><td align="left">[]byte</td></tr></tbody></table><p>解析消息时，如果编码的消息不包含特定元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是基于类型的：</p><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数字类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，必须为 0。</li><li>对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参阅生成的代码指南。</li><li>重复字段的默认值为空（通常是相应语言的空列表）。</li></ul><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>在定义消息类型时，您可能希望其字段之一仅具有预定义的值列表之一。例如，假设您要为每个 SearchRequest 添加一个 <code>corpus</code> 字段，其中值可以是 UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS 或 VIDEO。您可以通过在消息定义中添加一个枚举来非常简单地做到这一点，每个可能的值都有一个常量。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-comment">// 同上略</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  Corpus corpus = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值列表的第一常量值必须为0，这样可以更好的处理默认值。（也为了向下兼容）</p><p>也可以为同一个枚举值分配不同的常量，称为别名。需要使用选项 <code>option allow_alias = true</code> 来启用别名设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">MyMessage1</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">EnumAllowingAlias</span> &#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<br>    UNKNOWN = <span class="hljs-number">0</span>;<br>    STARTED = <span class="hljs-number">1</span>;<br>    RUNNING = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h5><p>当某些字段不再使用时，例如更新消息类型时移除了某些字段，为了防止其他人重新使用了之前的字段名或字段序号而导致逻辑混乱的问题，可以把这些不用的字段设置为保留字段，关键字 <code>reserved</code> 用来设置：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;<br>  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，以上的序号和字段名就不能后续使用了，避免了逻辑混乱。</p><h5 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将不同类型的消息定义在不同的 .proto 文件中，需要时导入进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">import &quot;myproject/other_protos.proto&quot;;<br></code></pre></td></tr></table></figure><h5 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h5><p>未知字段是格式良好的 Protocol Buffer 序列化数据，表示解析器无法识别的字段。例如，当旧二进制文件用新字段解析新二进制文件发送的数据时，这些新字段将成为旧二进制文件中的未知字段。</p><p>最初，proto3 消息在解析过程中总是丢弃未知字段，但在 3.5 版本中，我们重新引入了保留未知字段以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析期间保留并包含在序列化输出中。</p><h5 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h5><p>Any 消息类型允许您将消息用作嵌入类型，而无需定义它们的 .proto。 Any 包含作为 <code>Bytes</code> 的任意序列化消息，以及充当全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要导入 google&#x2F;protobuf&#x2F;any.proto。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ErrorStatus</span> &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">repeated</span> google.protobuf.Any details = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Onef"><a href="#Onef" class="headerlink" title="Onef"></a>Onef</h5><p>如果您有一条包含多个字段的消息，并且最多同时设置一个字段，您可以强制执行此行为并使用 <code>oneof</code> 功能节省内存。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SampleMessage</span> &#123;<br>  <span class="hljs-keyword">oneof</span> test_oneof &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">4</span>;<br>    SubMessage sub_message = <span class="hljs-number">9</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>如果您想创建关联映射作为数据定义的一部分，protocol buffers 提供了一种方便的快捷语法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;<span class="hljs-type">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="语法指导"><a href="#语法指导" class="headerlink" title="语法指导"></a>语法指导</h4><h5 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h5><p>您可以将可选的 <code>package</code> 说明符添加到 .proto 文件中，以防止协议消息类型之间的名称冲突。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> foo.bar;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Open</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>在 GO 中，该软件包被用作 GO 软件包名称，除非您在 .proto 文件中明确提供 <code>option go_package</code>。</p><h5 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h5><p>如果您想在 RPC（远程过程调用）系统中使用您的消息类型，您可以在 .proto 文件中定义一个 RPC 服务接口，并且协议缓冲区编译器将以您选择的语言生成服务接口代码和存根。因此，例如，如果您想使用获取 SearchRequest 并返回 SearchResponse 的方法定义 RPC 服务，您可以在 .proto 文件中定义它，如下所示：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 Proto Buffers 一起使用的最直接的 RPC 系统是 gRPC：由 Google 开发的一种语言和平台中立的开源 RPC 系统。 gRPC 特别适用于协议缓冲区，并允许您使用特殊的协议缓冲区编译器插件直接从 .proto 文件生成相关的 RPC 代码。</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>.proto 文件中支持定义选项。全部的选项定义在 <code>google/protobuf/descriptor.proto</code> 中。</p><p>例如我们使用 option go_package 选项来控制生成的 go 代码所在的 package。</p><h3 id="gRPC-支持四种定义服务的方法"><a href="#gRPC-支持四种定义服务的方法" class="headerlink" title="gRPC 支持四种定义服务的方法"></a>gRPC 支持四种定义服务的方法</h3><h4 id="一元-RPC"><a href="#一元-RPC" class="headerlink" title="一元 RPC"></a>一元 RPC</h4><p>首先考虑最简单的 RPC 类型，其中客户端发送单个请求并返回单个响应。</p><ol><li>一旦客户端调用了一个存根方法，服务器就会被通知该 RPC 已被调用，其中包含该调用的客户端元数据、方法名称和指定的截止日期（如果适用）。</li><li>然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。</li><li>一旦服务器收到客户端的请求消息，它就会执行任何必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选状态消息）和可选尾随元数据一起返回（如果成功）给客户端。</li><li>如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。</li></ol><blockquote><p>一元  RPC，其中客户端向服务器发送单个请求并获得单个响应，就像正常的函数调用一样</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="服务器流式-RPC"><a href="#服务器流式-RPC" class="headerlink" title="服务器流式 RPC"></a>服务器流式 RPC</h4><p>服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有所有服务器消息后完成。</p><blockquote><p>服务器流式 RPC，其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 gRPC 保证单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfReplies(HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h4><p>客户端流式 RPC 类似于一元 RPC，不同之处在于客户端向服务器发送消息流而不是单个消息。服务器响应一条消息（连同其状态详细信息和可选的尾随元数据），通常但不一定是在它收到所有客户端的消息之后</p><blockquote><p>客户端流式 RPC，其中客户端写入一系列消息并将它们发送到服务器，再次使用提供的流。一旦客户端完成了消息的写入，它就会等待服务器读取它们并返回它的响应。 gRPC 再次保证了单个 RPC 调用中的消息顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> LotsOfGreetings(stream HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br></code></pre></td></tr></table></figure><h4 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h4><p>在双向流式 RPC 中，调用由调用方法的客户端和接收客户端元数据、方法名称和截止日期的服务器发起。服务器可以选择发回其初始元数据或等待客户端开始流式传输消息。</p><p>客户端和服务器端流处理是特定于应用程序的。<strong>由于这两个流是独立的，客户端和服务器可以以任意顺序读写消息</strong>。例如，服务器可以等到它收到客户端的所有消息后再写入它的消息，或者服务器和客户端可以玩 “ping-pong”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。</p><blockquote><p>双向流式 RPC，双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。保留每个流中消息的顺序。</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> BidiHello(stream HelloRequest) <span class="hljs-keyword">returns</span> (stream HelloResponse)</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期指的是 gRPC 客户端调用 gRPC 服务端方法的过程。区别于不同的4种服务定义，过程如下：</p><h4 id="截止日期-超时"><a href="#截止日期-超时" class="headerlink" title="截止日期&#x2F;超时"></a>截止日期&#x2F;超时</h4><p>gRPC 允许客户端指定在 RPC 因 DEADLINE_EXCEEDED 错误而终止之前，他们愿意等待 RPC 完成多长时间。在服务器端，服务器可以查询特定的 RPC 是否已超时，或者还剩多少时间来完成 RPC。指定期限或超时是特定于语言的：一些语言 API 根据超时（持续时间）工作，而一些语言 API 根据期限（固定时间点）工作，可能有也可能没有默认期限。</p><h4 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h4><p>在 gRPC 中，客户端和服务器都对调用是否成功做出独立的本地判断，并且它们的结论可能不匹配。这意味着，例如，您可能有一个 RPC 在服务器端成功完成（“我已经发送了所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务器也可以在客户端发送所有请求之前决定完成。</p><h4 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h4><p>客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，以便不再进行任何工作。</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><blockquote><p> http2 是 gRPC 中的关键协议</p></blockquote><h3 id="HTTP1-存在的问题"><a href="#HTTP1-存在的问题" class="headerlink" title="HTTP1 存在的问题"></a>HTTP1 存在的问题</h3><ul><li>低效的 TCP 利用<ul><li>连接是一次性的，不能重复使用</li></ul></li><li>臃肿的消息首部<ul><li>请求行（url、请求头、版本）</li><li>首部行</li><li>空行</li><li>实体主体</li></ul></li><li>明文传输<ul><li>可以通过加 SSL 证书，将请求转成 HTTPS</li></ul></li><li>传输效率低</li></ul><h3 id="HTP2-改进的地方"><a href="#HTP2-改进的地方" class="headerlink" title="HTP2 改进的地方"></a>HTP2 改进的地方</h3><ul><li><p>传输的改进</p><ul><li>HTTP1 中一次处理一个请求，并且不能停止解析</li><li>HTTP1 中对于服务端来说无法预判使用多少内存</li><li>HTTP1 冗余过多的 LF 分隔符</li><li>HTTP2 中tcp连接之后不会断掉<ul><li>会将一次请求分成一定数量的帧，给关键帧打上标识，然后客户端会根据这些标识组装数据</li></ul></li></ul></li><li><p>请求头优化</p><ul><li><p>HTTP1 是属于无状态的，每次都需要将所有请求头发送到服务方（ http2 在将请求头帧发送到服务后，后续的帧只会发送不同的东西）</p><p><img src="https://i.imgur.com/qqbaMCU.png" alt="image-20241031212104738"></p></li><li><p>多路复用</p><ul><li>HTTP1 连接是一次性的，打开一个网页会发起多次请求，每个请求完之后就会关闭</li><li>HTTP2 在请求过程中只会建立一次连接，后续的请求都可以通过这个连接进行发送</li></ul></li><li><p>服务端可推送</p><ul><li><p>HTTP1 不支持</p></li><li><p>HTTP2 服务端与客户端会保持长连接</p></li></ul></li></ul></li></ul><h2 id="gRPC-实战"><a href="#gRPC-实战" class="headerlink" title="gRPC 实战"></a>gRPC 实战</h2><h3 id="gRPC-的服务端连接调度实现原理分析"><a href="#gRPC-的服务端连接调度实现原理分析" class="headerlink" title="gRPC 的服务端连接调度实现原理分析"></a>gRPC 的服务端连接调度实现原理分析</h3><h4 id="自定义服务加载"><a href="#自定义服务加载" class="headerlink" title="自定义服务加载"></a>自定义服务加载</h4><p><img src="https://i.imgur.com/DW8LO8s.png" alt="image-20241031212647536"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User_ServiceDesc is the grpc.ServiceDesc for User service.</span><br><span class="hljs-comment">// It&#x27;s only intended for direct use with grpc.RegisterService,</span><br><span class="hljs-comment">// and not to be introspected or modified (even as a copy)</span><br><span class="hljs-keyword">var</span> User_ServiceDesc = grpc.ServiceDesc&#123;<br>    ServiceName: <span class="hljs-string">&quot;user.User&quot;</span>,<br>    HandlerType: (*UserServer)(<span class="hljs-literal">nil</span>),<br>    Methods: []grpc.MethodDesc&#123;<br>       &#123;<br>          MethodName: <span class="hljs-string">&quot;GetUser&quot;</span>,<br>          Handler:    _User_GetUser_Handler,<br>       &#125;,<br>    &#125;,<br>    Streams:  []grpc.StreamDesc&#123;&#125;,<br>    Metadata: <span class="hljs-string">&quot;user.proto&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">User_GetUser_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    in := <span class="hljs-built_in">new</span>(GetUserReq)<br>    <span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, in)<br>    &#125;<br>    info := &amp;grpc.UnaryServerInfo&#123;<br>       Server:     srv,<br>       FullMethod: User_GetUser_FullMethodName,<br>    &#125;<br>    handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>       <span class="hljs-keyword">return</span> srv.(UserServer).GetUser(ctx, req.(*GetUserReq))<br>    &#125;<br>    <span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br><br><span class="hljs-comment">// RegisterService registers a service and its implementation to the gRPC</span><br><span class="hljs-comment">// server. It is called from the IDL generated code. This must be called before</span><br><span class="hljs-comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span><br><span class="hljs-comment">// ensure it implements sd.HandlerType.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> RegisterService(sd *ServiceDesc, ss any) &#123;<br>    <span class="hljs-keyword">if</span> ss != <span class="hljs-literal">nil</span> &#123;<br>       ht := reflect.TypeOf(sd.HandlerType).Elem()<br>       st := reflect.TypeOf(ss)<br>       <span class="hljs-keyword">if</span> !st.Implements(ht) &#123;<br>          logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)<br>       &#125;<br>    &#125;<br>    s.register(sd, ss)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> register(sd *ServiceDesc, ss any) &#123;<br>    s.mu.Lock()<br>    <span class="hljs-keyword">defer</span> s.mu.Unlock()<br>    s.printf(<span class="hljs-string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)<br>    <span class="hljs-keyword">if</span> s.serve &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    <span class="hljs-keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;<br>       logger.Fatalf(<span class="hljs-string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)<br>    &#125;<br>    info := &amp;serviceInfo&#123;<br>       serviceImpl: ss,<br>       methods:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*MethodDesc),<br>       streams:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*StreamDesc),<br>       mdata:       sd.Metadata,<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Methods &#123;<br>       d := &amp;sd.Methods[i]<br>       info.methods[d.MethodName] = d<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sd.Streams &#123;<br>       d := &amp;sd.Streams[i]<br>       info.streams[d.StreamName] = d<br>    &#125;<br>    s.services[sd.ServiceName] = info<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a>服务初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">s := grpc.NewServer()<br><br><br><br><span class="hljs-comment">// NewServer creates a gRPC server which has no service registered and has not</span><br><span class="hljs-comment">// started to accept requests yet.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opt ...ServerOption)</span></span> *Server &#123;<br>    opts := defaultServerOptions<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> globalServerOptions &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opt &#123;<br>       o.apply(&amp;opts)<br>    &#125;<br>    s := &amp;Server&#123;<br>       lis:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[net.Listener]<span class="hljs-type">bool</span>),<br>       opts:     opts,<br>       conns:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[transport.ServerTransport]<span class="hljs-type">bool</span>),<br>       services: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*serviceInfo),<br>       quit:     grpcsync.NewEvent(),<br>       done:     grpcsync.NewEvent(),<br>       channelz: channelz.RegisterServer(<span class="hljs-string">&quot;&quot;</span>),<br>    &#125;<br>    chainUnaryServerInterceptors(s)<br>    chainStreamServerInterceptors(s)<br>    s.cv = sync.NewCond(&amp;s.mu)<br>    <span class="hljs-keyword">if</span> EnableTracing &#123;<br>       _, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>       s.events = newTraceEventLog(<span class="hljs-string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line))<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> s.opts.numServerWorkers &gt; <span class="hljs-number">0</span> &#123;<br>       s.initServerWorkers()<br>    &#125;<br><br>    channelz.Info(logger, s.channelz, <span class="hljs-string">&quot;Server created&quot;</span>)<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrInterceptor</span><span class="hljs-params">(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp any, err <span class="hljs-type">error</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;err begin&quot;</span>)<br>    resp, err = handler(ctx, req)<br>    fmt.Println(<span class="hljs-string">&quot;err end&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br><br>    s := grpc.NewServer(grpc.ChainUnaryInterceptor(interceptor.LogInterceptor, interceptor.ErrInterceptor))<br>    user.RegisterUserServer(s, <span class="hljs-built_in">new</span>(UserService))<br>    log.Println(<span class="hljs-string">&quot;启动成功&quot;</span>)<br>    err = s.Serve(listener)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="请求监听处理"><a href="#请求监听处理" class="headerlink" title="请求监听处理"></a>请求监听处理</h4><p><img src="https://i.imgur.com/ImC3Tbc.png" alt="image-20241031212849420"></p><h3 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h3><blockquote><p>对 go-zero的安装不做赘述</p></blockquote><h4 id="实践-go-zero-基础功能案例（api-rpc）"><a href="#实践-go-zero-基础功能案例（api-rpc）" class="headerlink" title="实践 go-zero 基础功能案例（api&#x2F;rpc）"></a>实践 go-zero 基础功能案例（api&#x2F;rpc）</h4><ol><li><p>编写.proto文件</p></li><li><p>构建 rpc 服务</p></li><li><p>编写 api 文件</p><ol><li><p>构建 api 服务</p><ol><li><p>构建 rpc 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl rpc new user<br></code></pre></td></tr></table></figure></li><li><p>构建 api 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl api new api<br></code></pre></td></tr></table></figure></li><li><p>一般情况是编写 <code>.api</code> 文件和编写 <code>.proto</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">      goctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.<br>      goctl api go -api user.api -<span class="hljs-built_in">dir</span> . -style gozero<br><br>2. 服务联调<br><br>   ```yaml<br>   <span class="hljs-comment"># api etc user.yaml</span><br>   Name: User<br>   Host: 0.0.0.0<br>   Port: 8888<br>   <br>   UserRpc:<br>     Etcd:<br>       Hosts:<br>         - 117.50.179.8:2379<br>       Key: user.rpc<br>       User: <span class="hljs-string">&quot;root&quot;</span><br>       Pass: <span class="hljs-string">&quot;fghf987....&quot;</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// internal config config.go</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>rest.RestConf<br><br>UserRpc zrpc.RpcClientConf<br>&#125;<br><br><br><span class="hljs-comment">// svc servicecontext.go</span><br><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>Config     config.Config<br>UserClient userclient.User<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceContext</span><span class="hljs-params">(c config.Config)</span></span> *ServiceContext &#123;<br><span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>Config:     c,<br>UserClient: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// logic userlogic.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *UserLogic)</span></span> User(req *types.UserReq) (resp *types.UserResp, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// todo: add your logic here and delete this line</span><br>getUserResp, err := l.svcCtx.UserClient.GetUser(l.ctx, &amp;user.GetUserReq&#123;<br>Id: req.Id,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;types.UserResp&#123;<br>Id:    getUserResp.Id,<br>Name:  getUserResp.Name,<br>Phone: getUserResp.Phone,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><ol><li><p>编写 <em>.sql</em> 文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `<span class="hljs-keyword">user</span>` (<br>                        `id` <span class="hljs-type">BIGINT</span> UNSIGNED AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用户ID，主键&#x27;</span>,<br>                        `username` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>                        `email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;电子邮箱&#x27;</span>,<br>                        `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;密码（加密存储）&#x27;</span>,<br>                        `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>                        `status` TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态：1=启用，0=禁用&#x27;</span>,<br>                        `created_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>                        `updated_at` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>                        <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>生成 model</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">goctl model mysql ddl --src user.sql --<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;./models/&quot;</span> -c<br></code></pre></td></tr></table></figure><p><code>-c</code>表示使用缓存</p></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><p>core</p><p>工具集包含数据处理、熔断器、服务发现等工具</p></li><li><p>internal</p><p>包含框架处理、请求编码、健康检测等功能</p></li><li><p>zrpc</p><p>是rpc服务端与客户端的核心代码</p></li></ul><h5 id="go-zero-如何适配grpc"><a href="#go-zero-如何适配grpc" class="headerlink" title="go-zero 如何适配grpc"></a>go-zero 如何适配grpc</h5><h5 id="服务如何初始化"><a href="#服务如何初始化" class="headerlink" title="服务如何初始化"></a>服务如何初始化</h5><h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2024/10/31/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/"/>
    <url>/2024/10/31/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="golang中的-RPC"><a href="#golang中的-RPC" class="headerlink" title="golang中的 RPC"></a>golang中的 RPC</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;errors&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id,omitempty&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name,omitempty&quot;`</span><br>    Phone <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;phone&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> users = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*User&#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;1&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xx&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;2&quot;</span>: &#123;<br>        Id:    <span class="hljs-string">&quot;2&quot;</span>,<br>        Name:  <span class="hljs-string">&quot;xxx&quot;</span>,<br>        Phone: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-keyword">type</span> UserServer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserServer)</span></span> GetUser(req GetUserReq, resp *GetUserResp) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> u, ok := users[req.Id]; ok &#123;<br>        *resp = GetUserResp&#123;<br>            Id:    u.Id,<br>            Name:  u.Name,<br>            Phone: u.Phone,<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;未找到用户&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    userServer := <span class="hljs-built_in">new</span>(UserServer)<br>    rpc.Register(userServer)<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;监听客户端连接失败&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> rpc.ServeConn(conn)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> (<br>    GetUserReq <span class="hljs-keyword">struct</span> &#123;<br>        Id <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>    &#125;<br><br>    GetUserResp <span class="hljs-keyword">struct</span> &#123;<br>        Id    <span class="hljs-type">string</span><br>        Name  <span class="hljs-type">string</span><br>        Phone <span class="hljs-type">string</span><br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> client.Close()<br>    <span class="hljs-keyword">var</span> (<br>        req = GetUserReq&#123;<br>            Id: <span class="hljs-string">&quot;3&quot;</span>,<br>        &#125;<br>        res GetUserResp<br>    )<br>    err = client.Call(<span class="hljs-string">&quot;UserServer.GetUser&quot;</span>, req, &amp;res)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;请求异常&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    log.Println(res)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="怎么分析这一块的源码？"><a href="#怎么分析这一块的源码？" class="headerlink" title="怎么分析这一块的源码？"></a>怎么分析这一块的源码？</h3><blockquote><p>源码分析三步</p></blockquote><ol><li><p>目的</p><ol><li>客户端为啥能直接调用服务端的方法</li><li>客户端与服务端的交互的数据格式确定</li></ol></li><li><p>构思实现：</p><ol><li><p>Rpc 之间通讯的数据格式与传输参数</p></li><li><p>Rpc 之间的的通讯数据格式与传输参数</p><p>标准库是通过 json 实现的，需要考虑其他类型转换情况</p></li><li><p>接受到请求消息之后是如何运行对应服务的</p><p>​    <img src="https://i.imgur.com/PTGAkaq.png" alt="image-20241031203029336"></p></li></ol></li><li><p>直接阅读源码</p></li></ol><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p><img src="https://i.imgur.com/cE6mxPs.png" alt="image-20241031203127867"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构</title>
    <link href="/2024/07/12/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/07/12/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="微服务架构整体感受"><a href="#微服务架构整体感受" class="headerlink" title="微服务架构整体感受"></a>微服务架构整体感受</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>什么是微服务架构？</li><li>服务应该如何拆分？</li><li>微服务架构带来了哪些问题？以及如何去解决这些问题。</li></ol><h3 id="典型架构图"><a href="#典型架构图" class="headerlink" title="典型架构图"></a>典型架构图</h3><p><img src="https://i.imgur.com/JXw7vLg.png" alt="image-20240710222819833"></p><p>微服务架构知识内容：</p><ol><li>应用由多个服务构成。</li><li>服务独享自身数据。</li><li>服务会共享配置，使用配置中心来支持。</li><li>服务还会共享中间件，主要缓存、消息队列、搜索、日志等。</li><li>服务间需要通信，第一步需要找到目标服务。需要服务注册中心，提供服务注册和发现。</li><li>服务需要通信，规范通信协议，典型的协议：gRPC，RestFul API，HTTP、MQ。</li><li>应用要响应外部的请求，并将请求转发给目标服务。需要 API 网关技术。</li><li>服务请求需要被控制的管理，使用负载均衡、限流、熔断、降级等控制。</li><li>服务间数据一致性的问题，通常需要分布式事务、分布式锁、分布式 Session。</li><li>服务需要被监控、需要链路追踪、监控平台、日志分析。</li></ol><h3 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h3><ol><li>Go 核心语法，我们需要用 go 编写测试用例。</li><li>Linux 基础操作，需要的程序软件大都安装在 linux 上。</li><li>Web 相关编程技术，需要使用 http 请求响应相关操作。</li></ol><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><h3 id="巨石架构"><a href="#巨石架构" class="headerlink" title="巨石架构"></a>巨石架构</h3><p>早期，大部分的应用程序是将全部的功能模块作为一个整体进行打包、发布、运行。这样程序会越来越大，像一块大石头一样，因此称为巨石架构（the monolithic architecture）。例如，一个商城系统可能包含：分类、商品、购物车、订单、支付、物流、评价、售后、会员、推广、商户等功能模块。那么程序的架构就是：</p><p><img src="https://i.imgur.com/6GYGacV.png" alt="image-20240710223242786"></p><p>巨石应用的劣势：</p><ul><li>更新局部，需要重新部署整体</li><li>整体发布时间过长，包括编译、发布等</li><li>回归测试周期过长</li><li>不利于新技术应用，否则需要重构整体应用</li></ul><p>巨石应用也有自己的优势，例如部署容易，整体打包，整体部署即可；IDE 友好，测试容易、监控方便。</p><h3 id="微服务架构-1"><a href="#微服务架构-1" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构（MicroServices Architecture Pattern）的目的是将大型的、复杂的、长期运行的应用程序（巨石应用）构建为一组相互配合的服务，每个服务都可以很容易得局部改良。<strong>Micro</strong> 意味着服务应该足够小，服务的大小应该从业务逻辑上衡量，而不是用代码量。符合 SRP （单一职责原则）的才叫微服务。</p><p>微服务是去中心化的分布式软件架构。微服务通常是无状态服务。</p><p>微服务架构的优势：</p><ul><li>服务可以使用不同技术栈研发</li><li>每个微服务都可以独立优化，部署或扩展</li><li>更好的故障处理和错误检测</li><li>服务复用性强</li><li>服务扩展性强</li></ul><p>单体应用拆解成大量的微服务，带来的新问题是服务间通信和一致性等问题，通常需要通过服务注册发现、服务网格、分布式锁、分布式事务来解决。</p><p>上面的应用，拆分之后：</p><p><img src="https://i.imgur.com/84ZJjjR.png" alt="image-20240710223419599"></p><h3 id="SOA-与服务"><a href="#SOA-与服务" class="headerlink" title="SOA 与服务"></a>SOA 与服务</h3><p>SOA（Service-Oriented Architecture，面向服务的架构）是一种在计算机环境中设计、开发、部署和管理离散模型的方法。在 SOA 模型中，所有的功能都被定义成了独立的服务，所有的服务通过企业服务总线(ESB, Enterprise Service Bus)或流程管理器来连接。</p><p>带有 ESB 的架构典型如下：</p><p><img src="https://i.imgur.com/8K6F5ei.png" alt="image-20240710223558517"></p><p>微服务架构与 SOA 架构最重要的区别是：</p><ul><li>微服务架构是去中心化的分布式架构</li><li>SOA 是中心化的分布式架构。</li></ul><h3 id="云原生中的微服务"><a href="#云原生中的微服务" class="headerlink" title="云原生中的微服务"></a>云原生中的微服务</h3><p>微服务是云原生技术的核心部分，在微服务架构上运行的现代云原生应用程序依赖于以下关键组件：</p><ul><li>容器化，通过将服务分成多个进程来进行有效的管理和部署，例如 Docker 类平台。</li><li>编排，用于配置、分配和管理服务的可用系统资源，例如 Kubernetes 类平台。</li><li>服务网格，通过服务代理网格进行服务间通信，连接，管理和保护微服务，例如 Istio 类平台。</li></ul><p>以上三个是微服务架构在云原生中最重要的组件，这些组件允许云原生中的应用程序在负载下扩展，甚至在故障期间也能执行。</p><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><p>微服务是化整为零、分而治之的思想。</p><p>拆分原则一览：</p><p><strong>业务拆分：</strong></p><p>业务逻辑拆分，单一职责，服务自身可治理数据库。</p><p>独立功能用例拆分，独立的二方或三方用例，通常拆分为独立服务。例如二方的账号服务和三方的支付服务。</p><p><strong>技术拆分：</strong></p><p>服务的并发性，考虑持续并发、瞬时并发，拆分服务独立。</p><p>服务处理的数据，考虑数据量、读写操作的数据、冷热数据量、边长定长数据类型，将服务拆分。</p><p>服务的安全等级，考虑服务业务、数据的安全等级、采用不同的安全策略，来进行拆分。</p><p>服务需要的资源，考虑服务需要计算、I&#x2F;O、网络、存储等资源、来进行拆分。</p><p>服务扩展性，考虑服务中技术、业务等的更新率、扩展率，进行拆分。</p><p>架构的稳定性，考虑单体服务的技术架构稳定性。</p><p>便于测试，测试可集成、可回溯。</p><p>便于监控，便于日志分析、指标监控等。</p><p><strong>项目拆分：</strong></p><p>团队（开发、测试、运维）小而美。小指的是规模，团队通常 10 人左右；美指的是团队可自治，与其他团队人员协调尽量少。</p><p>成本因素，考虑技术（学习）成本、人力成本、时间成本、设施成本，来拆分服务。</p><h3 id="AKF-扩展立方体"><a href="#AKF-扩展立方体" class="headerlink" title="AKF 扩展立方体"></a>AKF 扩展立方体</h3><p>立方体图：</p><p><img src="https://i.imgur.com/VWvqOOl.png" alt="image-20240711113639989"></p><h4 id="X-轴，克隆扩展（水平复制）"><a href="#X-轴，克隆扩展（水平复制）" class="headerlink" title="X 轴，克隆扩展（水平复制）"></a>X 轴，克隆扩展（水平复制）</h4><p>X轴，代表无差别服务和数据的克隆，也称水平扩展。它指的是，相同的服务部署多个，通过负载均衡器在多个应用间做选择。</p><p>图例：</p><p><img src="https://i.imgur.com/98Xf4y3.png" alt="image-20240711113729258"></p><h4 id="Y-轴，功能拆分扩展"><a href="#Y-轴，功能拆分扩展" class="headerlink" title="Y 轴，功能拆分扩展"></a>Y 轴，功能拆分扩展</h4><p>Y轴，代表依据资源、服务或功能进行拆分。指的是把任何特定功能的操作以及操作所需的数据资源从整体（或其他操作）中分离出来。X 轴体现的是相同功能的复制，而 Y 轴体现的是多个不同功能的组合。</p><p>如图：用户购买商品，需要浏览商品信息、购买、订单管理、支付等操作，依据功能将应用拆分为：</p><p><img src="https://i.imgur.com/lyE8H0n.png" alt="image-20240711113804383"></p><p>这种拆分，就是典型微服务架构中业务逻辑的拆分方案，每个服务负责具体的某个特定功能，整体应用由多个服务组成。</p><p>同样，若某个服务需要更多的资源，也可以采用 X 轴扩展模式，例如上图中的订单服务。</p><h4 id="Z-轴，数据拆分扩展"><a href="#Z-轴，数据拆分扩展" class="headerlink" title="Z 轴，数据拆分扩展"></a>Z 轴，数据拆分扩展</h4><p>当业务基于 X、Y 做了克隆或拆分后，数据存储的压力需要通过 Z 轴扩展解决。Z 轴扩展通常指的是数据库拆分。数据库拆分如依据地域划分、依据不同功能的表划分或将表中的记录依据主键hash（或其他分区算法）划分等。</p><p>地域：</p><p><img src="https://i.imgur.com/njoLZmv.png" alt="image-20240711113907153"></p><p>基于功能：</p><p><img src="https://i.imgur.com/7XsuXnX.png" alt="image-20240711113957121"></p><p>记录划分：</p><p><img src="https://i.imgur.com/j1C2q2p.png" alt="image-20240711114009105"></p><h4 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h4><p>坐标原点 (0, 0, 0) 表示应用系统的最小扩展性。</p><h3 id="SRP-单一职责原则"><a href="#SRP-单一职责原则" class="headerlink" title="SRP 单一职责原则"></a>SRP 单一职责原则</h3><p>单一职责原则，应该表达最朴素的一个原则了，顾名思义，就是一个服务负责单独的一个职责，就意味着我们的设计满足单一职责。</p><p>SRP，Single Responsibility Principle，单一职责原则来自于面向对象设计的基本原则，是这么说的：</p><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>映射到我们微服务其实就是：对于服务而言，应该只有一个理由引起它的变化。</p><p>也就是，一个服务的功能要单一，只做与之相关的事情，在服务的设计过程中要按照职责进行设计。如果需要更多功能呢，那么就需要更多的服务，服务彼此互不干涉。</p><p>单一职责原则在使用时，要注意粒度，也就是我们应该将单体服务的规模设计多大。如果粒度过细，会导致在开发、测试、部署上都会带来额外的负担。同样若粒度过粗，那么特定功能的更新，直接会导致整体服务更新。因此，我们在拆分服务时，除了要考虑功能性，还要考虑和预测需求的变化点、变化率，以及数据增长点、并发热点等，相互结合，设计出相对平衡的独立服务。</p><p>例如，对于商品服务，商品的品牌、标签、属性、库存等，是否需要独立设计为一个服务呢？这个需要基于我们自身的业务逻辑进行设计。这个例子中，库存通常需要独立服务设计的，因为库存在订单生成和仓库管理时，会被高频率使用。而其他功能，通常隶属于商品服务的范畴。</p><p>SRP 原则通常也会被表述为服务设计的高内聚低耦合。内聚度是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好只做一件事，高内聚就是一个类封装的很完善，每个类只完成一项任务，也就是常说的单一责任原则。   耦合度是对模块间关联程度的度量，模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系，模块间联系越多，耦合性越强，模块的独立性越差。</p><h3 id="DDD-领域设计"><a href="#DDD-领域设计" class="headerlink" title="DDD 领域设计"></a>DDD 领域设计</h3><h2 id="微服务架构需要解决的问题"><a href="#微服务架构需要解决的问题" class="headerlink" title="微服务架构需要解决的问题"></a>微服务架构需要解决的问题</h2><h3 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h3><h3 id="服务间发现"><a href="#服务间发现" class="headerlink" title="服务间发现"></a>服务间发现</h3><h3 id="服务间通讯"><a href="#服务间通讯" class="headerlink" title="服务间通讯"></a>服务间通讯</h3><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="熔断和降级"><a href="#熔断和降级" class="headerlink" title="熔断和降级"></a>熔断和降级</h3>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux &amp; Hyperland</title>
    <link href="/2024/05/15/Linux/Arch%20linux%20&amp;%20Hyperland/"/>
    <url>/2024/05/15/Linux/Arch%20linux%20&amp;%20Hyperland/</url>
    
    <content type="html"><![CDATA[<h1 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h1><h2 id="发行版选择"><a href="#发行版选择" class="headerlink" title="发行版选择"></a>发行版选择</h2><p>Arch Linux 有很多发行版，笔者采用 <strong>EndeavourOS</strong></p><p><strong>EndeavourOS</strong>是轻量级的，并且附带了最少数量的预装应用程序。一块近乎空白的画布，随时可以个性化。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装教程有很多，在这不做过多阐述，笔者推荐一个做启动盘的工具。<a href="https://www.ventoy.net/en/index.html">ventoy</a></p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>笔者最开始安装 Arch Linux 发行版，遇到了很多问题，尝试使用 Docker 安装 <code>V2rayA</code>，来走 <code>tun</code>代理，但是失败了，后面通过 <code>yay</code> 安装 <code>clash verge rev</code>来实现代理，下面展示安装步骤</p><h3 id="Clash-Verge-rev"><a href="#Clash-Verge-rev" class="headerlink" title="Clash Verge rev"></a>Clash Verge rev</h3><blockquote><p>由于安装 <code>clash verge rev</code>需要从 <code>github</code>下载，因此需要使用代理，笔者因为还有其他电脑，再其他电脑上开启了局域网代理</p></blockquote><p><img src="https://i.imgur.com/9RksGFa.png" alt="image-20250515100402352"></p><p>然后再 linux 上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=http://xxx:7890 http_proxy=http://xxx:7890 all_proxy=socks5://xxx:7890<br></code></pre></td></tr></table></figure><p>安装 <code>clash verge rev</code></p><ol><li><p>paru</p><ol><li><p>安装 <code>paru</code></p><ol><li><p>在 <code>/etc/pacman.conf</code> 文件中写入下列内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[archlinuxcn]<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.hit.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://repo.huaweicloud.com/archlinuxcn/<span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure></li><li><p>在终端运行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman-key --lsign-key <span class="hljs-string">&quot;farseerfc@archlinux.org&quot;</span><br><span class="hljs-built_in">sudo</span> pacman -S archlinuxcn-keyring<br><span class="hljs-built_in">sudo</span> pacman -S paru<br></code></pre></td></tr></table></figure></li></ol></li><li><p>安装 <code>clash-verge-rev-bin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>yay</code></p><ol><li><p>安装 <code>yay</code></p><ol><li><p>在 <code>/etc/pacman.conf</code> 文件中写入下列内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[archlinuxcn]<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.hit.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span><br>Server = https://repo.huaweicloud.com/archlinuxcn/<span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure></li><li><p>在终端运行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman-key --lsign-key <span class="hljs-string">&quot;farseerfc@archlinux.org&quot;</span><br><span class="hljs-built_in">sudo</span> pacman -S archlinuxcn-keyring<br><span class="hljs-built_in">sudo</span> pacman -S yay<br></code></pre></td></tr></table></figure></li></ol></li><li><p>安装 <code>clash-verge-rev-bin</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li><p>安装 docker、docker-compose</p></li><li><p>docker-compose.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">v2ray:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mzz2017/v2raya</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">host</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">v2ray</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/v2ray/:/etc/v2raya</span><br></code></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker-compose up -d<br></code></pre></td></tr></table></figure></li><li><p>使用方法 </p><p>参考<a href="https://v2raya.org/docs/prologue/installation/docker/">v2rayA</a></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://clashverge.uk/install/install">Arch Linux 下载</a></p></li><li><p><a href="https://www.ventoy.net/en/index.html">ventoy</a></p></li><li><p><a href="https://v2raya.org/docs/prologue/installation/docker/">v2rayA</a></p></li></ul><h1 id="Hyperland"><a href="#Hyperland" class="headerlink" title="Hyperland"></a>Hyperland</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>笔者使用的是 <a href="https://github.com/HyDE-Project/HyDE">Hyde</a>，一键安装即可</p><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>安装完成 Hyperland，可以开始处理中文输入法，笔者使用 <code>fcitx5</code></p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fctix5-im fcitx5-chinese-addons<br></code></pre></td></tr></table></figure></li><li><p>配置</p><ol><li><p>设置启动使用 <code>fctix5</code></p><p>在 <code>~/.config/hypr/hyprland.conf</code> 里添加，然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exec-once=fcitx5 --replace -d<br></code></pre></td></tr></table></figure></li><li><p>wayland 在 electron 应用下可能会存在问题，需要设置 electron 参数</p><p>编辑 <code>~/.config/electron-flags.conf</code>，然后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">--enable-features=UseOzonePlatform<br>--ozone-platform=wayland<br>--enable-wayland-ime<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>笔者遇到的问题，每次开机可能都需要输入 wifi 密码，需要切换到 KDE 下，将 wifi 设置为所有账户可以连接，然后再切换到 Hyperland</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/HyDE-Project/HyDE">Hyperland 配置</a></li><li><a href="https://www.bilibili.com/opus/817423840849166391">输入法安装</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Arch</category>
      
      <category>Linux</category>
      
      <category>Hyperland</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>钉钉单点登录</title>
    <link href="/2024/05/15/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/%E9%92%89%E9%92%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <url>/2024/05/15/%E5%B7%A5%E4%BD%9C/%E5%B9%82%E5%BE%8B/%E9%92%89%E9%92%89%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="钉钉单点登录"><a href="#钉钉单点登录" class="headerlink" title="钉钉单点登录"></a>钉钉单点登录</h1><p>公司需要通过自建应用实现应用单点到我们系统，在此基础上通过创建钉钉应用，实现单点登录，以及发送消息等功能。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><pre><code class=" mermaid">sequenceDiagram    participant User as 用户    participant App as 应用系统    participant DingTalk as 钉钉    participant Backend as 后端服务    User-&gt;&gt;App: 访问登录页    App-&gt;&gt;DingTalk: 跳转钉钉扫码登录页面    User-&gt;&gt;DingTalk: 使用钉钉扫码授权    DingTalk--&gt;&gt;App: 回调授权码（auth_code）    App-&gt;&gt;Backend: 携带 auth_code 请求登录    Backend-&gt;&gt;DingTalk: 使用 auth_code 请求用户信息    DingTalk--&gt;&gt;Backend: 返回用户信息（userId、unionId等）    Backend--&gt;&gt;App: 返回登录成功状态 + 用户信息    App--&gt;&gt;User: 登录成功，进入系统</code></pre><h3 id="1-创建自定义应用"><a href="#1-创建自定义应用" class="headerlink" title="1. 创建自定义应用"></a>1. 创建自定义应用</h3><blockquote><p>需要拥有开发者或则管理员权限 </p><p>钉钉开放平台:<a href="https://open-dev.dingtalk.com/fe/app?hash=%23/corp/app#/corp/app">https://open-dev.dingtalk.com/fe/app?hash=%23%2Fcorp%2Fapp#/corp/app</a></p></blockquote><p>钉钉开放平台-&gt;创建应用</p><p><img src="https://i.imgur.com/vsLHIv9.png" alt="image-20250512154727832"></p><p><img src="https://i.imgur.com/gzK6JzV.png" alt="image-20250512154756148"></p><h3 id="2-给应用申请权限"><a href="#2-给应用申请权限" class="headerlink" title="2. 给应用申请权限"></a>2. 给应用申请权限</h3><p>点击刚创建的应用-&gt;权限管理<br><img src="https://i.imgur.com/WV5HakS.png" alt="image-20250512154853116"></p><p>申请权限列表为：</p><ol><li>Contact.User.Read</li><li>fieldEmail</li><li>qyapi_get_member</li><li>qyapi_get_omp_sso_userinfo</li><li>open_app_api_base</li><li>api_get_member_by_mobile</li></ol><p>应该这几个就行了，可能实际会有变化</p><p>输入框中输入上述code点击申请（已申请按钮会变成移除权限）</p><h3 id="3-添加网页应用能力"><a href="#3-添加网页应用能力" class="headerlink" title="3. 添加网页应用能力"></a>3. 添加网页应用能力</h3><h3 id="4-添加网页应用能力"><a href="#4-添加网页应用能力" class="headerlink" title="4. 添加网页应用能力"></a>4. 添加网页应用能力</h3><p>填写网页地址，地址为：<a href="https://wiki.chenhailong.com/workBench?in=dingtalk&orgId=%E6%9C%BA%E6%9E%84%E5%8F%B7id">https://wiki.chenhailong.com/workBench?in=dingtalk&amp;orgId=机构号id</a></p><p><img src="https://i.imgur.com/QH53eiR.png" alt="image-20250512154955250"></p><p><img src="https://i.imgur.com/GEGmnP1.png" alt="image-20250512155042874"></p><h3 id="5-分享设置"><a href="#5-分享设置" class="headerlink" title="5. 分享设置"></a>5. 分享设置</h3><blockquote><p>域名为：<a href="https://wiki.chenhailong.com/">https://wiki.chenhailong.com</a></p></blockquote><p>在分享设置中设置域名（表示当前应用对那些域名可见）</p><p><img src="https://i.imgur.com/oaUFFCZ.png" alt="image-20250512155257515"></p><h3 id="6-发送消息"><a href="#6-发送消息" class="headerlink" title="6. 发送消息"></a>6. 发送消息</h3><p>需要提供 appID 和 corpID</p><ul><li><p>appID<br><img src="https://i.imgur.com/173rw26.png" alt="image-20250512155440848"></p></li><li><p>corpID</p><p><img src="https://i.imgur.com/vayv9wE.png" alt="image-20250512155513766"></p></li></ul><h1 id="单点登录方案"><a href="#单点登录方案" class="headerlink" title="单点登录方案"></a>单点登录方案</h1><h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><ol><li><p>应用创建配置网页应用携带了 <code>in=dingtalk&amp;orgId=chenhailong</code></p><ol><li><code>dingtalk</code>: 表示从dingtalk 平台进行登录，业务前端如果识别到当前未处于登录态，需要调用后端接口 <code>oauth_uri</code> 来进行跳转</li><li><code>orgId</code>: 多租户时使用</li></ol></li><li><p>调用 <code>oauth_uri</code>接口，返回钉钉的一个跳转页面，然后进行跳转</p></li><li><p>钉钉确认登录之后会调用后台接口 <code>call_back</code>，然后拿到用户信息</p></li><li><p>前提： 需要在后台数据库中存放租户下的钉钉配置，后续是需要使用的</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>钉钉</category>
      
      <category>单点登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务概览</title>
    <link href="/2024/05/11/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/"/>
    <url>/2024/05/11/Golang/%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务-一-微服务概览"><a href="#微服务-一-微服务概览" class="headerlink" title="微服务(一) 微服务概览"></a>微服务(一) 微服务概览</h1><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>先问自己几个问题，看是否可以回答，下面我们就带着问题总结课程的内容</p><ul><li>为什么会有微服务？</li><li>微服务是什么？</li><li>微服务可以带来什么好处，又有那些缺点？</li><li>微服务如何构建？</li><li>微服务如何对外暴露？</li><li>微服务如何拆分？</li><li>如何保证微服务之间的安全？</li></ul><h3 id="Q1-为什么会有微服务？"><a href="#Q1-为什么会有微服务？" class="headerlink" title="Q1:为什么会有微服务？"></a>Q1:为什么会有微服务？</h3><ul><li>之前一般是一个单一的巨石架构，存在很多问题<ul><li>应用比较复杂，没有人能够搞懂</li><li>应用扩展比较复杂，可靠性比较低</li><li>无法进行敏捷开发和部署</li></ul></li><li>所以一般这个时候就会考虑按照服务、功能进行拆分</li></ul><h3 id="Q2-微服务是什么？"><a href="#Q2-微服务是什么？" class="headerlink" title="Q2:微服务是什么？"></a>Q2:微服务是什么？</h3><ul><li>SOA （面向服务）是什么？<ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li>**单一职责，**一个服务只做一件事情</li><li>**尽可能的早的创建原型，**先定义 API，达成契约</li><li>**可移植性比效率更重要，**通讯协议的可移植性更加重要</li></ul></li><li>SOA 和 微服务 是什么关系？<ul><li>微服务是 SOA 的一种实践，微服务也是面向服务的一种架构</li></ul></li><li>微服务是什么？<ul><li><strong>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术</strong></li></ul></li></ul><h3 id="Q3-微服务可以带来哪些好处，又有哪些缺点？"><a href="#Q3-微服务可以带来哪些好处，又有哪些缺点？" class="headerlink" title="Q3:微服务可以带来哪些好处，又有哪些缺点？"></a>Q3:微服务可以带来哪些好处，又有哪些缺点？</h3><ul><li><p>优点</p><ul><li>服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展</li><li>**原子服务，**一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去</li><li>**独立进程，**一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处</li><li>**隔离部署，**每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本</li><li>去中心化服务治理<ul><li>数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台</li><li>治理去中心化</li><li>技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>服务之间的依赖关系复杂成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。</p><ul><li>常见的解决方案：全链路追踪，例如， opentracing</li></ul></li><li><p>微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</p><ul><li>例子：服务调用流量会容易被放大，如果 服务 A -&gt; B -&gt;C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的</li><li><strong>常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡</strong></li></ul></li><li><p>会有分布式事务问题，</p><p>因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦</p><ul><li>常见解决方案：两阶段提交、TCC 等</li><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米信息部技术团队: 分布式事务，这一篇就够了</a></li></ul></li><li><p>测试会非常复杂，</p><p>由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题</p><ul><li>常见解决方案：独立测试环境，后面会有一个解决方案</li></ul></li><li><p>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。</p><ul><li>切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，<strong>时刻谨记保持服务契约(接口)的兼容性</strong></li><li>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</li></ul></li><li><p>对基础建设的要求很高，</p><p>基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等</p><ul><li>常见解决方案：上云</li></ul></li></ul><h3 id="Q4-微服务如何构建？"><a href="#Q4-微服务如何构建？" class="headerlink" title="Q4: 微服务如何构建？"></a>Q4: <strong>微服务如何构建？</strong></h3><blockquote><p>多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p></blockquote><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><h3 id="Q5-微服务如何对外暴露？"><a href="#Q5-微服务如何对外暴露？" class="headerlink" title="Q5:微服务如何对外暴露？"></a>Q5:<strong>微服务如何对外暴露？</strong></h3><p><img src="https://i.imgur.com/qejM7Jh.png" alt="1718629799961"></p></li></ul><h4 id="流量链路是什么？"><a href="#流量链路是什么？" class="headerlink" title="流量链路是什么？"></a>流量链路是什么？</h4><ul><li>移动端 -&gt; API Gateway -&gt; BFF -&gt; 微服务</li><li>不含 CDN、负载均衡（LB）</li><li>BFF 纯 web 的业务一般用 nodejs 做 SSR</li></ul><h4 id="为什么我们的服务不直接对外进行暴露？"><a href="#为什么我们的服务不直接对外进行暴露？" class="headerlink" title="为什么我们的服务不直接对外进行暴露？"></a>为什么我们的服务不直接对外进行暴露？</h4><ul><li>前端（移动端、客户端、web）同学非常痛苦，需要对接多个服务，兼容性差，沟通效率低</li><li>后端同学也很痛苦，一年前的版本都有人使用，服务无法进行重构升级</li></ul><h4 id="为什么需要最外层的-api-gateway"><a href="#为什么需要最外层的-api-gateway" class="headerlink" title="为什么需要最外层的 api gateway?"></a>为什么需要最外层的 api gateway?</h4><ul><li>基础库的同学非常痛苦，限流熔断安全等业务无关的功能需要进行升级的时候升不动</li></ul><h3 id="Q6-微服务如何拆分？"><a href="#Q6-微服务如何拆分？" class="headerlink" title="Q6: 微服务如何拆分？"></a>Q6: <strong>微服务如何拆分？</strong></h3><ul><li><p>在对业务领域不是特别熟悉的时候，按照<strong>部门职能进行划分，例如账号、财务等</strong></p><ul><li>注意划分的时候<strong>要闭环</strong>，不要相同的功能散落到几个部门当中</li></ul></li><li><p>在系统稳定之后，积累了相关的业务经验和微服务开发经验之后，再考虑使用 DDD 限界上下文进行划分</p></li><li><p>如果可以闭环的解决一个用户场景，那么它应该是一个微服务</p></li><li><p>还可以根据访问频率进行区分划分，将用户高频访问的部分划分为一个服务</p></li><li><p>还可以根据读写进行划分</p><ul><li><p>CQRS: 将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</p><p><img src="https://i.imgur.com/k83Ex8Q.png" alt="1718630014302"></p></li></ul></li></ul><h3 id="Q7-如何保证微服务之间的安全？"><a href="#Q7-如何保证微服务之间的安全？" class="headerlink" title="Q7:如何保证微服务之间的安全？"></a>Q7:<strong>如何保证微服务之间的安全？</strong></h3><p><img src="https://i.imgur.com/aUAJjYf.png" alt="1718630058407"></p><p>在内网主要看安全级别一般有三种：</p><ul><li>Full Trust：假定内网服务之间是安全的，在内网裸奔</li><li>Half Trust：内网服务之间需要进行认证鉴权，但是不需要所有的都进行加密</li><li>Zero Trust: 零信任，任务内部网络是不安全的，类似公网，所有的请求通过身份认证鉴权之后，都需要通过安全加密，防止被嗅探<ul><li><a href="https://www.microsoft.com/en-us/security/business/zero-trust">https://www.microsoft.com/en-us/security/business/zero-trust</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>进阶训练营</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶训练营</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
